
* 第 11 章 字符串和字符串函数

** 表示字符串和字符串 I/O
*** COMMENT 在程序中定义字符串
    字符串定义方式
    1. 字符串字面量(字符串常量)
       用双引号括起来的内容成本为字符串字面量(string literal), 也叫做字符串常量
       (string constant). 双引号中的字符串和编译器自动加入末尾的 ~\0~ 字符, 都作
       为字符串储存在内容中, 所以 ~"I am a symbolic string constant"~, ~"I am a
       string in an array."~, ~"Something is pointed at me."~, ~"Here are
       some strings:"~ 都是字符串字面量.

       从 ANSI C 标准起, 如果字符串字面量之间没有间隔, 或者空白字符分割, C 会将其
       视为串联起来的字符串字面量, 例如:
       #+begin_src c
         char greeting[50] = "Hello, and "" how are" "you"
             " today!";
         // 与下面代码等价:
         char greeting[50] = "Hello, and how are you today!";
       #+end_src
       如果要在字符串内部使用双引号, 必须转义

       字符串常量属于静态存储类别(static storage class), 这说明在函数中使用字符
       串常量, 该字符串只会被储存一次, 在整个程序的生命期内存在, 即使函数被调用
       多次. 用双引号括起来的内容被视为指向该字符串储存位置的指针. 这类似于把数
       组名作为指向该数组位置的指针.

    2. 字符串数组和初始化
       定义字符串数组时, 必须让编译器知道需要多少空间. 一种方法是用足够空间的数
       组储存字符串. 
       #+begin_src c
         const char m1[40] = "Limit yourself to one line's worth.";
       #+end_src
       ~const~ 表名不会更改这个字符串

       这种形式的初始化比标准的数组初始化形式简单的多:
       #+begin_src c
         const char m1[40] = { 'L', 'i', 'm', 'i', 't', '', 'y', 'o', 'u', 'r', 's', 'e', 'l', 'l'
                               , 'f', '', 't', 'o', '', 'o', 'n', 'e', '', 'l', 'i', 'n', 'e', '\',
                               , 's', ' ', 'w', 'o', 'r', 't', 'h', '.', '\0'};
       #+end_src

       *注意最后的空字符*, 没有这个空字符, 就是一个字符数组而不是一个字符串

       在指定数组大小时, 要确保数组的元素个数至少比字符串长度 *多 1* (为了容纳空
       字符). 所有未被使用的元素都被自动初始化为 0

       通常, 让编译器确定数组的大小很方便且合理. 因为处理字符串的函数通常不知道
       数组的大小, 这些函数通过查找字符串末尾的空字符来确定字符串在何处结束

       让编译器计算数组大小只能用在 *初始化* 时. 如果创建一个稍后再填充的数组,
       就必须在声明时指定大小.

       字符数组名和其他数组名一样, 是该数组首元素的地址. 因此, 假设有如下代码:
       #+begin_src c
         char car[10] = "Tata";
       #+end_src

       以下表达式为 '真':
       #+begin_src c
         car == &car[0];
         *car == 'T';
         *(car + 1) == car[1] == 'a';
       #+end_src

       还可以用 *指针表示法* 创建字符串:
       #+begin_src c
         const char* pt1 = "Something is pointing at me";
       #+end_src
       该声明与下面的声明几乎相同:
       #+begin_src c
         const char ar1[] = "Something is pointing at me";
       #+end_src
       以上 2 个声明表名, ~pt1~ 和 ~ar1~ 都是该字符串的地址. 尽管如此, 这两种形式
       *并不完全相同*

    3. 数组和指针
       - 数组形式(~ar[n]~): 在计算机的内存中分配一个内含 n 个元素的数组(每个元素对
         应一个字符, 还加上一个末尾的空字符 ~'\0'~), 每个元素被初始化为字符串字
         面量对应的字符. 冗长, 字符串都作为可执行文件的一部分储存在数据段中. 当
         把程序载入内存时, 也载入了程序中的字符串. 字符串储存在静态存储区(static
         memory)中. 但是, 程序在 *开始运行时才会为该数组分配内存*. 此时, 才将字
         符串拷贝到数组中.
         *注意*: 此时字符串有 2 个副本, 一个是静态内存中的字符串字面量, 一个是储存
         在 ~ar~ 数组中的字符串

         此后, 编译器便吧数组名 ~ar~ 识别为该数组首元素地址(~&ar[0]~)的别名. 这
         里关键要理解, 在数组形式中, ~ar~ 是地址常量, *不能更改* ~ar~, 如果改变了
         ~ar~, 则意味着改变了数组的存储位置(即地址). 可以进行类似 ~ar + 1~ 这样
         的操作, 标识数组的下一个元素. 但是 *不允许进行 ~++ar~ 这样的操作*.

       - 指针形式(~*pt1~): 也使得编译器为字符串在静态储存区预留相应元素的空间. 另
         外, 一旦开始执行程序, 它会为指针变量 ~pt1~ 流出一个存储位置, 并把字符串
         的地址储存在指针变量中. 该变量最初指向该字符串的首字符, 但是它的值可以
         改变. 因此, *可以使用* 递增运算符. 例如: ~++pt1~ 将指向第 2 个字符

         字符串字面量被视为 ~const~ 数组. 由于 ~pt1~ 指向这个数据, 所以应该把
         ~pt1~ 声明为指向 ~const~ 数组的指针. 这意味着不能用 ~pt1~ 改变它所指向
         的数据, 但是仍然可以改变 ~pt1~ 的值.

         *初始化数组把静态存储区的字符串拷贝到数组中, 而初始化指针只把字符串的地
         址拷贝给指针*

    4. 数组和指针的区别
       - 数组名是 *常量*: 数组名不可再次赋值

       - 指针名是 *变量*: 只有指针可以进行递增操作
         
         const 限定符的指针初始化:
         #+begin_src c
           char* word = "frame";

           word[1] = 'l';
         #+end_src
         编译器 *可能允许* 这样做, 但是对当前的 C 标准而言, 这样的行为是未定义的,
         这样的语句可能导致内存访问错误. 
         原因: 编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量

         *建议*: 在把指针初始化为字符串字面量时使用 const 限定符
         
         把非 const 数组初始化为字符串字面量缺不会导致类似的问题. 因为数组获得的
         是原始字符串的 *副本*

       - 字符串数组
         指针数组效率高但不可修改, 而多维数组中内容可以修改

*** 指针和字符串 
    拷贝地址比拷贝整个字符串(数组)高效

** 字符串输入
*** 分配空间
    假设编写了如下代码:
    #+begin_src c
      char* name;
      scanf("%s", name);
    #+end_src
    虽然可能通过编译(警告), 但是在读入 ~name~ 时, ~name~ 可能会擦写掉程序中的数
    据或代码, 从而导致程序异常终止. 因为 ~scanf()~ 要把信息拷贝至参数指定的地址
    上, 而此时该参数是个未初始化的指针, ~name~ 可能会指向任何地方.

*** 不幸的 ~gets()~ 函数
    ~gets()~ 函数简单易用, 读取整行输入, 直至遇到换行符, 然后丢弃换行符, 储存其
    余字符, 并在这些字符的末尾添加一个空字符使其成为一个 C 字符串. 经常和
    ~puts()~ 配对使用, 该函数用于显示字符串, 并在末尾添加换行符.

    *警告*: ~gets()~ 的唯一参数 *无法检查数组是否装得下输入行*, 数组名会被转换成
     该数组首元素的地址, 因此, ~gets()~ 只知道数组的开始处, 并不知道数组中有多少
     个元素

     如果输入的字符串过长, 会导致 *缓冲区溢出(buffer overflow)*. 即多余的字符超
     出了指定的目标空间. 如果这些多余的字符只是占用了尚未使用的内存, 就不会立即
     出现问题; 如果他们擦写掉程序中的其他数据, 会导致程序异常中止; 或者还有其他
     情况

     C11 标准 *废除* 了 ~gets()~ 函数

*** ~gets()~ 的替代品
    过去通常使用 ~fgets()~ 来替代 ~gets()~. C11 标准新增的 ~gets_s()~ 函数也可以
    代替 ~gets()~. 但是它是 ~stdio.h~ 输入/输出函数系列的 *可选* 扩展, 所以支持
    C11 的编译器也不一定支持它

    1. ~fgets()~ 函数(和 ~fputs()~)
       ~fgets()~ 函数通过第二个参数限制读入字符数来解决移除的问题. 该函数专门设
       计用于处理文件输入, 所以一般情况下可能不太好用. 与 ~gets()~ 的区别:
       - ~fgets()~ 函数的第 2 个参数指明了读入字符的最大数量. 如果该参数的值是 n,
         那么 ~fgets()~ 将读入 n-1 个字符, 或者读到遇到的第一个换行符位置
       - 如果 ~fgets()~ 读到一个换行符, 会把它存储在字符串中. 这点与 ~gets()~ 不
         同, ~gets()~ 会丢弃换行符
       - ~fgets()~ 函数的第 3 个参数指明要读入的文件. 如果读入从键盘输入的数据, 则
         以 stdin(标准输入作为参数), 该标识符定义在 ~stdio.h~ 中
       - 因为 ~fgets()~ 函数把换行符放在字符串的末尾(假设输入行不溢出), 通常要与
         ~fputs()~ 函数(和 ~puts()~ 类似) 配对使用, 除非该函数不再字符串末尾添加
         换行符. ~fputs()~ 函数的第 2 个参数指明它要写入的文件. 如果要显示在计算机
         显示器上, 应使用 stdout(标准输出) 作为该参数
       - ~fputs()~ 函数 *不会在字符串末尾添加一个换行符*, ~fputs()~ 函数返回指向
         char 的指针. 如果一切进行顺利, 该函数返回的地址与传入的第一个参数相同.
         如果函数读到文件结尾, 它将返回一个特殊的指针: 空指针 (null pointer). 该
         指针保证不会指向有效的数据, 代码中可以用数字 0 来代替, 不过在 C 语言中用
         宏 ~NULL~ 来代替更常见(如果读入错误, 也返回 ~NULL~)

         系统使用缓冲的 I/O, 这意味着用于按下 ~Return~ 键之前, 输入都被存储在临
         时存储区(即, 缓冲区) 中. 按下 ~Return~ 键就在输入中增加了一个换行符, 并
         把整行输入发送给 ~fgets()~. 对于输出, ~fputs()~ 把字符发送给另一个缓冲
         区, 当发送换行符时, 缓冲区的内容被发送至屏幕上
