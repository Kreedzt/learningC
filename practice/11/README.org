
* 第 11 章 字符串和字符串函数

** 表示字符串和字符串 I/O
*** COMMENT 在程序中定义字符串
    字符串定义方式
    1. 字符串字面量(字符串常量)
       用双引号括起来的内容成本为字符串字面量(string literal), 也叫做字符串常量
       (string constant). 双引号中的字符串和编译器自动加入末尾的 ~\0~ 字符, 都作
       为字符串储存在内容中, 所以 ~"I am a symbolic string constant"~, ~"I am a
       string in an array."~, ~"Something is pointed at me."~, ~"Here are
       some strings:"~ 都是字符串字面量.

       从 ANSI C 标准起, 如果字符串字面量之间没有间隔, 或者空白字符分割, C 会将其
       视为串联起来的字符串字面量, 例如:
       #+begin_src c
         char greeting[50] = "Hello, and "" how are" "you"
             " today!";
         // 与下面代码等价:
         char greeting[50] = "Hello, and how are you today!";
       #+end_src
       如果要在字符串内部使用双引号, 必须转义

       字符串常量属于静态存储类别(static storage class), 这说明在函数中使用字符
       串常量, 该字符串只会被储存一次, 在整个程序的生命期内存在, 即使函数被调用
       多次. 用双引号括起来的内容被视为指向该字符串储存位置的指针. 这类似于把数
       组名作为指向该数组位置的指针.

    2. 字符串数组和初始化
       定义字符串数组时, 必须让编译器知道需要多少空间. 一种方法是用足够空间的数
       组储存字符串. 
       #+begin_src c
         const char m1[40] = "Limit yourself to one line's worth.";
       #+end_src
       ~const~ 表名不会更改这个字符串

       这种形式的初始化比标准的数组初始化形式简单的多:
       #+begin_src c
         const char m1[40] = { 'L', 'i', 'm', 'i', 't', '', 'y', 'o', 'u', 'r', 's', 'e', 'l', 'l'
                               , 'f', '', 't', 'o', '', 'o', 'n', 'e', '', 'l', 'i', 'n', 'e', '\',
                               , 's', ' ', 'w', 'o', 'r', 't', 'h', '.', '\0'};
       #+end_src

       *注意最后的空字符*, 没有这个空字符, 就是一个字符数组而不是一个字符串

       在指定数组大小时, 要确保数组的元素个数至少比字符串长度 *多 1* (为了容纳空
       字符). 所有未被使用的元素都被自动初始化为 0

       通常, 让编译器确定数组的大小很方便且合理. 因为处理字符串的函数通常不知道
       数组的大小, 这些函数通过查找字符串末尾的空字符来确定字符串在何处结束

       让编译器计算数组大小只能用在 *初始化* 时. 如果创建一个稍后再填充的数组,
       就必须在声明时指定大小.

       字符数组名和其他数组名一样, 是该数组首元素的地址. 因此, 假设有如下代码:
       #+begin_src c
         char car[10] = "Tata";
       #+end_src

       以下表达式为 '真':
       #+begin_src c
         car == &car[0];
         *car == 'T';
         *(car + 1) == car[1] == 'a';
       #+end_src

       还可以用 *指针表示法* 创建字符串:
       #+begin_src c
         const char* pt1 = "Something is pointing at me";
       #+end_src
       该声明与下面的声明几乎相同:
       #+begin_src c
         const char ar1[] = "Something is pointing at me";
       #+end_src
       以上 2 个声明表名, ~pt1~ 和 ~ar1~ 都是该字符串的地址. 尽管如此, 这两种形式
       *并不完全相同*

    3. 数组和指针
       - 数组形式(~ar[n]~): 在计算机的内存中分配一个内含 n 个元素的数组(每个元素对
         应一个字符, 还加上一个末尾的空字符 ~'\0'~), 每个元素被初始化为字符串字
         面量对应的字符. 冗长, 字符串都作为可执行文件的一部分储存在数据段中. 当
         把程序载入内存时, 也载入了程序中的字符串. 字符串储存在静态存储区(static
         memory)中. 但是, 程序在 *开始运行时才会为该数组分配内存*. 此时, 才将字
         符串拷贝到数组中.
         *注意*: 此时字符串有 2 个副本, 一个是静态内存中的字符串字面量, 一个是储存
         在 ~ar~ 数组中的字符串

         此后, 编译器便吧数组名 ~ar~ 识别为该数组首元素地址(~&ar[0]~)的别名. 这
         里关键要理解, 在数组形式中, ~ar~ 是地址常量, *不能更改* ~ar~, 如果改变了
         ~ar~, 则意味着改变了数组的存储位置(即地址). 可以进行类似 ~ar + 1~ 这样
         的操作, 标识数组的下一个元素. 但是 *不允许进行 ~++ar~ 这样的操作*.

       - 指针形式(~*pt1~): 也使得编译器为字符串在静态储存区预留相应元素的空间. 另
         外, 一旦开始执行程序, 它会为指针变量 ~pt1~ 流出一个存储位置, 并把字符串
         的地址储存在指针变量中. 该变量最初指向该字符串的首字符, 但是它的值可以
         改变. 因此, *可以使用* 递增运算符. 例如: ~++pt1~ 将指向第 2 个字符

         字符串字面量被视为 ~const~ 数组. 由于 ~pt1~ 指向这个数据, 所以应该把
         ~pt1~ 声明为指向 ~const~ 数组的指针. 这意味着不能用 ~pt1~ 改变它所指向
         的数据, 但是仍然可以改变 ~pt1~ 的值.

         *初始化数组把静态存储区的字符串拷贝到数组中, 而初始化指针只把字符串的地
         址拷贝给指针*

    4. 数组和指针的区别
       - 数组名是 *常量*: 数组名不可再次赋值

       - 指针名是 *变量*: 只有指针可以进行递增操作
         
         const 限定符的指针初始化:
         #+begin_src c
           char* word = "frame";

           word[1] = 'l';
         #+end_src
         编译器 *可能允许* 这样做, 但是对当前的 C 标准而言, 这样的行为是未定义的,
         这样的语句可能导致内存访问错误. 
         原因: 编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量

         *建议*: 在把指针初始化为字符串字面量时使用 const 限定符
         
         把非 const 数组初始化为字符串字面量缺不会导致类似的问题. 因为数组获得的
         是原始字符串的 *副本*

       - 字符串数组
         指针数组效率高但不可修改, 而多维数组中内容可以修改

*** 指针和字符串 
    拷贝地址比拷贝整个字符串(数组)高效

** 字符串输入
*** 分配空间
    假设编写了如下代码:
    #+begin_src c
      char* name;
      scanf("%s", name);
    #+end_src
    虽然可能通过编译(警告), 但是在读入 ~name~ 时, ~name~ 可能会擦写掉程序中的数
    据或代码, 从而导致程序异常终止. 因为 ~scanf()~ 要把信息拷贝至参数指定的地址
    上, 而此时该参数是个未初始化的指针, ~name~ 可能会指向任何地方.

*** 不幸的 ~gets()~ 函数
    ~gets()~ 函数简单易用, 读取整行输入, 直至遇到换行符, 然后丢弃换行符, 储存其
    余字符, 并在这些字符的末尾添加一个空字符使其成为一个 C 字符串. 经常和
    ~puts()~ 配对使用, 该函数用于显示字符串, 并在末尾添加换行符.

    *警告*: ~gets()~ 的唯一参数 *无法检查数组是否装得下输入行*, 数组名会被转换成
     该数组首元素的地址, 因此, ~gets()~ 只知道数组的开始处, 并不知道数组中有多少
     个元素

     如果输入的字符串过长, 会导致 *缓冲区溢出(buffer overflow)*. 即多余的字符超
     出了指定的目标空间. 如果这些多余的字符只是占用了尚未使用的内存, 就不会立即
     出现问题; 如果他们擦写掉程序中的其他数据, 会导致程序异常中止; 或者还有其他
     情况

     C11 标准 *废除* 了 ~gets()~ 函数

*** ~gets()~ 的替代品
    过去通常使用 ~fgets()~ 来替代 ~gets()~. C11 标准新增的 ~gets_s()~ 函数也可以
    代替 ~gets()~. 但是它是 ~stdio.h~ 输入/输出函数系列的 *可选* 扩展, 所以支持
    C11 的编译器也不一定支持它

    1. ~fgets()~ 函数(和 ~fputs()~)
       ~fgets()~ 函数通过第二个参数限制读入字符数来解决移除的问题. 该函数专门设
       计用于处理文件输入, 所以一般情况下可能不太好用. 与 ~gets()~ 的区别:
       - ~fgets()~ 函数的第 2 个参数指明了读入字符的最大数量. 如果该参数的值是 n,
         那么 ~fgets()~ 将读入 n-1 个字符, 或者读到遇到的第一个换行符位置
       - 如果 ~fgets()~ 读到一个换行符, 会把它存储在字符串中. 这点与 ~gets()~ 不
         同, ~gets()~ 会丢弃换行符
       - ~fgets()~ 函数的第 3 个参数指明要读入的文件. 如果读入从键盘输入的数据, 则
         以 stdin(标准输入作为参数), 该标识符定义在 ~stdio.h~ 中
       - 因为 ~fgets()~ 函数把换行符放在字符串的末尾(假设输入行不溢出), 通常要与
         ~fputs()~ 函数(和 ~puts()~ 类似) 配对使用, 除非该函数不再字符串末尾添加
         换行符. ~fputs()~ 函数的第 2 个参数指明它要写入的文件. 如果要显示在计算机
         显示器上, 应使用 stdout(标准输出) 作为该参数
       - ~fputs()~ 函数 *不会在字符串末尾添加一个换行符*, ~fputs()~ 函数返回指向
         char 的指针. 如果一切进行顺利, 该函数返回的地址与传入的第一个参数相同.
         如果函数读到文件结尾, 它将返回一个特殊的指针: 空指针 (null pointer). 该
         指针保证不会指向有效的数据, 代码中可以用数字 0 来代替, 不过在 C 语言中用
         宏 ~NULL~ 来代替更常见(如果读入错误, 也返回 ~NULL~)

         系统使用缓冲的 I/O, 这意味着用于按下 ~Return~ 键之前, 输入都被存储在临
         时存储区(即, 缓冲区) 中. 按下 ~Return~ 键就在输入中增加了一个换行符, 并
         把整行输入发送给 ~fgets()~. 对于输出, ~fputs()~ 把字符发送给另一个缓冲
         区, 当发送换行符时, 缓冲区的内容被发送至屏幕上
       - 空字符和空指针:
         + 空字符(或 ~'\0'~): 是用于标记 C 字符串末尾的字符, 其对应编码是 0, 由
           于其他字符的编码不可能是 0, 所以不可能是字符串的一部分
           空字符是 *整数类型*, 空字符是一个字符, 占 1 字节

         + 空指针(或 ~NULL~)有一个值, 该值不会与任何数据的有效地址对应. 通常, 函
           数使用它返回一个有效地址表示某些特殊情况发生, 例如遇到文件结尾或未能
           按预期执行
           空指针是 *指针类型*, 空指针是一个地址, 通过占 4 字节

    2. ~gets_s~ 函数
       C11 新增的 ~gets_s()~ 函数(可选)和 ~fgets()~ 类似, 用一个参数限制读入的空
       字符数. 
       与 ~fgets()~ 区别:
       1) ~gets()~ 只总从标准输入中读取数据, 所以不需要第三个参数

       2) 如果 ~gets_s()~ 读取到换行符, 会丢弃它而不是存储它

       3) 如果 ~gets_s()~ 读到最大字符数都没有读到换行符, 会执行以下几步:
          1. 把模板数组中的首字符设置为空字符

          2. 读取并丢弃随后输入直至读到换仿佛或文件结尾, 然后返回空指针

          3. 调用依赖实现的 "处理函数", 可能会中止会退出程序

             只要输入行未超过最大字符数, 效果与 ~gets()~ 几乎一致
             当输入与预期不符时, ~fgets()~ 比 ~gets_s()~ 更方便

    3. ~s_gets()~ 函数
       
       #+begin_src c
         char* s_gets(char* st, int n)
         {
           char* ret_val;
           int i = 0;

           ret_val = fgets(st, n, stdin);

           if (ret_val) // 即 判断是否为 NULL
           {

             while (st[i] != '\n' && st[i] != '\0') {
               ++i;
             }

             // 使用空字符替换换行符
             if (st[i] == '\n') {
               st[i] = '\0';      
             } else {
               while (getchar() != '\n') {
                 continue;
               }
             }
           }

           return ret_val;
         }
       #+end_src

       如果 ~fgets()~ 返回 ~NULL~ 说明读到文件结尾或出现读取错误, 跳过该过程, 如
       果出现换行符, 使用空字符替换. 若出现空字符, 丢弃该输入行的其余字符, 返回
       与 ~fgets()~ 相同的值

       输入行多出来的字符会被留在缓冲区中, 成为下一次读取语句的输入. 若类型不匹
       配可能导致程序崩溃
*** ~scanf()~ 函数
    ~scanf()~ 和 ~gets()~ 或 ~fgets()~ 的区别在于它们如何确定字符串的末尾

    ~scanf()~ 更像是 "获取单词" 函数, 而不是 "获取字符串" 函数; 如果预留的存储区
    装的下行, ~gets()~ 和 ~fgets()~ 会读取第一个换行符之前所有的字符.
    
    ~scanf()~ 函数有 2 种方法确定输入结束. 无论哪种方法, 都从第一个非空白字符作为
    字符串的开始. 如果使用 ~%s~ 转换说明, 以下一个空白字符(空行, 空格, 制表符或
    换行符)作为字符串的结束(字符串不包括空白字符). 如果指定了字段宽度, 如
    ~%10s~, 那么 ~scanf()~ 将读取 10 个字符或读到第一个空白字符停止(先满足的条件
    即是输入结束的条件):

    | 输入语句            | 原输入序列*  | name 中的内容 | 剩余输入序列 |
    |---------------------+--------------+--------------+--------------|
    | scanf("%s" name);   | Fleebert Hup | Fleebert     | Hup          |
    | scanf("%5s", name); | Fleebert Hup | Fleeb        | ert Hup      |
    | scanf("%5s", name); | Ann Ular     | Ann          | Ular         |

    
    当第一个参数长度过长时, 再次使用 ~scanf()~ 赋值时会从上一次调用结束的地方继
    续读取数据

    根据输入数据的性质, 用 ~fgets()~ 读取从键盘输入的数据更合适. 例如, ~scanf()~
    无法完整读取书名或歌曲名, 除非这些名称是一个单词. ~scanf()~ 的典型用法是读取
    并转换混合数据为某种标准形式. 例如, 如果输入行包含一种工具名, 库存量和单价,
    就可以使用 ~scanf()~. 否则可能要自己拼凑一个函数处理一些输入检查. 如果一次只
    输入一个单词, 用 ~scanf()~ 也没问题.

    ~scanf()~ 和 ~gets()~ 类似, 也存在溢出可能, 转换说明指名字段宽度可以防止溢出
** 字符串输出
   C 有 3 个标准库函数用于打印字符串: ~puts()~, ~fputs()~ 和 ~printf()~

*** ~puts()~ 函数
    该函数仅需把字符串的地址作为参数传递即可

    每个字符串单独占一行, 因为 ~puts()~ 在显示字符串时会自动在其末尾添加一个换行
    符.

    该函数遇到空字符时就停止输出, 所以 *必须确保有空字符*

    没有空字符结果会由编译器不同而输出内容不同, ~puts()~ 会在一个空字符下停止

    
