
* 第 11 章 字符串和字符串函数

** 表示字符串和字符串 I/O
*** 在程序中定义字符串
    字符串定义方式
    1. 字符串字面量(字符串常量)
       用双引号括起来的内容成本为字符串字面量(string literal), 也叫做字符串常量
       (string constant). 双引号中的字符串和编译器自动加入末尾的 ~\0~ 字符, 都作
       为字符串储存在内容中, 所以 ~"I am a symbolic string constant"~, ~"I am a
       string in an array."~, ~"Something is pointed at me."~, ~"Here are
       some strings:"~ 都是字符串字面量.

       从 ANSI C 标准起, 如果字符串字面量之间没有间隔, 或者空白字符分割, C 会将其
       视为串联起来的字符串字面量, 例如:
       #+begin_src c
         char greeting[50] = "Hello, and "" how are" "you"
             " today!";
         // 与下面代码等价:
         char greeting[50] = "Hello, and how are you today!";
       #+end_src
       如果要在字符串内部使用双引号, 必须转义

       字符串常量属于静态存储类别(static storage class), 这说明在函数中使用字符
       串常量, 该字符串只会被储存一次, 在整个程序的生命期内存在, 即使函数被调用
       多次. 用双引号括起来的内容被视为指向该字符串储存位置的指针. 这类似于把数
       组名作为指向该数组位置的指针.

    2. 字符串数组和初始化
       定义字符串数组时, 必须让编译器知道需要多少空间. 一种方法是用足够空间的数
       组储存字符串. 
       #+begin_src c
         const char m1[40] = "Limit yourself to one line's worth.";
       #+end_src
       ~const~ 表名不会更改这个字符串

       这种形式的初始化比标准的数组初始化形式简单的多:
       #+begin_src c
         const char m1[40] = { 'L', 'i', 'm', 'i', 't', '', 'y', 'o', 'u', 'r', 's', 'e', 'l', 'l'
                               , 'f', '', 't', 'o', '', 'o', 'n', 'e', '', 'l', 'i', 'n', 'e', '\',
                               , 's', ' ', 'w', 'o', 'r', 't', 'h', '.', '\0'};
       #+end_src

       *注意最后的空字符*, 没有这个空字符, 就是一个字符数组而不是一个字符串

       在指定数组大小时, 要确保数组的元素个数至少比字符串长度 *多 1* (为了容纳空
       字符). 所有未被使用的元素都被自动初始化为 0

       通常, 让编译器确定数组的大小很方便且合理. 因为处理字符串的函数通常不知道
       数组的大小, 这些函数通过查找字符串末尾的空字符来确定字符串在何处结束

       让编译器计算数组大小只能用在 *初始化* 时. 如果创建一个稍后再填充的数组,
       就必须在声明时指定大小.

       字符数组名和其他数组名一样, 是该数组首元素的地址. 因此, 假设有如下代码:
       #+begin_src c
         char car[10] = "Tata";
       #+end_src

       以下表达式为 '真':
       #+begin_src c
         car == &car[0];
         *car == 'T';
         *(car + 1) == car[1] == 'a';
       #+end_src

       还可以用 *指针表示法* 创建字符串:
       #+begin_src c
         const char* pt1 = "Something is pointing at me";
       #+end_src
       该声明与下面的声明几乎相同:
       #+begin_src c
         const char ar1[] = "Something is pointing at me";
       #+end_src
       以上 2 个声明表名, ~pt1~ 和 ~ar1~ 都是该字符串的地址. 尽管如此, 这两种形式
       *并不完全相同*

    3. 数组和指针
       - 数组形式(~ar[n]~): 在计算机的内存中分配一个内含 n 个元素的数组(每个元素对
         应一个字符, 还加上一个末尾的空字符 ~'\0'~), 每个元素被初始化为字符串字
         面量对应的字符. 冗长, 字符串都作为可执行文件的一部分储存在数据段中. 当
         把程序载入内存时, 也载入了程序中的字符串. 字符串储存在静态存储区(static
         memory)中. 但是, 程序在 *开始运行时才会为该数组分配内存*. 此时, 才将字
         符串拷贝到数组中.
         *注意*: 此时字符串有 2 个副本, 一个是静态内存中的字符串字面量, 一个是储存
         在 ~ar~ 数组中的字符串

         此后, 编译器便吧数组名 ~ar~ 识别为该数组首元素地址(~&ar[0]~)的别名. 这
         里关键要理解, 在数组形式中, ~ar~ 是地址常量, *不能更改* ~ar~, 如果改变了
         ~ar~, 则意味着改变了数组的存储位置(即地址). 可以进行类似 ~ar + 1~ 这样
         的操作, 标识数组的下一个元素. 但是 *不允许进行 ~++ar~ 这样的操作*.

       - 指针形式(~*pt1~): 也使得编译器为字符串在静态储存区预留相应元素的空间. 另
         外, 一旦开始执行程序, 它会为指针变量 ~pt1~ 流出一个存储位置, 并把字符串
         的地址储存在指针变量中. 该变量最初指向该字符串的首字符, 但是它的值可以
         改变. 因此, *可以使用* 递增运算符. 例如: ~++pt1~ 将指向第 2 个字符

         字符串字面量被视为 ~const~ 数组. 由于 ~pt1~ 指向这个数据, 所以应该把
         ~pt1~ 声明为指向 ~const~ 数组的指针. 这意味着不能用 ~pt1~ 改变它所指向
         的数据, 但是仍然可以改变 ~pt1~ 的值.

         *初始化数组把静态存储区的字符串拷贝到数组中, 而初始化指针只把字符串的地
         址拷贝给指针*

         
