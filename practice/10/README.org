
* 第 10 章 数组和指针

** 数组

*** 初始化数组
    只存储单个值的变量有时也被成为 *标量变量(scalar variable)*

    可使用 const 声明只读数组
    
    数组和其他变量相似, 可以把数组创建成不同的存储类别(storage class)

*** 指定初始化器(C99)
    指定初始化器(designated initializer)可以初始化指定的数组元素
    #+begin_src c
      int arr[6] = { 0, 0, 0, 0, 212 }; // 传统语法
      int arr[6] = { [5] = 212 }; // C99
    #+end_src

*** 给指定数组元素赋值
    C 不允许把数组作为一个单元赋给另一个数组, 除初始化意外也不允许使用画括号列表
    的形式赋值
    #+begin_src c
      #define SIZE 5

      int main()
      {
          int oxen[SIZE] = { 5, 3, 2, 8 }; // 初始化没问题
          int yaks[SIZE];
          yaks = oxen; // 不允许

          yks[SIZE] = OXEN[SIZE]; // 数组下标越界
          yksp[SIZE] = { 5, 3, 2, 8 } // 不起作用
    
          return 0;
      }
    #+end_src
    SIZE - 1 才是数组最终元素下标

*** 指定数组的大小
    #+begin_src c
      #define SIZE 4
      int main()
      {
          int arr[SIZE]; // 整数符号常量
          double lots[144]; // 整数字面常量
      }
    #+end_src
    #+begin_src c
      int n = 5;
      int m = 8;
      float a4[-4]; // 数组大小必须大于0
      float a5[0]; // 数组大小必须大于0
      float a5[2.5]; // 数组大小必须是整数
      float a7[(int)2.5]; // 可以, 已被强制转换为整型常量
      float a8[n]; // C99之前不允许
    #+end_src

    C99 支持变长数组(variable-lengtht array), 简称 VLA()C11 放弃了这一创新的举措,
    把 VLA 

** 多维数组
   
*** 初始化二维数组
    #+begin_src c
      int sq[2][3] = {{ 5, 6 }, { 7, 8 }};
      // 等价
      int sq[2][3] = { 5, 6, 7, 8 };
    #+end_src

*** 指针和数组
    数组名是数组首元素的地址
    #+begin_src c
      fizny == &flizny[0];
    #+end_src
    可以把它们赋值给指针变量, 然后可以修改指针变量的值

    指针的值是它所指向对象的地址. 地址的表示方式依赖于计算机内部的硬件. 许多计算
    机都是按字节编址, 意思是内存中的每个字节都按顺序编号. 一个较大对象的地址通常
    是该对象第一个字节的地址

    在指针前面使用*运算符可以得到该指针所指向对象的值
    指针加 1, 指针的值传递它所指向类型的大小
    #+begin_src c
      dates + 2 == &date[2]; // 相同的地址
      *(dates + 2) == dates[2]; // 相同的值
    #+end_src
    
    可以使用指针标识数组的元素和获得元素的值.
    从本质上看, 同一个对象有 2 种表示方法. 实际上, C 语言标准在描述数组表示法时确实
    借助了指针.
    也就是说, 定义 ~ar[n]~ 的意思是 ~*(ar + n)~. 可以认为 ~*(ar + n)~ 的意思是"
    到内存的 ar 位置, 然后移动 n 个单位, 检索储存在那里的值"

    *间接运算符(*)的优先级高于+*, ~*dates + 2~ 相当于 ~(*dates) + 2~

*** 函数, 数组和指针
    只有在函数原型或函数定义头中, 才可以使用 ~int ar[]~ 代替 ~int* ar~
    以下 4 种原型等价:
    #+begin_src c
      int sum(int* ar, int n);
      int sum(int*, int);
      int sum(int ar[], int n);
      int sum(int [], int);
    #+end_src

    但是在函数定义中不能省略参数名. 下面 2 种形式的函数定义等价
    #+begin_src c
      int sum(int* ar, int n)
      {
          // ...
      }

      int sum(int ar[], int n)
      {
          // ...
      }
    #+end_src

**** 使用指针形参
     可以传递 2 个指针, 第一个指明数组开始处, 第二个指明数组结束处(见 ~sum_arr2.c~)

**** 指针表示法和数组表示法

     - 使用数组表示法: 让函数是处理数组的这一意图更明显
     - 使用指针表示法: 更贴近机器语言(尤其与递增运算符一起使用时), 在一些编译器
       可以生成更高效的代码
    

** 指针操作(见 ~ptr_ops.c~) : 重点
   - 赋值: 可以把地址赋给指针.
     例: 用数组名, 带地址运算符(&)的变量名, 另一个指针进行赋值. 
     该例中: ~urn~ 数组的首地址赋给了 ~ptr1~
   - 解引用: ~*~ 运算符给出指针执行地址上存储的值
   - 取址: 指针变量也有自己的地址和值. 对指针而言, &运算符给出指针本身的地址
     该例中: ~&ptr1~ 是指向 ~ptr1~ 的指针, 而 ~ptr1~ 是指向 ~utn[0]~ 的指针
   - 指针与整数相加: 可以使用 ~+~ 运算符把指针与整数相加, 或整数与指针相加. 无论
     哪种情况, 指针都会和指针所指向类型的大小(以字节为单位)相乘, 然后把结果与初
     始地址相加. 因此 ~ptr + 1~ 与 ~&urn[4]~ 等价. 如果相加的结果超出了初始指针
     指向的数组范围, 计算结果则是未定义的. 除非正好超过数组末尾的第一个位置, C 保
     证该指针有效
   - 递增指针: 指针指向数组元素的指针可以让该指针移动至下一个元素.
     因此, ~ptr1++~ 相当于把 ~ptr1~ 的值加上 ~4~, ~ptr1~ 指向 ~urn[1]~
     *注意*: 变量不会因为值发生变化就移动位置, 所以 ~ptr~ 本身的地址仍然不变
   - 指针减去一个整数: 可以使用 ~-~ 运算符从指针减去一个整数. 指针 *必须* 是第一
     个运算对象, 整数是第二个运算对象. 该整数将 *乘以指针指向类型的大小* (以字节为单
     位), 然后用初始地址减去乘积. 所以 ~ptr3 - 2~ 与 ~&urn[2]~ 等价, 因为 ~ptr3~
     指向的是 ~&arn[4]~. 如果相减的结果超出了初始指针
     指向的数组范围, 计算结果则是未定义的. 除非正好超过数组末尾的第一个位置, C 保
     证该指针有效
   - 递减指针: 与递增指针反向
   - 指针求差: 可以计算 2 个指针的差值. 通常, 求差的 2 个指针分别指向同一个元素的
     不同元素, 通过计算求出 2 元素之间的 *距离*. 差值的单位与数据类型的单位相同;
     例: ~ptr2 - ptr1~ 得 ~2~, 意思是指向相同的数组(或其中一个指针指向数组后面的
     第一个地址), C 都能保证相减运算有效. 如果指向 2 个不同数组的指针进行求差运算可
     能会得出一个值, 或者导致运行时错误.
   - 比较: 使用关系运算符可以比较 2 个指针的值, *前提是 2 个指针都指向相同类型的
     对象*

   - *注意*: 这里的减法有 2 种. 可以用一个指针减去另一个指针得到一个整数, 或者用一
     个指针减去一个整数得到另一个指针.

   - *注意 2*: 在递增或递减指针时还要注意一些问题. 编译器不会检查指针是否仍指向数
     组元素. C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效.
     但是, 如果递减或递增一个指针后超出了这个范围, 则是未定义的. 另外, 可以解引
     用指向数组任意元素的指针. 但是, 即使指针指向数组后面一个位置是有效的, 也能
     解引用这样的越界指针

   - *注意 3*: 牢记: 千万不要解引用未初始化的指针, 因为指针默认地址是随机值

     #+begin_src c
       double* pd; // 未初始化的指针
       ,*pd = 2.4; // 不要这样做

       int urn[3];
       int *ptr1, *ptr2;

       // 有效语句
       ptr1++;
       ptr2 = ptr1 + 2;
       ptr2 = urn + 1;

       // 无效语句
       urn++;
       ptr2 = ptr2 + ptr1;
       ptr2 = urn * ptr1;
     #+end_src

** 保护数组中的数据
   编写一个处理基本类型的函数式, 可选传递值或指针. 通常都是直接传递数值, 只有程
   序需要在函数中改变该数值时, 才会传递指针. 对于数组别无选择, 必须传递指针, 因
   为这样做效率高. 如果一个函数按值传递数组, 则必须分配足够的空间来储存原数组的
   副本, 然后把原数组所有的数组拷贝进新的数组中, 如果把数组的地址传递给函数, 让
   函数直接处理原数组则效率要高

   传递地址会导致一些问题, 处理数组的函数通常都需要使用原始数据, 因此这样的函数
   可以修改原数组. 但有些函数不需要修改原数组, 但由于传递的实际上是指针, 所以编
   程错误可能会破坏原始数据

*** 对形式参数使用 const
    避免类似错误的方式是在函数原型和函数定义中声明形式参数时使用关键字 ~const~ 
    
*** const 的其他内容
    1. 把 ~const~ 数据或非 ~const~ 数组的地址初始化为指向 const 的指针或为其赋值
       是合法的: (表示不能更改指针值)
       #+begin_src c
         double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.5 };
         const double locked[4] = { 0.08, 0.075, 0.0725, 0.07 };
         const double* pc = rates; // 有效
         pc = locked; // 有效
         pc = &rates[3]; // 有效
       #+end_src
       
    2. 只能把非 const 的地址赋给普通指针
       #+begin_src c
         double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.55 };
         const double locked[4] = { 0.08, 0.075, 0.0725, 0.07 };
         double* pnc = rates; // 有效
         pnc = locked; // 无效
         pnc = &rates[3]; // 有效
       #+end_src
       此规则避免改变 ~const~ 数组中的数据

       应用以上规则的例子, ~show_array()~ 函数(见 ~arf.c~)可以接受普通数组名和
       ~const~ 数组名作为参数, 因为这 2 种参数都可以用来初始化指向 ~const~ 的指
       针(规则 1)

       因此, 对函数的形参使用 ~const~ 不仅能保护数据, 还能让函数处理 ~const~ 数
       组

       C 标准规定, 使用非 ~const~ 标识符修改 ~const~ 数据导致的结果是未定义的

    3. ~const~ 可以声明并初始化一个不能指向别处的指针:
       #+begin_src c
         double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.5 };
         double* const pc = rates; // pc指向数组的开始
         pc = &rates[2]; // 不允许, 因为该指针不能指向别处
         *pc = 92.99; // 允许, 更改rates[0]的值
       #+end_src

    4. 创建指针时可以使用 ~const~ 两次, 该指针即不能更改它所指向的地址, 也不能更
       改指针值
        #+begin_src c
          double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.5 };
          const double* const pc = rates;
          pc = &rates[2]; // 不允许
          ,*pc = 92.99; // 不允许
        #+end_src

** 指针和多维数组
   假设有:
   #+begin_src c
     int zippo[4][2]; // 内含int数组的数组
   #+end_src
   有以下结果:
   1. ~zippo~ 的值和 ~&zippo[0]~ 的值相同
   2. 给指针或地址加 1, 其值会增加对应类型大小的数值. 在这方面, ~zippo~ 和
      ~zippo[0]~ 不同, 因为 ~zippo~ 指向的对象占用了 2 个 ~int~ 大小, 而
      ~zippo[0]~ 指向的对象只占用 1 个 ~int~ 大小, 因此, ~zippo + 1~ 和
      ~zippo[0] + 1~ 的值不同
   3. 解引用一个指针或在数组名后使用带下标的 ~[]~ 运算符, 得到引用对象代表的值.
      因为 ~zippo[0]~ 是该数组首元素(~zippo[0]~)的地址, 所以 ~*(zippo[0])~ 表示
      存储在 ~zippo[0][0]~ 上的值. 与此类似, ~*zippo~ 代表该数组首元素
      (~zippo[0]~) 的值, 但是 ~zippo[0]~ 本身是一个 ~int~ 类型的地址. 该值的地址
      是 ~&zippo[0][0]~ , 所以 ~*zippo~ 就是 ~&zippo[0][0]~. 对 2 个表达式应用解引
      用运算符表名, ~**zippo~ 与 ~*&zippo[0][0]~ 等价, 这相当于 ~zippo[0][0]~.
      地址的地址或指针的指针就是双重间接(double indirection)的例子.

*** 指向多维数组的指针
    在编写处理类似 ~zippo~ 这样的二维数组时, 把指针声明为指向 ~int~ 的类型还不够.
    因为指向 ~int~ 只能与 ~zippo[0]~ 的类型匹配, 说明该指针指向一个 ~int~ 类型的
    值. 但是 ~zippo~ 是它首元素的地址, 该元素是一个内含 2 个 ~int~ 类型值的一维数
    组. 因此, ~pz~ 必须指向一个内含 2 个 ~int~ 类型值的数组, 而不是执行一个 ~int~
    类型值, 声明如下:
    #+begin_src c
      int (* pz)[2]; // pz 指向一个内含2个int类型值的数组
    #+end_src
    为什么要使用圆括号? 因为 ~[]~ 的优先级高于 ~*~. 考虑下面的声明:
    #+begin_src c
      int* pax[2]; // pax是一个内含2个指针元素的数组, 每个元素都指向int的指针
    #+end_src
    
    下列写法效果相等:
    #+begin_src c
      zippo[m][n] == *(*(zippo + m) + n);
      pz[m][n] == *(*(pz + m) + n);
    #+end_src

*** 指针的兼容性
    指针之间的赋值比数值类型的赋值要严格, 无法把 ~int~ 类型的指针值赋给 ~double~
    类型的指针
    
    复杂指针指向:
    #+begin_src c
      int *pt;
      int (*pa)[3];
      int ar1[2][3];
      int ar2[3][2];
      int **p2; // 一个指向指针的指针

      // 如下语句
      pt = &ar1[0][0]; // 指向int的指针
      pt = ar1[0]; // 指向int的指针
      pt = ar1; // 无效, pt指向一个int值, ar1指向一个内含3个int类型元素的数组

      pa = ar1; // 指向内含3个int类型元素数组的指针
      pa = ar2; // 无效, pa指向一个内含3个int元素的数组(书中有误, 应为3个)

      p2 = &pt; // 都是指向int的指针
      ,*p2 = ar2[0]; // *p2是指向int的指针, ar2[0]是指向ar2[0][0]的指针, 也是指向int的指针
      p2 = ar2; // 无效
    #+end_src
    
    安全指针赋值:
    #+begin_src c
      int x = 20;
      const int y = 23;
      int *p1 = &x;
      const int *p2 = &y;
      const int **pp2;

      p1 = p2; // 不安全 -- 把 const指针赋给非const指针
      p2 = p1; // 有效 -- 把非 const指针赋给const指针
      pp2 = &p1; // 不安全 - 嵌套指针类型赋值
    #+end_src
    
    #+begin_src c
      const int **pp2;
      int *p1;
      const int n = 13;

      pp2 = &p1; // 允许, 但是这导致 const 限定符失效(根据第一行代码, 不能通过 *pp2修改它所指向的内容)

      ,*pp2 = &n; // 有效, 2者都声明为 const, 但是这将导致p1指向n(*pp2已被修改)

      ,*p1 = 10; // 有效, 但是这将改变n的值(根据第三行代码, 不能修改n的值)
    #+end_src
    以上代码在 ~gcc~ 和 ~clang~ 等不同编译器下结果不同

    C 的 const 与 C++的 const:
    1. C++允许在声明数组大小时使用 ~const~ 整数, 而 C 却不允许. 
    2. C++的指针赋值检查更严格:
       #+begin_src c
         const int y;
         const int *p2 = &y;
         int *p1;
         p1 = p2; // C++中不允许此操作, C仅警告
       #+end_src
       C++不允许把 ~const~ 指针赋给非 ~const~ 指针, C 中允许, 如果通过 ~p1~ 更改 ~y~, 其
       行为是未定义的

*** 函数和多维数组
    
    编写处理二维数组的函数
    ~for~ 循环
    声明函数形参:
    #+begin_src c
      void somefunction(int (*pt)[4]);
    #+end_src
    当且仅当 pt 是一个函数的形式参数时, 可以这样声明:
    #+begin_src c
      // 注意: 第一个空括号表明pt是一个指针
      void somefunction(int pt[][4]);
    #+end_src

    (见 ~array2d.c~ )注意: ~ar~ 和 ~main()~ 中的 junk 都使用数组表示法. 因为 ar 和
    junk 的类型相同, 他们都是指向内含 4 个 ~int~ 类型值的数组的指针

    下面的声明不正确:
    #+begin_src c
      int sum2(int ar[][], int rows); // 错误的声明
    #+end_src
    编译器会把数组表示法转换成指针表示法.
    例如: ~ar[1]~ 转换成 ~ar + 1~. 编译器对 ~ar + 1~ 求值, 要知道 ~ar~ 所指向的
    大小
    
    也可以在第一对方括号中写上大小, 但是编译器会忽略该值:
    #+begin_src c
      int sum2(int ar[3][4], int rows); // 有效声明, 但是3将被忽略
    #+end_src
    
    与使用 ~typedef~ 相比, 这种形式方便的多
    #+begin_src c
      typedef int arr4[4]; // arr4是一个内含4个int的数组
      typedef arr4 arr3x4[3]; // arr3x4 是一个内含3个arr4的数组

      int sum2(arr3x4 ar, int rows); // 与下面的声明相同
      int sum2(int ar[3][4], int rows); // 与下面的声明相同
      int sum2(int ar[][4], int rows); // 标准形式
    #+end_src
    
** 变长数组(VLA)
   要创建一个能处理任意大小二维数组的函数, 比较繁琐(必须把数组作为一维数组传递,
   然后让函数计算每行的开始处). 而且, 这种方法不好处理 ~FORTRAN~ 的子例程, 这些
   子例程都允许在函数调用中指定 2 个维度. 

   C99 新增了变长数组(variable-length arry, VLA), 允许使用变量表示数组的维度:
   #+begin_src c
     int quarters = 4;
     int regions = 5;
   #+end_src
   变长数组的限制:
   1. 必须是自动存储类别, 这意味着无论在函数中声明还是作为函数形参声明, 都 *不能
      使用* ~static~ 或 ~extern~ 存储类别说明符, 而且 *不能在声明中初始化*.
      该特性在 C11 作为可选特性
   2. 变长数组不能改变大小, 变长数组是指创建数组时可以使用变量指定数组的维度
      #+begin_src c
        int sum2d(int rows, int cols, int ar[rows][cols]); // 有效, VLA
        int sum2d(int ar[rows][cols], int rows, int cols); // 错误
      #+end_src
      可以省略原型中的形参名, 但是必须使用型号代替省略的维度:
      #+begin_src c
        int sum2d(int, int, int ar[*][*]); // VLA, 省略了维度形参名
      #+end_src

      
   C99/C11 标准允许在声明变长数组时使用 ~const~ 变量. 所以该数组的定义必须是声明
   在块中的自动存储类别的数组

   变量数组还允许动态内存分配, 这说明可以在程序运行时指定数组的大小
      
** 复合字面量
   C99 标准以前, 对于带数组形参的函数, 情况不同, 可以传递数组, 但是没有等价的数
   组常量. C99 新增了复合字面量(computed literal). 字面量是除符号常量外的常量.例
   如, ~5~ 是 ~int~ 类型字面量, ~81.3~ 是 ~double~ 类型的字面量, ~'Y'~ 是 ~char~
   类型的字面量, ~"elephat"~ 是字符串字面量. 发布 C99 标准的委员会认为, 如果有代表
   数组和结构内容的复合字面量, 在编程时会更方便
   
   对于数组, 复合字面量类似数组初始化列表, 前面是用括号括起来的类型名,
   例, 下面是一个普通的数组声明:
   #+begin_src c
     int diva[2] = { 10, 20 };
   #+end_src
   下面的复合字面量创建了一个和 diva 数组相同的匿名数组, 也有 2 个 ~int~ 类型的
   值:
   #+begin_src c
     (int [2]){10, 20}; // 复合字面量
   #+end_src
   *注意*: 去掉声明中的数组名, 留下的 ~int[2]~ 即是复合字面量的类型名
   
   初始化有数组名的数组时可以省略数组大小, 复合字面量也可以省略大小, 编译器会自
   动计算数组当前的元素个数:
   #+begin_src c
     (int []){50, 20, 90}; // 内涵3个元素的复合字面量
   #+end_src

   因为复合字面量是匿名的, 所以不能先创建然后再使用它, 必须在创建的同时使用它.
   使用指针记录地址就是一种用法:
   #+begin_src c
     int *pt1;
     pt1 = (int[2]){10, 20};
   #+end_src

   *注意*: 该复合字面量的字面常量与上面创建的 ~diva~ 数组的字面常量完全相同. 与有
   数组名的数组类型, 复合字面量的类型名也代表首元素的地址, 所以可以把它赋给指向
   ~int~ 的指针. 然后便可使用这个指针

   还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数:
   #+begin_src c
     int sum(const int ar[], int n);

     int total3;
     total3 = sum((int []){4, 4, 4, 5, 5, 5}, 6);
   #+end_src
   这种用法的好处是: 把信息传入函数前不必先创建数组, 这是复合字面量的典型用法

   可以把这种用法应用于二维数组或多维数组:
   #+begin_src c
     int (*pt2)[4];

     pt = (int [2][4]){ { 1, 2, 3, -9}, { 4, 5, 6, -8} };
   #+end_src
   
   *复合字面量是提供只临时需要值的一种手段*. 复合字面量具有 *块级作用域*, 这意味
    着一旦离开定义复合字面量的块, 程序将无法保证该字面量是否存在. 复合字面量的定
    义在最内层的花括号中

** 关键概念
   1. 数据用于存储相同类型的数据. C 把数组看作是派生类型, 因为数组是建立在其他类型的基础上. 也就是说, 无法简单地声明一个数组. 在声明数组时必须说明其元素的类型,所谓的其他类型也可以是数组类型, 这种情况下, 创建的是数组的数组(多维数组)

   2. 通常编写一个函数来处理数组, 这样在特定的函数中解决特定的问题, 有助于实现程
      序的模块化. 在把数组名作为实际参数时, 传递给函数的不是这个数组, 而是数组的
      地址(因此, 函数对应的形式参数是是指针). 为了处理数组, 函数 *必须* 知道从何
      处开始读取数据和要处理多少个数组元素. 数组地址提供了 "地址", "元素个数" 可
      以内置在函数中或作为单独的参数传递.

   3. 数组和指针的关系密切, 同一个操作可以用 *数组表示法* 和 *指针表示法*

   4. 对于传统的 C 数组, 必须用常量表达式指明数组的大小, 所以数组大小在编译时就
      已确定, C99/C11 新增了变长数组, 可以用变量表示数组大小. 这意味着变长数组的
      大小延迟到程序运行时才确定

** 本章小结
   1. 数组是一组数据类型相同的元素. 数组元素按顺序储存在内存中, 通过整数下标(或
      索引)可以访问各元素. 在 C 中, 数组首元素的下标是 0

   2. C 把数组名解释为该数组首元素的地址. 换言之, 数组名与指向该数组首元素的指针
      *等价*

   3. 对于 C 语言而言, 不能把整个数组作为参数传递给函数, 但是可以传递数组的地址.
      然后函数可以使用传入的地址操作原始数组. 如果函数没有修改原始数组的意图, 应
      在声明函数的形式参数时使用关键字 ~const~. 在被掉函数中可以使用数组表示法或
      指针表示法

   4. 指针加上一个整数或者递增指针, 指针的值 *以所指向对象的大小为单位改变*.

   5. C 语言传递多维数组的传统方法是数组名(即数组的地址)传递给类型匹配的指针形参.
      声明这样的指针形参要指定所有的数组维度, 除了第一个维度

      
   *注意*: 字符串有一些特殊规则, 这是由于其末尾的空字符串所致. 有了这个空字符,
    不用传递数组的大小, 函数通过检测字符串的末尾也知道在何处停止
