
* 第 10 章 数组和指针

** 数组

*** 初始化数组
    只存储单个值的变量有时也被成为 *标量变量(scalar variable)*

    可使用 const 声明只读数组
    
    数组和其他变量相似, 可以把数组创建成不同的存储类别(storage class)

*** 指定初始化器(C99)
    指定初始化器(designated initializer)可以初始化指定的数组元素
    #+begin_src c
      int arr[6] = { 0, 0, 0, 0, 212 }; // 传统语法
      int arr[6] = { [5] = 212 }; // C99
    #+end_src

*** 给指定数组元素赋值
    C 不允许把数组作为一个单元赋给另一个数组, 除初始化意外也不允许使用画括号列表
    的形式赋值
    #+begin_src c
      #define SIZE 5

      int main()
      {
          int oxen[SIZE] = { 5, 3, 2, 8 }; // 初始化没问题
          int yaks[SIZE];
          yaks = oxen; // 不允许

          yks[SIZE] = OXEN[SIZE]; // 数组下标越界
          yksp[SIZE] = { 5, 3, 2, 8 } // 不起作用
    
          return 0;
      }
    #+end_src
    SIZE - 1 才是数组最终元素下标

*** 指定数组的大小
    #+begin_src c
      #define SIZE 4
      int main()
      {
          int arr[SIZE]; // 整数符号常量
          double lots[144]; // 整数字面常量
      }
    #+end_src
    #+begin_src c
      int n = 5;
      int m = 8;
      float a4[-4]; // 数组大小必须大于0
      float a5[0]; // 数组大小必须大于0
      float a5[2.5]; // 数组大小必须是整数
      float a7[(int)2.5]; // 可以, 已被强制转换为整型常量
      float a8[n]; // C99之前不允许
    #+end_src

    C99 支持变长数组(variable-lengtht array), 简称 VLA()C11 放弃了这一创新的举措,
    把 VLA 

** 多维数组
   
*** 初始化二维数组
    #+begin_src c
      int sq[2][3] = {{ 5, 6 }, { 7, 8 }};
      // 等价
      int sq[2][3] = { 5, 6, 7, 8 };
    #+end_src

*** 指针和数组
    数组名是数组首元素的地址
    #+begin_src c
      fizny == &flizny[0];
    #+end_src
    可以把它们赋值给指针变量, 然后可以修改指针变量的值

    指针的值是它所指向对象的地址. 地址的表示方式依赖于计算机内部的硬件. 许多计算
    机都是按字节编址, 意思是内存中的每个字节都按顺序编号. 一个较大对象的地址通常
    是该对象第一个字节的地址

    在指针前面使用*运算符可以得到该指针所指向对象的值
    指针加 1, 指针的值传递它所指向类型的大小
    #+begin_src c
      dates + 2 == &date[2]; // 相同的地址
      *(dates + 2) == dates[2]; // 相同的值
    #+end_src
    
    可以使用指针标识数组的元素和获得元素的值.
    从本质上看, 同一个对象有 2 种表示方法. 实际上, C 语言标准在描述数组表示法时确实
    借助了指针.
    也就是说, 定义 ~ar[n]~ 的意思是 ~*(ar + n)~. 可以认为 ~*(ar + n)~ 的意思是"
    到内存的 ar 位置, 然后移动 n 个单位, 检索储存在那里的值"

    *间接运算符(*)的优先级高于+*, ~*dates + 2~ 相当于 ~(*dates) + 2~

*** 函数, 数组和指针
    只有在函数原型或函数定义头中, 才可以使用 ~int ar[]~ 代替 ~int* ar~
    以下 4 种原型等价:
    #+begin_src c
      int sum(int* ar, int n);
      int sum(int*, int);
      int sum(int ar[], int n);
      int sum(int [], int);
    #+end_src

    但是在函数定义中不能省略参数名. 下面 2 种形式的函数定义等价
    #+begin_src c
      int sum(int* ar, int n)
      {
          // ...
      }

      int sum(int ar[], int n)
      {
          // ...
      }
    #+end_src

**** 使用指针形参
     可以传递 2 个指针, 第一个指明数组开始处, 第二个指明数组结束处(见 ~sum_arr2.c~)

**** 指针表示法和数组表示法

     - 使用数组表示法: 让函数是处理数组的这一意图更明显
     - 使用指针表示法: 更贴近机器语言(尤其与递增运算符一起使用时), 在一些编译器
       可以生成更高效的代码
    

** 指针操作(见 ~ptr_ops.c~) : 重点
   - 赋值: 可以把地址赋给指针.
     例: 用数组名, 带地址运算符(&)的变量名, 另一个指针进行赋值. 
     该例中: ~urn~ 数组的首地址赋给了 ~ptr1~
   - 解引用: ~*~ 运算符给出指针执行地址上存储的值
   - 取址: 指针变量也有自己的地址和值. 对指针而言, &运算符给出指针本身的地址
     该例中: ~&ptr1~ 是指向 ~ptr1~ 的指针, 而 ~ptr1~ 是指向 ~utn[0]~ 的指针
   - 指针与整数相加: 可以使用 ~+~ 运算符把指针与整数相加, 或整数与指针相加. 无论
     哪种情况, 指针都会和指针所指向类型的大小(以字节为单位)相乘, 然后把结果与初
     始地址相加. 因此 ~ptr + 1~ 与 ~&urn[4]~ 等价. 如果相加的结果超出了初始指针
     指向的数组范围, 计算结果则是未定义的. 除非正好超过数组末尾的第一个位置, C 保
     证该指针有效
   - 递增指针: 指针指向数组元素的指针可以让该指针移动至下一个元素.
     因此, ~ptr1++~ 相当于把 ~ptr1~ 的值加上 ~4~, ~ptr1~ 指向 ~urn[1]~
     *注意*: 变量不会因为值发生变化就移动位置, 所以 ~ptr~ 本身的地址仍然不变
   - 指针减去一个整数: 可以使用 ~-~ 运算符从指针减去一个整数. 指针 *必须* 是第一
     个运算对象, 整数是第二个运算对象. 该整数将 *乘以指针指向类型的大小* (以字节为单
     位), 然后用初始地址减去乘积. 所以 ~ptr3 - 2~ 与 ~&urn[2]~ 等价, 因为 ~ptr3~
     指向的是 ~&arn[4]~. 如果相减的结果超出了初始指针
     指向的数组范围, 计算结果则是未定义的. 除非正好超过数组末尾的第一个位置, C 保
     证该指针有效
   - 递减指针: 与递增指针反向
   - 指针求差: 可以计算 2 个指针的差值. 通常, 求差的 2 个指针分别指向同一个元素的
     不同元素, 通过计算求出 2 元素之间的 *距离*. 差值的单位与数据类型的单位相同;
     例: ~ptr2 - ptr1~ 得 ~2~, 意思是指向相同的数组(或其中一个指针指向数组后面的
     第一个地址), C 都能保证相减运算有效. 如果指向 2 个不同数组的指针进行求差运算可
     能会得出一个值, 或者导致运行时错误.
   - 比较: 使用关系运算符可以比较 2 个指针的值, *前提是 2 个指针都指向相同类型的
     对象*

   - *注意*: 这里的减法有 2 种. 可以用一个指针减去另一个指针得到一个整数, 或者用一
     个指针减去一个整数得到另一个指针.

   - *注意 2*: 在递增或递减指针时还要注意一些问题. 编译器不会检查指针是否仍指向数
     组元素. C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效.
     但是, 如果递减或递增一个指针后超出了这个范围, 则是未定义的. 另外, 可以解引
     用指向数组任意元素的指针. 但是, 即使指针指向数组后面一个位置是有效的, 也能
     解引用这样的越界指针

   - *注意 3*: 牢记: 千万不要解引用为初始化的指针, 因为指针默认地址是随机值

     #+begin_src c
       double* pd; // 未初始化的指针
       ,*pd = 2.4; // 不要这样做

       int urn[3];
       int *ptr1, *ptr2;

       // 有效语句
       ptr1++;
       ptr2 = ptr1 + 2;
       ptr2 = urn + 1;

       // 无效语句
       urn++;
       ptr2 = ptr2 + ptr1;
       ptr2 = urn * ptr1;
     #+end_src

** 保护数组中的数据
   编写一个处理基本类型的函数式, 可选传递值或指针. 通常都是直接传递数值, 只有程
   序需要在函数中改变该数值时, 才会传递指针. 对于数组别无选择, 必须传递指针, 因
   为这样做效率高. 如果一个函数按值传递数组, 则必须分配足够的空间来储存原数组的
   副本, 然后把原数组所有的数组拷贝进新的数组中, 如果把数组的地址传递给函数, 让
   函数直接处理原数组则效率要高

   传递地址会导致一些问题, 处理数组的函数通常都需要使用原始数据, 因此这样的函数
   可以修改原数组. 但有些函数不需要修改原数组, 但由于传递的实际上是指针, 所以编
   程错误可能会破坏原始数据

*** 对形式参数使用 const
    避免类似错误的方式是在函数原型和函数定义中声明形式参数时使用关键字 ~const~ 
    
*** const 的其他内容
    1. 把 ~const~ 数据或非 ~const~ 数组的地址初始化为指向 const 的指针或为其赋值
       是合法的: (表示不能更改指针值)
       #+begin_src c
         double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.5 };
         const double locked[4] = { 0.08, 0.075, 0.0725, 0.07 };
         const double* pc = rates; // 有效
         pc = locked; // 有效
         pc = &rates[3]; // 有效
       #+end_src
       
    2. 只能把非 const 的地址赋给普通指针
       #+begin_src c
         double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.55 };
         const double locked[4] = { 0.08, 0.075, 0.0725, 0.07 };
         double* pnc = rates; // 有效
         pnc = locked; // 无效
         pnc = &rates[3]; // 有效
       #+end_src
       此规则避免改变 ~const~ 数组中的数据

       应用以上规则的例子, ~show_array()~ 函数(见 ~arf.c~)可以接受普通数组名和
       ~const~ 数组名作为参数, 因为这 2 种参数都可以用来初始化指向 ~const~ 的指
       针(规则 1)

       因此, 对函数的形参使用 ~const~ 不仅能保护数据, 还能让函数处理 ~const~ 数
       组

       C 标准规定, 使用非 ~const~ 标识符修改 ~const~ 数据导致的结果是未定义的

    3. ~const~ 可以声明并初始化一个不能指向别处的指针:
       #+begin_src c
         double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.5 };
         double* const pc = rates; // pc指向数组的开始
         pc = &rates[2]; // 不允许, 因为该指针不能指向别处
         *pc = 92.99; // 允许, 更改rates[0]的值
       #+end_src

    4. 创建指针时可以使用 ~const~ 两次, 该指针即不能更改它所指向的地址, 也不能更
       改指针值
        #+begin_src c
          double rates[5] = { 88.99, 100.12, 59.45, 183.11, 340.5 };
          const double* const pc = rates;
          pc = &rates[2]; // 不允许
          ,*pc = 92.99; // 不允许
        #+end_src

** 指针和多维数组
   假设有:
   #+begin_src c
     int zippo[4][2]; // 内含int数组的数组
   #+end_src
   有以下结果:
   1. ~zippo~ 的值和 ~&zippo[0]~ 的值相同
   2. 给指针或地址加 1, 其值会增加对应类型大小的数值. 在这方面, ~zippo~ 和
      ~zippo[0]~ 不同, 因为 ~zippo~ 指向的对象占用了 2 个 ~int~ 大小, 而
      ~zippo[0]~ 指向的对象只占用 1 个 ~int~ 大小, 因此, ~zippo + 1~ 和
      ~zippo[0] + 1~ 的值不同
   3. 解引用一个指针或在数组名后使用带下标的 ~[]~ 运算符, 得到引用对象代表的值.
      因为 ~zippo[0]~ 是该数组首元素(~zippo[0]~)的地址, 所以 ~*(zippo[0])~ 表示
      存储在 ~zippo[0][0]~ 上的值. 与此类似, ~*zippo~ 代表该数组首元素
      (~zippo[0]~) 的值, 但是 ~zippo[0]~ 本身是一个 ~int~ 类型的地址. 该值的地址
      是 ~&zippo[0][0]~ , 所以 ~*zippo~ 就是 ~&zippo[0][0]~. 对 2 个表达式应用解引
      用运算符表名, ~**zippo~ 与 ~*&zippo[0][0]~ 等价, 这相当于 ~zippo[0][0]~.
      地址的地址或指针的指针就是双重间接(double indirection)的例子.

*** 指向多维数组的指针
    在编写处理类似 ~zippo~ 这样的二维数组时, 把指针声明为指向 ~int~ 的类型还不够.
    因为指向 ~int~ 只能与 ~zippo[0]~ 的类型匹配, 说明该指针指向一个 ~int~ 类型的
    值. 但是 ~zippo~ 是它首元素的地址, 该元素是一个内含 2 个 ~int~ 类型值的一维数
    组. 因此, ~pz~ 必须指向一个内含 2 个 ~int~ 类型值的数组, 而不是执行一个 ~int~
    类型值, 声明如下:
    #+begin_src c
      int (* pz)[2]; // pz 指向一个内含2个int类型值的数组
    #+end_src
    为什么要使用圆括号? 因为 ~[]~ 的优先级高于 ~*~. 考虑下面的声明:
    #+begin_src c
      int* pax[2]; // pax是一个内含2个指针元素的数组, 每个元素都指向int的指针
    #+end_src
    
    下列写法效果相等:
    #+begin_src c
      zippo[m][n] == *(*(zippo + m) + n);
      pz[m][n] == *(*(pz + m) + n);
    #+end_src

*** 指针的兼容性
    指针之间的赋值比数值类型的赋值要严格, 无法把 ~int~ 类型的指针值赋给 ~double~
    类型的指针
    
    复杂指针指向:
    #+begin_src c
      int *pt;
      int (*pa)[3];
      int ar1[2][3];
      int ar2[3][2];
      int **p2; // 一个指向指针的指针

      // 如下语句
      pt = &ar1[0][0]; // 指向int的指针
      pt = ar1[0]; // 指向int的指针
      pt = ar1; // 无效, pt指向一个int值, ar1指向一个内含3个int类型元素的数组

      pa = ar1; // 指向内含3个int类型元素数组的指针
      pa = ar2; // 无效, pa指向一个内含3个int元素的数组(书中有误, 应为3个)

      p2 = &pt; // 都是指向int的指针
      ,*p2 = ar2[0]; // *p2是指向int的指针, ar2[0]是指向ar2[0][0]的指针, 也是指向int的指针
      p2 = ar2; // 无效
    #+end_src
    
    安全指针赋值:
    #+begin_src c
      int x = 20;
      const int y = 23;
      int *p1 = &x;
      const int *p2 = &y;
      const int **pp2;

      p1 = p2; // 不安全 -- 把 const指针赋给非const指针
      p2 = p1; // 有效 -- 把非 const指针赋给const指针
      pp2 = &p1; // 不安全 - 嵌套指针类型赋值
    #+end_src
    
    #+begin_src c
      const int **pp2;
      int *p1;
      const int n = 13;

      pp2 = &p1; // 允许, 但是这导致 const 限定符失效(根据第一行代码, 不能通过 *pp2修改它所指向的内容)

      ,*pp2 = &n; // 有效, 2者都声明为 const, 但是这将导致p1指向n(*pp2已被修改)

      ,*p1 = 10; // 有效, 但是这将改变n的值(根据第三行代码, 不能修改n的值)
    #+end_src
    以上代码在 ~gcc~ 和 ~clang~ 等不同编译器下结果不同

    C 的 const 与 C++的 const:
    1. C++允许在声明数组大小时使用 ~const~ 整数, 而 C 却不允许. 
    2. C++的指针赋值检查更严格:
       #+begin_src c
         const int y;
         const int *p2 = &y;
         int *p1;
         p1 = p2; // C++中不允许此操作, C仅警告
       #+end_src
       C++不允许把 ~const~ 指针赋给非 ~const~ 指针, C 中允许, 如果通过 ~p1~ 更改 ~y~, 其
       行为是未定义的
