
* 第 10 章 数组和指针

** 数组

*** 初始化数组
    只存储单个值的变量有时也被成为 *标量变量(scalar variable)*

    可使用 const 声明只读数组
    
    数组和其他变量相似, 可以把数组创建成不同的存储类别(storage class)

*** 指定初始化器(C99)
    指定初始化器(designated initializer)可以初始化指定的数组元素
    #+begin_src c
      int arr[6] = { 0, 0, 0, 0, 212 }; // 传统语法
      int arr[6] = { [5] = 212 }; // C99
    #+end_src

*** 给指定数组元素赋值
    C 不允许把数组作为一个单元赋给另一个数组, 除初始化意外也不允许使用画括号列表
    的形式赋值
    #+begin_src c
      #define SIZE 5

      int main()
      {
          int oxen[SIZE] = { 5, 3, 2, 8 }; // 初始化没问题
          int yaks[SIZE];
          yaks = oxen; // 不允许

          yks[SIZE] = OXEN[SIZE]; // 数组下标越界
          yksp[SIZE] = { 5, 3, 2, 8 } // 不起作用
    
          return 0;
      }
    #+end_src
    SIZE - 1 才是数组最终元素下标

*** 指定数组的大小
    #+begin_src c
      #define SIZE 4
      int main()
      {
          int arr[SIZE]; // 整数符号常量
          double lots[144]; // 整数字面常量
      }
    #+end_src
    #+begin_src c
      int n = 5;
      int m = 8;
      float a4[-4]; // 数组大小必须大于0
      float a5[0]; // 数组大小必须大于0
      float a5[2.5]; // 数组大小必须是整数
      float a7[(int)2.5]; // 可以, 已被强制转换为整型常量
      float a8[n]; // C99之前不允许
    #+end_src

    C99 支持变长数组(variable-lengtht array), 简称 VLA()C11 放弃了这一创新的举措,
    把 VLA 

** 多维数组
   
*** 初始化二维数组
    #+begin_src c
      int sq[2][3] = {{ 5, 6 }, { 7, 8 }};
      // 等价
      int sq[2][3] = { 5, 6, 7, 8 };
    #+end_src

*** 指针和数组
    数组名是数组首元素的地址
    #+begin_src c
      fizny == &flizny[0];
    #+end_src
    可以把它们赋值给指针变量, 然后可以修改指针变量的值

    指针的值是它所指向对象的地址. 地址的表示方式依赖于计算机内部的硬件. 许多计算
    机都是按字节编址, 意思是内存中的每个字节都按顺序编号. 一个较大对象的地址通常
    是该对象第一个字节的地址

    在指针前面使用*运算符可以得到该指针所指向对象的值
    指针加 1, 指针的值传递它所指向类型的大小
    #+begin_src c
      dates + 2 == &date[2]; // 相同的地址
      *(dates + 2) == dates[2]; // 相同的值
    #+end_src
    
    可以使用指针标识数组的元素和获得元素的值.
    从本质上看, 同一个对象有 2 种表示方法. 实际上, C 语言标准在描述数组表示法时确实
    借助了指针.
    也就是说, 定义 ~ar[n]~ 的意思是 ~*(ar + n)~. 可以认为 ~*(ar + n)~ 的意思是"
    到内存的 ar 位置, 然后移动 n 个单位, 检索储存在那里的值"

    *间接运算符(*)的优先级高于+*, ~*dates + 2~ 相当于 ~(*dates) + 2~
