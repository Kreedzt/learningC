
* 第 10 章 数组和指针

** 数组

*** 初始化数组
    只存储单个值的变量有时也被成为 *标量变量(scalar variable)*

    可使用 const 声明只读数组
    
    数组和其他变量相似, 可以把数组创建成不同的存储类别(storage class)

*** 指定初始化器(C99)
    指定初始化器(designated initializer)可以初始化指定的数组元素
    #+begin_src c
      int arr[6] = { 0, 0, 0, 0, 212 }; // 传统语法
      int arr[6] = { [5] = 212 }; // C99
    #+end_src

*** 给指定数组元素赋值
    C 不允许把数组作为一个单元赋给另一个数组, 除初始化意外也不允许使用画括号列表
    的形式赋值
    #+begin_src c
      #define SIZE 5

      int main()
      {
          int oxen[SIZE] = { 5, 3, 2, 8 }; // 初始化没问题
          int yaks[SIZE];
          yaks = oxen; // 不允许

          yks[SIZE] = OXEN[SIZE]; // 数组下标越界
          yksp[SIZE] = { 5, 3, 2, 8 } // 不起作用
    
          return 0;
      }
    #+end_src
    SIZE - 1 才是数组最终元素下标

*** 指定数组的大小
    #+begin_src c
      #define SIZE 4
      int main()
      {
          int arr[SIZE]; // 整数符号常量
          double lots[144]; // 整数字面常量
      }
    #+end_src
    #+begin_src c
      int n = 5;
      int m = 8;
      float a4[-4]; // 数组大小必须大于0
      float a5[0]; // 数组大小必须大于0
      float a5[2.5]; // 数组大小必须是整数
      float a7[(int)2.5]; // 可以, 已被强制转换为整型常量
      float a8[n]; // C99之前不允许
    #+end_src

    C99 支持变长数组(variable-lengtht array), 简称 VLA()C11 放弃了这一创新的举措,
    把 VLA 

** 多维数组
   
*** 初始化二维数组
    #+begin_src c
      int sq[2][3] = {{ 5, 6 }, { 7, 8 }};
      // 等价
      int sq[2][3] = { 5, 6, 7, 8 };
    #+end_src

*** 指针和数组
    数组名是数组首元素的地址
    #+begin_src c
      fizny == &flizny[0];
    #+end_src
    可以把它们赋值给指针变量, 然后可以修改指针变量的值

    指针的值是它所指向对象的地址. 地址的表示方式依赖于计算机内部的硬件. 许多计算
    机都是按字节编址, 意思是内存中的每个字节都按顺序编号. 一个较大对象的地址通常
    是该对象第一个字节的地址

    在指针前面使用*运算符可以得到该指针所指向对象的值
    指针加 1, 指针的值传递它所指向类型的大小
    #+begin_src c
      dates + 2 == &date[2]; // 相同的地址
      *(dates + 2) == dates[2]; // 相同的值
    #+end_src
    
    可以使用指针标识数组的元素和获得元素的值.
    从本质上看, 同一个对象有 2 种表示方法. 实际上, C 语言标准在描述数组表示法时确实
    借助了指针.
    也就是说, 定义 ~ar[n]~ 的意思是 ~*(ar + n)~. 可以认为 ~*(ar + n)~ 的意思是"
    到内存的 ar 位置, 然后移动 n 个单位, 检索储存在那里的值"

    *间接运算符(*)的优先级高于+*, ~*dates + 2~ 相当于 ~(*dates) + 2~

*** 函数, 数组和指针
    只有在函数原型或函数定义头中, 才可以使用 ~int ar[]~ 代替 ~int* ar~
    以下 4 种原型等价:
    #+begin_src c
      int sum(int* ar, int n);
      int sum(int*, int);
      int sum(int ar[], int n);
      int sum(int [], int);
    #+end_src

    但是在函数定义中不能省略参数名. 下面 2 种形式的函数定义等价
    #+begin_src c
      int sum(int* ar, int n)
      {
          // ...
      }

      int sum(int ar[], int n)
      {
          // ...
      }
    #+end_src

**** 使用指针形参
     可以传递 2 个指针, 第一个指明数组开始处, 第二个指明数组结束处(见 ~sum_arr2.c~)

**** 指针表示法和数组表示法

     - 使用数组表示法: 让函数是处理数组的这一意图更明显
     - 使用指针表示法: 更贴近机器语言(尤其与递增运算符一起使用时), 在一些编译器
       可以生成更高效的代码
    

** 指针操作(见 ~ptr_ops.c~) : 重点
   - 赋值: 可以把地址赋给指针.
     例: 用数组名, 带地址运算符(&)的变量名, 另一个指针进行赋值. 
     该例中: ~urn~ 数组的首地址赋给了 ~ptr1~
   - 解引用: ~*~ 运算符给出指针执行地址上存储的值
   - 取址: 指针变量也有自己的地址和值. 对指针而言, &运算符给出指针本身的地址
     该例中: ~&ptr1~ 是指向 ~ptr1~ 的指针, 而 ~ptr1~ 是指向 ~utn[0]~ 的指针
   - 指针与整数相加: 可以使用 ~+~ 运算符把指针与整数相加, 或整数与指针相加. 无论
     哪种情况, 指针都会和指针所指向类型的大小(以字节为单位)相乘, 然后把结果与初
     始地址相加. 因此 ~ptr + 1~ 与 ~&urn[4]~ 等价. 如果相加的结果超出了初始指针
     指向的数组范围, 计算结果则是未定义的. 除非正好超过数组末尾的第一个位置, C 保
     证该指针有效
   - 递增指针: 指针指向数组元素的指针可以让该指针移动至下一个元素.
     因此, ~ptr1++~ 相当于把 ~ptr1~ 的值加上 ~4~, ~ptr1~ 指向 ~urn[1]~
     *注意*: 变量不会因为值发生变化就移动位置, 所以 ~ptr~ 本身的地址仍然不变
   - 指针减去一个整数: 可以使用 ~-~ 运算符从指针减去一个整数. 指针 *必须* 是第一
     个运算对象, 整数是第二个运算对象. 该整数将 *乘以指针指向类型的大小* (以字节为单
     位), 然后用初始地址减去乘积. 所以 ~ptr3 - 2~ 与 ~&urn[2]~ 等价, 因为 ~ptr3~
     指向的是 ~&arn[4]~. 如果相减的结果超出了初始指针
     指向的数组范围, 计算结果则是未定义的. 除非正好超过数组末尾的第一个位置, C 保
     证该指针有效
   - 递减指针: 与递增指针反向
   - 指针求差: 可以计算 2 个指针的差值. 通常, 求差的 2 个指针分别指向同一个元素的
     不同元素, 通过计算求出 2 元素之间的 *距离*. 差值的单位与数据类型的单位相同;
     例: ~ptr2 - ptr1~ 得 ~2~, 意思是指向相同的数组(或其中一个指针指向数组后面的
     第一个地址), C 都能保证相减运算有效. 如果指向 2 个不同数组的指针进行求差运算可
     能会得出一个值, 或者导致运行时错误.
   - 比较: 使用关系运算符可以比较 2 个指针的值, *前提是 2 个指针都指向相同类型的
     对象*

   - *注意*: 这里的减法有 2 种. 可以用一个指针减去另一个指针得到一个整数, 或者用一
     个指针减去一个整数得到另一个指针.

   - *注意 2*: 在递增或递减指针时还要注意一些问题. 编译器不会检查指针是否仍指向数
     组元素. C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效.
     但是, 如果递减或递增一个指针后超出了这个范围, 则是未定义的. 另外, 可以解引
     用指向数组任意元素的指针. 但是, 即使指针指向数组后面一个位置是有效的, 也能
     解引用这样的越界指针

   - *注意 3*: 牢记: 千万不要解引用为初始化的指针, 因为指针默认地址是随机值

     #+begin_src c
       double* pd; // 未初始化的指针
       ,*pd = 2.4; // 不要这样做

       int urn[3];
       int *ptr1, *ptr2;

       // 有效语句
       ptr1++;
       ptr2 = ptr1 + 2;
       ptr2 = urn + 1;

       // 无效语句
       urn++;
       ptr2 = ptr2 + ptr1;
       ptr2 = urn * ptr1;
     #+end_src
