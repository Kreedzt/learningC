* C 预处理器和 C 库
  本章介绍以下内容:
  
  - 预处理器指令: 
    + ~#define~
    + ~#include~
    + ~#ifdef~
    + ~#else~
    + ~#endif~
    + ~#ifndef~
    + ~#if~
    + ~#elif~
    + ~#line~
    + ~#error~
    + ~#pragma~
  - 关键字:
    + ~_Generic~
    + ~_Noreturn~
    + ~_Static_assert~
  - 函数/宏
    + ~sqrt()~
    + ~atan()~
    + ~atan2()~
    + ~exit()~
    + ~atexit()~
    + ~assert()~
    + ~memcpy()~
    + ~memmove()~
    + ~va_start()~
    + ~va_arg()~
    + ~va_copy()~
    + ~va_end()~
  - C 预处理器的其他功能
  - 通用选择表达式
  - 内联函数
  - C 库概述和一些特殊用途的方便函数
  
  C 语言建立在适当的关键字, 表达式, 语句以及使用它们的规则上. 然而, C 标准不仅描
  述 C 语言, 还描述如何执行 C 预处理器, C 标准库有哪些函数, 以及详述这些函数的工
  作原理

  C 预处理在 *程序执行之前* 查看程序(故称之为预处理器). 根据程序中的预处理器指令,
  预处理器把符号缩写替换成其表示的内容. 预处理器可以包含程序所需的其他文件, 可以
  选择让编译器查看哪些代码. 预处理器 *并不知道 C*. 基本上它的工作是把一些文本转
  换成另外一些文本.

** 翻译程序的第一步
   在预处理器之前, 编译器必须对该程序进行一些翻译处理. 首先, 编译器把源代码中出
   现的 *字符映射到源字符集*. 该过程处理多字节字符和三字符序列 -- 字符扩展让 C 更加
   国际化

   第二, 编译器 *定位每个反斜杠后面跟着换行符的实例*, 并删除它们.
   eg: 下面的 *物理行(physical line)*:
   #+begin_src c
     printf("That's wond\
     erful!\n");
   #+end_src

   转换成一个 *逻辑行(logical line)*:
   #+begin_src c
     printf("That's wonderful!\n");
   #+end_src

   *注意*: 在这种场合中, "换行符" 的意思是通过按下 ~Enter~ 键在源代码文件中换行
   所生成的字符, 而不是指符号表征 ~\n~
    
   由于预处理器表达式的长度必须是一个逻辑行, 所以这一步为预处理器做好了准备工作.
   一个逻辑行可以是多个物理行

   第三, 编译器把文本划分成预处理器记号序列, 空白序列和注释序列(记号是由空格, 制
   表符活换行符分隔的项). 这里要注意的是, 编译器将由一个空格字符替换每一条注释.

   eg: 下面代码:
   #+begin_src c
     int/* 这看起来并不像一个空格 */fox;
   #+end_src

   处理后:
   #+begin_src c
     int fox;
   #+end_src
   
   而且, 实现可以用 *一个空格替换所有的空白字符序列* (不包括换行符). 最后, 程序
   已经 *准备好进入预处理阶段*, 预处理器查找一行中以 ~#~ 号开始的预处理命令
** 明示常量: ~#define~
   ~#define~ 预处理器指令和其他预处理器指令一样, 以 ~#~ 号 作为一行的开始. ANSI
   和后来的标准都允许 ~#~ 号前面有空格或制表符, 而且还允许在 ~#~ 和 指令的其余部
   分之间有空格. 旧版本的 C 要求质量从一行最左边开始, 而且 ~#~ 和指令其余部分之
   间不能有空格. 

   指令可以出现在源文件的任何地方, 其定义从指令出现的地方到该文件末尾有效. 我们
   大量使用 ~#define~ 指令来 *定义明示常量(manifest constant)(也叫做符号常量)*,
   但是该指令还有许多其他用途. 见 ~prepro.c~ 用法.

   预处理器指令从 ~#~ 开始运行, 到后面的 *第一个换行符为止*. 也就是说, 指令的长
   度仅限于一行. 然而, 前面提到过, 在预处理开始前, 编译器会把多行物理行处理为一
   行逻辑行

   每行(逻辑行) ~#define~ 都由 3 部分组成.
   1. ~#define~ 指令本身
   2. 选定的缩写, 也称为宏. 有些宏代表值(如本例), 这些宏被称为 *类对象宏*
      (object-like macro). C 语言还有 *类函数宏* (function-like macro).
      宏的名称中 *不允许有空格*, 而且不洗遵循 C 变量的命名规则
   3. 指令行的其余部分: 替换列表或替换体.
      一旦预处理器在程序中找到宏的实例后, 就会用替换体代替该宏(也有例外). 从宏变
      成最终替换文本的过程称为 *宏展开* (macro expansion).

      *注意*: 可以在 ~#define~ 行使用标准 C 注释

      
   由于编译器会在编译期对说哟逇常量表达式(只包含常量的表达式) 求值, 所以预处理器
   *不会进行实际的乘法运算*, 这一过程在 *编译时* 进行. 预处理器不做计算, 不对表
   达式求值, 它只进行替换

   *注意*: 宏定义还可以包含其他宏(一些编译器不支持嵌套):

   #+begin_src c
     printf(FMT, x);
   #+end_src

   变成了:
   #+begin_src c
     printf("X is %d.\n", x);
   #+end_src

   相应的字符串替换了 ~FMT~

   可以在 *一行的结尾加一个反斜杠字符使该行扩展至下一行*
   *注意*: 下一行要与第一行左对齐

   使用字符常量的时机: 对于绝大部分 *数字常量, 应该使用字符常量*. 如果在算式中用
   字符常量代替数字, 常量明能更清楚地表达该数字的含义. 如果是数组大小的数字, 用
   符号常量后更容易改变数组的大小和循环次数. 如果是数字是系统代码(eg: *EOF*), 用
   符号常量表示的代码 *更容易移植*.

   符号常量有价值的特性: *助记*, *易更改*, *可移植*

   C 语言也支持 ~const~ 关键字, 可以创建在程序运行过程中不能改变的变量. 创建的变
   量可具有文件作用域或块作用域, *宏常量可用于指定标准数组的大小和 ~const~ 变量
   的初始值*

   #+begin_src c
     #define LIMIT 20
     const int LIM = 50;

     static int data1[LIMIT]; // 有效
     static int data2[LIM]; // 无效
     const int LIM2 = 2 * LIMIT; // 有效
     const int LIM3 = 2 * LIM; // 无效
   #+end_src

   在 C 中, 非自动数组的大小应该是 *整型常量表达式*, 这意味着表示数组大小的必须
   是 *整形常量的组合*, *不包括 ~const~ 声明的值. 但是, Clang 4.6 允许此声明, 为
   了可移植性, 谨慎使用.
*** 记号
*** 记号
    从技术角度来看, 可以把 *宏的替换体看作是记号(token)型字符串*, 而不是字符型字
    符串. C 预处理器记号是宏定义的替换体中单独的 "词". 用空白把这些词分开.

    eg:
    #+begin_src c
      #define FOUR 2 * 2
    #+end_src

    该宏定义有一个记号: 2 * 2 序列. 但是, 下面的宏定义中:
    #+begin_src c
      #define SIX 2 * 3
    #+end_src
    
    有 3 个记号: ~2~, ~*~, ~3~.

    替换体中有多个空格时, 字符型字符串和记号型字符串的处理方式不同.

    eg:
    #+begin_src c
      #define EIGHT 4 * 8
    #+end_src
    
    如果预处理器把该替换体解释为字符型字符串, 将用 4 * 8 替换 ~EIGHT~.
    即: 额外的空格是替换体的一部分.

    如果预处理器把该替换体解释为记号型字符串, 则用 3 个的记号 4 * 8(分别由单个空
    格分隔) 来替换 ~EIGHT~.

    换而言之, 解释为字符型字符串, *把空格视为替换体的一部分*; 解释为记号型字符串,
    *把空格视为替换体中各记号的分隔符*. 在实际应用中, 一些 C 编译器把宏替换体视
    为字符串而不是记号. 在比这个例子更复杂的情况下, 两者的区别才有实际意义
    
    顺带一提, C 编译器处理记号的方式比预处理器复杂. 由于编译器理解 C 语言的规则,
    *所以不要求代码中用空格来分割记号*. eg: C 编译器可以把 ~2 * 2~ 直接视为 3 个记
    号, 因为它可以识别 2 是常量, * 是运算符

*** 重定义常量
    不同的实现才用不同的重定义方案, 除非新定义与就定义相同, 否则有些实现会将其视
    为错误. 另外一些实现允许重定义, 但会给出警告. ANSI 标准采用第一种方案, 只有
    新定义和就定义完全相同才允许重定义

    具有相同的定义意味着替换体中的 *记号必须相同, 且顺序也相同*.

    eg: 两个定义相同
    #+begin_src c
      #define SIX 2 * 3
      #define SIX 2 * 3
    #+end_src

    这两条定义都有 3 个相同的记号, 额外的空格不算替换体的一部分. 而下面的定义则
    与上面 2 条宏定义不同:
    
    eg: *不同*
    #+begin_src c
      #define SIX 2*3
    #+end_src

    这条宏定义中只有一个记号, 因此与前 2 条定义不同. 如果需要重定义宏, 使用
    ~#undef~ 指令

    如果确实需要重定义常量, 使用 ~const~ 关键字和作用域规则更容易些

** 在 ~#define~ 中使用参数
   在 ~#define~ 中使用参数可以创建外形和作用与函数类似的 *类函数宏*. 带有参数的
   宏看上去很像函数, 因为这样的宏也是用圆括号. 内函数宏定义的圆括号中可以有一个
   或多个参数, 随后这些参数出现在替换体中

   #+begin_src c
     #define MEAN(X, Y) (((X) + (Y)) / 2)
     //      宏 (包含: 宏参数)  替换体
   #+end_src

   eg:
   #+begin_src c
     #define SQUARE(X) X * X
   #+end_src

   用法:
   #+begin_src c
     z = SQUARE(2);
   #+end_src

   看上去像函数调用, 但是它的行为和函数调用完全不同. 

   见 ~mac_arg.c~ 用法

   代码中, ~SQUARE~ 是宏标识符, ~SQUARE(X)~ 中的 ~X~ 是宏参数, ~X * X~ 是替换列
   表, 代码中出现 ~SQUARE(X)~ 的地方都会被 ~X * X~ 替换.

   ~SQUARE(x + 2)~ 被替换为 ~x+2*x+2~, 没有括号, 所以结果为 17

   函数调用在程序运行时把参数的值传递给函数. 宏调用在 *编译之前把参数记号传递给
   程序*. 这两个不同的过程发生在不同时期.
   
   eg: 规避上述问题
   #+begin_src c
     #define SQUARE(x) (x)*(x)
   #+end_src

   并未解决如下问题:
   #+begin_src c
     100/SQUARE(2);
   #+end_src

   替换结果:
   #+begin_src c
     100/2*2
   #+end_src

   适用上述问题的解决方案之一:
   #+begin_src c
     #define SQUARE(x) (x*x)
   #+end_src

   合并解决方案:
   #+begin_src c
     #define SQUARE(x) ((x)*(x))
   #+end_src

   尽管如此, 还是无法避免如下问题:
   #+begin_src c
     SQUARE(++x);
     // 替换结果: ++x*++x=6*7 = 42
   #+end_src

   标准 *并未对这类运算规定顺序*, 所以不同编译器结果不同, 但 ~x~ 的最终值是 7

   尽量避免在宏参数中使用 *递增递减运算符*.

*** 用宏参数创建字符串: ~#~ 运算符
    一个类函数宏:
    #+begin_src c
      #define PSQR(X) printf("The square of X is %d.\n", ((X)*(X));
    #+end_src

    使用:
    #+begin_src c
      PSQR(8);
    #+end_src

    结果:
    #+begin_src text
      The squre of X is 64.
    #+end_src

    双引号的字符串中的 ~X~ 被视为 *普通文本*, 而不是一个可被替换的记号

    C 允许在字符串中包含宏参数. 在类函数宏的替换体中, ~#~ 号作为一个预处理运算符,
    可以把记号转换成字符串.

    eg: x 是一个宏形参, 那么 ~#x~ 就是转换为字符串 "x" 的形参名, 这个过程称为 
    *字符串化 (stringizing)*.

    见 ~subst.c~ 用法

    调用第一个宏时, 用 ~"y"~ 替换 ~#x~. 调用第二个宏时, 用 ~"2 + 4"~ 替换 ~#x~.

    ANSI C 字符串的串联特性将这些字符串与 ~printf()~ 语句的其他字符串组合, 生成
    最终的字符串

    第一次调用:
    #+begin_src c
      printf("The square of " "y" " is %d.\n", ((y)*(y)));
    #+end_src

    然后, 字符串串联功能将 3 个相邻的字符串组合:
    #+begin_src c
      "The squre of y is %d.\n"
    #+end_src
    
*** 预处理器黏合剂: ~##~ 运算符
    与 ~#~ 运算符类似, ~##~ 运算符可用于类函数宏的替换部分. 而且, ~##~ 还可用于
    对象宏的替换部分. ~##~ 运算符把 2 个记号组合成一个记号.

    eg:
    #+begin_src c
      #define XNAME(n) x##n
    #+end_src

    然后, 宏 ~XNAME(4)~ 将展开为 ~x4~.

    见 ~glue.c~ 用法

    *注意*: ~PRINT_XN()~ 宏用 ~#~ 运算符组合字符串, ~##~ 运算符把记号组合为一个
     新的标识符
*** 变参宏: ~...~ 和 ~__VA_ARGS__~
    一些函数(如: ~printf()~) 接受 *数量可变的参数*. ~stdvar.h~ 头文件提供了工具,
    让用户 *自定义带可变参数的函数*. C99/C11 也对宏提供了这样的工具. 虽然标准中
    未使用 "可变"(variadic) 这个词, 但是它已成为描述这种工具的通用词(虽然 C 标准
    的索引添加了字符串化(stringizing) 词条, 但是并未把固定参数的函数或宏称为固定
    函数和不变宏)

    通过把宏参数列表中最后的参数写成省略号(即: 3 个点 ~...~) 来实现这一功能. 这
    样, 预定义宏 ~__VA_ARGS__~ 可用在替换部分中, 表明省略号代表什么.

    eg: 下面的定义:
    #+begin_src c
      #define PR(...) printf(__VA_ARGS__)
    #+end_src

    假设稍后调用该宏:
    #+begin_src c
      PR("Howdy");
      PR("weight=%d, shipping=$%.2f\n", wt, sp);
    #+end_src

    对于第一次调用, ~__VA_ARGS__~ 展开为一个参数: "Howdy".

    对于第二次调用, ~__VA_ARGS__~ 展开为三个参数: "weight = %d,
    shipping=$%.2f\n", wt, sp

    因此, 展开后的代码是:
    #+begin_src c
      printf("Howdy");
      printf("weight = %d, shipping = $%.2f\n", wt, sp);
    #+end_src
    
    示例: ~variadic.c~ 使用了字符串的串联功能和 ~#~ 运算符

    第一个宏调用, X 的值是 1, 所以 ~#X~ 变成 "1", 展开后为:
    #+begin_src c
      printf("Message""1"":""x=%g\n", x);
    #+end_src

    然后串联 4 个字符
    #+begin_src c
      printf("Message 1: x=%g\n", x);
    #+end_src

    *注意*: 省略号只能代替最后的宏参数:
    错误用法:
    #+begin_src c
      #define WRONG(X, ..., Y) #X#__VA_ARGS__#y
    #+end_src
** 宏和函数的选择
   使用宏比使用普通函数复杂, *稍有不慎会产生奇怪的副作用*.
   *一些编译器规定宏指令定义成一行*

   *宏和函数的选择实际上是时间和空间的权衡*. 宏生成内嵌代码, 即在程序中生成语句.
    如果调用 20 次宏, 即在程序中插入 20 行代码. 如果调用函数 20 次, 程序中只有一
    份函数语句的副本, 所以节省了空间. 然而另一方面, 程序的控制必须 *跳转* 至函数
    内, 随后再返回主调程序, 这显然比内联代码花费更多的时间

    宏的一个优点是, 不用担心变量类型(这是因为 *宏处理的是字符串*, 而不是实际的值).
    因此, 只要能用 ~int~ 或 ~float~ 类型都可以使用 ~SQUARE(x)~ 宏

    C99 提供了内联函数. 后面介绍

    简单的函数, 通常使用宏: 
    #+begin_src c
      #define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
      #define ABS(X) ((X) < 0 ? -(X) : (X))
      #define ISSIGN(X) ((X) == '+' || (X) == '0' ? 1 : 0)
    #+end_src

    *使用时注意*:
    1. 宏名中 *不允许有空格*, 但是在替换字符串中可以有空格. ANSI C 允许在参数列
       表中使用空格
    2. 用圆括号把宏的参数和整个替换体括起来. 这样能确保被括起来的部分在表达式中
       正确展开
       #+begin_src c
         forks = 2 * MAX(guests + 3, last);
       #+end_src
    3. 用大写字母表示宏函数的名称. 可以提醒程序员注意产生的副作用
    4. 如果打算用来加快程序的运行速度, 那么首先要确定使用宏和使用函数是否会导致
       较大差异. 在程序中 *只使用一次的宏无法明显减少程序的运行时间*. 在嵌套循环
       中还是用宏更有助于提高效率. 许多系统提供程序分析器以帮助程序员压缩程序中
       最耗时的部分
       
    假设开发了一些方便的宏函数, 使用 ~#include~ 指令可以复用该宏
** 文件包含: ~#include~
   当预处理器发现 ~#include~ 指令时, 会查看后面的文件名并把文件的内容包含到当前
   文件中, 即替换源文件中的 ~#include~ 指令. 这相当于把被包含文件的全部内容输入
   到源文件 ~#include~ 指令所在的位置. ~#include~ 指令有 2 种形式
   
   #+begin_src c
     #include <stdio.h> // 文件名在尖括号中
     #include "mystuff.h" // 文件名在双引号中
   #+end_src

   在 UNIX 系统中, 尖括号告诉预处理器 *在标准系统目录中* 查找该文件. 双引号告诉
   预处理器 *首先在当前目录中* (或文件名中指定的其他目录) 查找该文件, 如果未找到
   再查找标准系统目录

   #+begin_src c
     #include <stdio.h> // 查找系统目录
     #include "hot.h" // 查找当前工作目录
     #include "/usr/biff/p.h" // 查找 /usr/biff目录
   #+end_src

   集成开发环境(IDE) 也有标准路径或系统头文件的路径. 许多集成开发环境提供菜单选
   项, 指定用尖括号时查找路径. 在 UNIX 中, 使用双引号意味着先查找本地目录, 但是
   具体查找哪个目录取决于编译器的设定. 有些编译器会搜索源代码文件所在的目录, 有
   些编译器则 搜索当前的工作目录, 还有些搜索项目文件所在的目录.

   ANSI C *不为文件系统提供统一的目录模型*, 因为不同的计算机所用的系统不同. 一般
   而言, 明明文件的方法因系统而异, 但是尖括号和双引号的规则与系统无关.

   包含文件的目的: 编译器需要这些文件中的信息. 
   eg: ~stdio.h~ 文件中通常包含 ~EOF~, ~NULL~, ~getchar()~ 和 ~putchar()~ 的定
   义. ~getchar()~ 和 ~putchar()~ 被定义为宏函数. 此外, 该文件中还包含 C 的其他
   I/O 函数

   C 语言习惯用 *.h 后缀表示头文件*, 这些文件包含需要放在程序 *顶部* 的信息. 头
   文件经常包含一些预处理器指令. 有些头文件(eg: ~stdio.h~) 由系统提供, 也可以自
   己创建.
   
   包含一个大型头文件不一定显著增加程序的大小. 在大部分情况下, 头文件的内容是编
   译器生成最终代码时所需的信息, 而不是添加到最终代码中的材料

*** 头文件示例
    假设开发了一个存放人名的结构, 还编写了一些使用该结构的函数. 可以把不同的什么
    放在头文件中, ~names_st.h~ 头文件演示了该例子

    该头文件包含了一些头文件中常见的内容: ~#define~ 指令, 结构声明, ~typedef~ 和
    函数原型.

    *注意*: 这些内容是编译器在 *创建可执行时所需的信息, 而不是可执行代码*. 为安
     全起见, 通常, 应该用 ~#ifndef~ 和 ~#define~ 防止多重包含头文件.

     可执行代码通常在源文件代码中, 而不是在头文件中. 例如, ~names_st.c~ 中有头文
     件中函数原型的定义. 该程序包含了 ~names_st.h~ 头文件, 所以编译器知道
     ~names~ 类型

     ~get_names()~ 函数通过 ~s_gets()~ 函数调用了 ~fgets()~ 函数, 避免了目标数组
     溢出. ~useheader.c~ 使用了头文件与源文件

     *注意*: 两个源代码文件都是用 ~names_st~ 类型结构, 所以都必须包含
      ~names_st.h~ 头文件

      必须编译和链接 ~names_st.c~ 和 ~useheader.c~ 源代码文件

      声明和指令放在 ~names_st.h~ 头文件中, 函数定义放在 ~names_st.c~ 源代码文件
      中
*** 使用头文件
    浏览任何一个标准头文件都可以了解头文件的基本信息. 
    头文件中最常用的形式如下:

    - 明示常量: eg: ~stdio.h~ 中定义的 ~EOF~, ~NULL~ 和 ~BUFSIZE(标准 I/O 缓冲区
      大小)~
    - 宏函数: eg: ~getc(stdin)~ 通常用 ~getchar()~ 定义, 而 ~getc()~ 经常用于定
      义较复杂的宏, 头文件 ~ctype.h~ 通常包含 ~ctype~ 系列函数的宏定义.
    - 函数声明: eg: ~string.h~ 头文件(一些旧系统中是 ~strings.h~) 包含字符串函数
      系列的函数声明. 在 ANSI C 和后面的标准中, 函数声明都是函数原型形式.
    - 结构模板定义: 标准 I/O 函数使用 ~FILE~ 结构, 该结构中包含了文件和文件缓冲
      区相关的信息. ~FILE~ 结构在头文件 ~stdio.h~ 中
    - 类型定义: 标准 I/O 函数使用指向 ~FILE~ 的指针作为参数. 通常, ~stdio.h~ 用
      ~#define~ 或 ~typedef~ 把 ~FILE~ 定义为指向结构的指针. 类似地, ~size_t~ 和
      ~time_t~ 类型也定义在在头文件中

      
    如果开发一系列相关的函数或结构, 使用自己开发的标准头文件特别有价值.

    还可以使用头文件声明外部变量供其他文件共享. eg: 已经开发了共享某个变量的一系
    列函数, 该变量报告某种状况(eg: 错误情况), 这种方法就很有效. 该情况下, 可以在
    包含函数声明的源代码文件定义一个文件作用域的外部链接变量:

    #+begin_src c
      int status = 0; // 该变量具有文件作用域, 在源代码文件
    #+end_src

    然后, 可以在与源代码文件相关联的头文件中进行引用式声明:
    #+begin_src c
      extern int status; // 在头文件中
    #+end_src

    这行代码会出现在包含了该头文件的文件中, 这样使用该系列函数的文件都能使用这个
    变量. 
    虽然源代码文件中包含该头文件后也包含了该声明. 但是 *只要声明的类型一致*, 在
    一个文件中同时使用定义式声明和引用式声明没问题.

    需要包含头文件的另一种情况是: 使用具有文件作用域, 内部链接和 ~const~ 限定符
    的变量或数组. ~const~ 防止值被意外修改, ~static~  意味着每个包含该头文件的文
    件都获得一份副本. 因此, 不需要在一个文件中进行定义式声明, 在其他文件中引用式
    声明.

    ~#include~ 和 ~#define~ 指令是最常用的 2 个 C 预处理器特性

