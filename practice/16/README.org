* C 预处理器和 C 库
  本章介绍以下内容:
  
  - 预处理器指令: 
    + ~#define~
    + ~#include~
    + ~#ifdef~
    + ~#else~
    + ~#endif~
    + ~#ifndef~
    + ~#if~
    + ~#elif~
    + ~#line~
    + ~#error~
    + ~#pragma~
  - 关键字:
    + ~_Generic~
    + ~_Noreturn~
    + ~_Static_assert~
  - 函数/宏
    + ~sqrt()~
    + ~atan()~
    + ~atan2()~
    + ~exit()~
    + ~atexit()~
    + ~assert()~
    + ~memcpy()~
    + ~memmove()~
    + ~va_start()~
    + ~va_arg()~
    + ~va_copy()~
    + ~va_end()~
  - C 预处理器的其他功能
  - 通用选择表达式
  - 内联函数
  - C 库概述和一些特殊用途的方便函数
  
  C 语言建立在适当的关键字, 表达式, 语句以及使用它们的规则上. 然而, C 标准不仅描
  述 C 语言, 还描述如何执行 C 预处理器, C 标准库有哪些函数, 以及详述这些函数的工
  作原理

  C 预处理在 *程序执行之前* 查看程序(故称之为预处理器). 根据程序中的预处理器指令,
  预处理器把符号缩写替换成其表示的内容. 预处理器可以包含程序所需的其他文件, 可以
  选择让编译器查看哪些代码. 预处理器 *并不知道 C*. 基本上它的工作是把一些文本转
  换成另外一些文本.

** 翻译程序的第一步
   在预处理器之前, 编译器必须对该程序进行一些翻译处理. 首先, 编译器把源代码中出
   现的 *字符映射到源字符集*. 该过程处理多字节字符和三字符序列 -- 字符扩展让 C 更加
   国际化

   第二, 编译器 *定位每个反斜杠后面跟着换行符的实例*, 并删除它们.
   eg: 下面的 *物理行(physical line)*:
   #+begin_src c
     printf("That's wond\
     erful!\n");
   #+end_src

   转换成一个 *逻辑行(logical line)*:
   #+begin_src c
     printf("That's wonderful!\n");
   #+end_src

   *注意*: 在这种场合中, "换行符" 的意思是通过按下 ~Enter~ 键在源代码文件中换行
   所生成的字符, 而不是指符号表征 ~\n~
    
   由于预处理器表达式的长度必须是一个逻辑行, 所以这一步为预处理器做好了准备工作.
   一个逻辑行可以是多个物理行

   第三, 编译器把文本划分成预处理器记号序列, 空白序列和注释序列(记号是由空格, 制
   表符活换行符分隔的项). 这里要注意的是, 编译器将由一个空格字符替换每一条注释.

   eg: 下面代码:
   #+begin_src c
     int/* 这看起来并不像一个空格 */fox;
   #+end_src

   处理后:
   #+begin_src c
     int fox;
   #+end_src
   
   而且, 实现可以用 *一个空格替换所有的空白字符序列* (不包括换行符). 最后, 程序
   已经 *准备好进入预处理阶段*, 预处理器查找一行中以 ~#~ 号开始的预处理命令
** 明示常量: ~#define~
   ~#define~ 预处理器指令和其他预处理器指令一样, 以 ~#~ 号 作为一行的开始. ANSI
   和后来的标准都允许 ~#~ 号前面有空格或制表符, 而且还允许在 ~#~ 和 指令的其余部
   分之间有空格. 旧版本的 C 要求质量从一行最左边开始, 而且 ~#~ 和指令其余部分之
   间不能有空格. 

   指令可以出现在源文件的任何地方, 其定义从指令出现的地方到该文件末尾有效. 我们
   大量使用 ~#define~ 指令来 *定义明示常量(manifest constant)(也叫做符号常量)*,
   但是该指令还有许多其他用途. 见 ~prepro.c~ 用法.

   预处理器指令从 ~#~ 开始运行, 到后面的 *第一个换行符为止*. 也就是说, 指令的长
   度仅限于一行. 然而, 前面提到过, 在预处理开始前, 编译器会把多行物理行处理为一
   行逻辑行

   每行(逻辑行) ~#define~ 都由 3 部分组成.
   1. ~#define~ 指令本身
   2. 选定的缩写, 也称为宏. 有些宏代表值(如本例), 这些宏被称为 *类对象宏*
      (object-like macro). C 语言还有 *类函数宏* (function-like macro).
      宏的名称中 *不允许有空格*, 而且不洗遵循 C 变量的命名规则
   3. 指令行的其余部分: 替换列表或替换体.
      一旦预处理器在程序中找到宏的实例后, 就会用替换体代替该宏(也有例外). 从宏变
      成最终替换文本的过程称为 *宏展开* (macro expansion).

      *注意*: 可以在 ~#define~ 行使用标准 C 注释

      
   由于编译器会在编译期对说哟逇常量表达式(只包含常量的表达式) 求值, 所以预处理器
   *不会进行实际的乘法运算*, 这一过程在 *编译时* 进行. 预处理器不做计算, 不对表
   达式求值, 它只进行替换

   *注意*: 宏定义还可以包含其他宏(一些编译器不支持嵌套):

   #+begin_src c
     printf(FMT, x);
   #+end_src

   变成了:
   #+begin_src c
     printf("X is %d.\n", x);
   #+end_src

   相应的字符串替换了 ~FMT~

   可以在 *一行的结尾加一个反斜杠字符使该行扩展至下一行*
   *注意*: 下一行要与第一行左对齐

   使用字符常量的时机: 对于绝大部分 *数字常量, 应该使用字符常量*. 如果在算式中用
   字符常量代替数字, 常量明能更清楚地表达该数字的含义. 如果是数组大小的数字, 用
   符号常量后更容易改变数组的大小和循环次数. 如果是数字是系统代码(eg: *EOF*), 用
   符号常量表示的代码 *更容易移植*.

   符号常量有价值的特性: *助记*, *易更改*, *可移植*

   C 语言也支持 ~const~ 关键字, 可以创建在程序运行过程中不能改变的变量. 创建的变
   量可具有文件作用域或块作用域, *宏常量可用于指定标准数组的大小和 ~const~ 变量
   的初始值*

   #+begin_src c
     #define LIMIT 20
     const int LIM = 50;

     static int data1[LIMIT]; // 有效
     static int data2[LIM]; // 无效
     const int LIM2 = 2 * LIMIT; // 有效
     const int LIM3 = 2 * LIM; // 无效
   #+end_src

   在 C 中, 非自动数组的大小应该是 *整型常量表达式*, 这意味着表示数组大小的必须
   是 *整形常量的组合*, *不包括 ~const~ 声明的值. 但是, Clang 4.6 允许此声明, 为
   了可移植性, 谨慎使用.
*** 记号
*** 记号
    从技术角度来看, 可以把 *宏的替换体看作是记号(token)型字符串*, 而不是字符型字
    符串. C 预处理器记号是宏定义的替换体中单独的 "词". 用空白把这些词分开.

    eg:
    #+begin_src c
      #define FOUR 2 * 2
    #+end_src

    该宏定义有一个记号: 2 * 2 序列. 但是, 下面的宏定义中:
    #+begin_src c
      #define SIX 2 * 3
    #+end_src
    
    有 3 个记号: ~2~, ~*~, ~3~.

    替换体中有多个空格时, 字符型字符串和记号型字符串的处理方式不同.

    eg:
    #+begin_src c
      #define EIGHT 4 * 8
    #+end_src
    
    如果预处理器把该替换体解释为字符型字符串, 将用 4 * 8 替换 ~EIGHT~.
    即: 额外的空格是替换体的一部分.

    如果预处理器把该替换体解释为记号型字符串, 则用 3 个的记号 4 * 8(分别由单个空
    格分隔) 来替换 ~EIGHT~.

    换而言之, 解释为字符型字符串, *把空格视为替换体的一部分*; 解释为记号型字符串,
    *把空格视为替换体中各记号的分隔符*. 在实际应用中, 一些 C 编译器把宏替换体视
    为字符串而不是记号. 在比这个例子更复杂的情况下, 两者的区别才有实际意义
    
    顺带一提, C 编译器处理记号的方式比预处理器复杂. 由于编译器理解 C 语言的规则,
    *所以不要求代码中用空格来分割记号*. eg: C 编译器可以把 ~2 * 2~ 直接视为 3 个记
    号, 因为它可以识别 2 是常量, * 是运算符

*** 重定义常量
    不同的实现才用不同的重定义方案, 除非新定义与就定义相同, 否则有些实现会将其视
    为错误. 另外一些实现允许重定义, 但会给出警告. ANSI 标准采用第一种方案, 只有
    新定义和就定义完全相同才允许重定义

    具有相同的定义意味着替换体中的 *记号必须相同, 且顺序也相同*.

    eg: 两个定义相同
    #+begin_src c
      #define SIX 2 * 3
      #define SIX 2 * 3
    #+end_src

    这两条定义都有 3 个相同的记号, 额外的空格不算替换体的一部分. 而下面的定义则
    与上面 2 条宏定义不同:
    
    eg: *不同*
    #+begin_src c
      #define SIX 2*3
    #+end_src

    这条宏定义中只有一个记号, 因此与前 2 条定义不同. 如果需要重定义宏, 使用
    ~#undef~ 指令

    如果确实需要重定义常量, 使用 ~const~ 关键字和作用域规则更容易些

** 在 ~#define~ 中使用参数
   在 ~#define~ 中使用参数可以创建外形和作用与函数类似的 *类函数宏*. 带有参数的
   宏看上去很像函数, 因为这样的宏也是用圆括号. 内函数宏定义的圆括号中可以有一个
   或多个参数, 随后这些参数出现在替换体中

   #+begin_src c
     #define MEAN(X, Y) (((X) + (Y)) / 2)
     //      宏 (包含: 宏参数)  替换体
   #+end_src

   eg:
   #+begin_src c
     #define SQUARE(X) X * X
   #+end_src

   用法:
   #+begin_src c
     z = SQUARE(2);
   #+end_src

   看上去像函数调用, 但是它的行为和函数调用完全不同. 

   见 ~mac_arg.c~ 用法

   代码中, ~SQUARE~ 是宏标识符, ~SQUARE(X)~ 中的 ~X~ 是宏参数, ~X * X~ 是替换列
   表, 代码中出现 ~SQUARE(X)~ 的地方都会被 ~X * X~ 替换.

   ~SQUARE(x + 2)~ 被替换为 ~x+2*x+2~, 没有括号, 所以结果为 17

   函数调用在程序运行时把参数的值传递给函数. 宏调用在 *编译之前把参数记号传递给
   程序*. 这两个不同的过程发生在不同时期.
   
   eg: 规避上述问题
   #+begin_src c
     #define SQUARE(x) (x)*(x)
   #+end_src

   并未解决如下问题:
   #+begin_src c
     100/SQUARE(2);
   #+end_src

   替换结果:
   #+begin_src c
     100/2*2
   #+end_src

   适用上述问题的解决方案之一:
   #+begin_src c
     #define SQUARE(x) (x*x)
   #+end_src

   合并解决方案:
   #+begin_src c
     #define SQUARE(x) ((x)*(x))
   #+end_src

   尽管如此, 还是无法避免如下问题:
   #+begin_src c
     SQUARE(++x);
     // 替换结果: ++x*++x=6*7 = 42
   #+end_src

   标准 *并未对这类运算规定顺序*, 所以不同编译器结果不同, 但 ~x~ 的最终值是 7

   尽量避免在宏参数中使用 *递增递减运算符*.

*** 用宏参数创建字符串: ~#~ 运算符
    一个类函数宏:
    #+begin_src c
      #define PSQR(X) printf("The square of X is %d.\n", ((X)*(X));
    #+end_src

    使用:
    #+begin_src c
      PSQR(8);
    #+end_src

    结果:
    #+begin_src text
      The squre of X is 64.
    #+end_src

    双引号的字符串中的 ~X~ 被视为 *普通文本*, 而不是一个可被替换的记号

    C 允许在字符串中包含宏参数. 在类函数宏的替换体中, ~#~ 号作为一个预处理运算符,
    可以把记号转换成字符串.

    eg: x 是一个宏形参, 那么 ~#x~ 就是转换为字符串 "x" 的形参名, 这个过程称为 
    *字符串化 (stringizing)*.

    见 ~subst.c~ 用法

    调用第一个宏时, 用 ~"y"~ 替换 ~#x~. 调用第二个宏时, 用 ~"2 + 4"~ 替换 ~#x~.

    ANSI C 字符串的串联特性将这些字符串与 ~printf()~ 语句的其他字符串组合, 生成
    最终的字符串

    第一次调用:
    #+begin_src c
      printf("The square of " "y" " is %d.\n", ((y)*(y)));
    #+end_src

    然后, 字符串串联功能将 3 个相邻的字符串组合:
    #+begin_src c
      "The squre of y is %d.\n"
    #+end_src
    
*** 预处理器黏合剂: ~##~ 运算符
    与 ~#~ 运算符类似, ~##~ 运算符可用于类函数宏的替换部分. 而且, ~##~ 还可用于
    对象宏的替换部分. ~##~ 运算符把 2 个记号组合成一个记号.

    eg:
    #+begin_src c
      #define XNAME(n) x##n
    #+end_src

    然后, 宏 ~XNAME(4)~ 将展开为 ~x4~.

    见 ~glue.c~ 用法

    *注意*: ~PRINT_XN()~ 宏用 ~#~ 运算符组合字符串, ~##~ 运算符把记号组合为一个
     新的标识符
*** 变参宏: ~...~ 和 ~__VA_ARGS__~
    一些函数(如: ~printf()~) 接受 *数量可变的参数*. ~stdvar.h~ 头文件提供了工具,
    让用户 *自定义带可变参数的函数*. C99/C11 也对宏提供了这样的工具. 虽然标准中
    未使用 "可变"(variadic) 这个词, 但是它已成为描述这种工具的通用词(虽然 C 标准
    的索引添加了字符串化(stringizing) 词条, 但是并未把固定参数的函数或宏称为固定
    函数和不变宏)

    通过把宏参数列表中最后的参数写成省略号(即: 3 个点 ~...~) 来实现这一功能. 这
    样, 预定义宏 ~__VA_ARGS__~ 可用在替换部分中, 表明省略号代表什么.

    eg: 下面的定义:
    #+begin_src c
      #define PR(...) printf(__VA_ARGS__)
    #+end_src

    假设稍后调用该宏:
    #+begin_src c
      PR("Howdy");
      PR("weight=%d, shipping=$%.2f\n", wt, sp);
    #+end_src

    对于第一次调用, ~__VA_ARGS__~ 展开为一个参数: "Howdy".

    对于第二次调用, ~__VA_ARGS__~ 展开为三个参数: "weight = %d,
    shipping=$%.2f\n", wt, sp

    因此, 展开后的代码是:
    #+begin_src c
      printf("Howdy");
      printf("weight = %d, shipping = $%.2f\n", wt, sp);
    #+end_src
    
    示例: ~variadic.c~ 使用了字符串的串联功能和 ~#~ 运算符

    第一个宏调用, X 的值是 1, 所以 ~#X~ 变成 "1", 展开后为:
    #+begin_src c
      printf("Message""1"":""x=%g\n", x);
    #+end_src

    然后串联 4 个字符
    #+begin_src c
      printf("Message 1: x=%g\n", x);
    #+end_src

    *注意*: 省略号只能代替最后的宏参数:
    错误用法:
    #+begin_src c
      #define WRONG(X, ..., Y) #X#__VA_ARGS__#y
    #+end_src
** 宏和函数的选择
   使用宏比使用普通函数复杂, *稍有不慎会产生奇怪的副作用*.
   *一些编译器规定宏指令定义成一行*

   *宏和函数的选择实际上是时间和空间的权衡*. 宏生成内嵌代码, 即在程序中生成语句.
    如果调用 20 次宏, 即在程序中插入 20 行代码. 如果调用函数 20 次, 程序中只有一
    份函数语句的副本, 所以节省了空间. 然而另一方面, 程序的控制必须 *跳转* 至函数
    内, 随后再返回主调程序, 这显然比内联代码花费更多的时间

    宏的一个优点是, 不用担心变量类型(这是因为 *宏处理的是字符串*, 而不是实际的值).
    因此, 只要能用 ~int~ 或 ~float~ 类型都可以使用 ~SQUARE(x)~ 宏

    C99 提供了内联函数. 后面介绍

    简单的函数, 通常使用宏: 
    #+begin_src c
      #define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
      #define ABS(X) ((X) < 0 ? -(X) : (X))
      #define ISSIGN(X) ((X) == '+' || (X) == '0' ? 1 : 0)
    #+end_src

    *使用时注意*:
    1. 宏名中 *不允许有空格*, 但是在替换字符串中可以有空格. ANSI C 允许在参数列
       表中使用空格
    2. 用圆括号把宏的参数和整个替换体括起来. 这样能确保被括起来的部分在表达式中
       正确展开
       #+begin_src c
         forks = 2 * MAX(guests + 3, last);
       #+end_src
    3. 用大写字母表示宏函数的名称. 可以提醒程序员注意产生的副作用
    4. 如果打算用来加快程序的运行速度, 那么首先要确定使用宏和使用函数是否会导致
       较大差异. 在程序中 *只使用一次的宏无法明显减少程序的运行时间*. 在嵌套循环
       中还是用宏更有助于提高效率. 许多系统提供程序分析器以帮助程序员压缩程序中
       最耗时的部分
       
    假设开发了一些方便的宏函数, 使用 ~#include~ 指令可以复用该宏
** 文件包含: ~#include~
   当预处理器发现 ~#include~ 指令时, 会查看后面的文件名并把文件的内容包含到当前
   文件中, 即替换源文件中的 ~#include~ 指令. 这相当于把被包含文件的全部内容输入
   到源文件 ~#include~ 指令所在的位置. ~#include~ 指令有 2 种形式
   
   #+begin_src c
     #include <stdio.h> // 文件名在尖括号中
     #include "mystuff.h" // 文件名在双引号中
   #+end_src

   在 UNIX 系统中, 尖括号告诉预处理器 *在标准系统目录中* 查找该文件. 双引号告诉
   预处理器 *首先在当前目录中* (或文件名中指定的其他目录) 查找该文件, 如果未找到
   再查找标准系统目录

   #+begin_src c
     #include <stdio.h> // 查找系统目录
     #include "hot.h" // 查找当前工作目录
     #include "/usr/biff/p.h" // 查找 /usr/biff目录
   #+end_src

   集成开发环境(IDE) 也有标准路径或系统头文件的路径. 许多集成开发环境提供菜单选
   项, 指定用尖括号时查找路径. 在 UNIX 中, 使用双引号意味着先查找本地目录, 但是
   具体查找哪个目录取决于编译器的设定. 有些编译器会搜索源代码文件所在的目录, 有
   些编译器则 搜索当前的工作目录, 还有些搜索项目文件所在的目录.

   ANSI C *不为文件系统提供统一的目录模型*, 因为不同的计算机所用的系统不同. 一般
   而言, 明明文件的方法因系统而异, 但是尖括号和双引号的规则与系统无关.

   包含文件的目的: 编译器需要这些文件中的信息. 
   eg: ~stdio.h~ 文件中通常包含 ~EOF~, ~NULL~, ~getchar()~ 和 ~putchar()~ 的定
   义. ~getchar()~ 和 ~putchar()~ 被定义为宏函数. 此外, 该文件中还包含 C 的其他
   I/O 函数

   C 语言习惯用 *.h 后缀表示头文件*, 这些文件包含需要放在程序 *顶部* 的信息. 头
   文件经常包含一些预处理器指令. 有些头文件(eg: ~stdio.h~) 由系统提供, 也可以自
   己创建.
   
   包含一个大型头文件不一定显著增加程序的大小. 在大部分情况下, 头文件的内容是编
   译器生成最终代码时所需的信息, 而不是添加到最终代码中的材料

*** 头文件示例
    假设开发了一个存放人名的结构, 还编写了一些使用该结构的函数. 可以把不同的什么
    放在头文件中, ~names_st.h~ 头文件演示了该例子

    该头文件包含了一些头文件中常见的内容: ~#define~ 指令, 结构声明, ~typedef~ 和
    函数原型.

    *注意*: 这些内容是编译器在 *创建可执行时所需的信息, 而不是可执行代码*. 为安
     全起见, 通常, 应该用 ~#ifndef~ 和 ~#define~ 防止多重包含头文件.

     可执行代码通常在源文件代码中, 而不是在头文件中. 例如, ~names_st.c~ 中有头文
     件中函数原型的定义. 该程序包含了 ~names_st.h~ 头文件, 所以编译器知道
     ~names~ 类型

     ~get_names()~ 函数通过 ~s_gets()~ 函数调用了 ~fgets()~ 函数, 避免了目标数组
     溢出. ~useheader.c~ 使用了头文件与源文件

     *注意*: 两个源代码文件都是用 ~names_st~ 类型结构, 所以都必须包含
      ~names_st.h~ 头文件

      必须编译和链接 ~names_st.c~ 和 ~useheader.c~ 源代码文件

      声明和指令放在 ~names_st.h~ 头文件中, 函数定义放在 ~names_st.c~ 源代码文件
      中
*** 使用头文件
    浏览任何一个标准头文件都可以了解头文件的基本信息. 
    头文件中最常用的形式如下:

    - 明示常量: eg: ~stdio.h~ 中定义的 ~EOF~, ~NULL~ 和 ~BUFSIZE(标准 I/O 缓冲区
      大小)~
    - 宏函数: eg: ~getc(stdin)~ 通常用 ~getchar()~ 定义, 而 ~getc()~ 经常用于定
      义较复杂的宏, 头文件 ~ctype.h~ 通常包含 ~ctype~ 系列函数的宏定义.
    - 函数声明: eg: ~string.h~ 头文件(一些旧系统中是 ~strings.h~) 包含字符串函数
      系列的函数声明. 在 ANSI C 和后面的标准中, 函数声明都是函数原型形式.
    - 结构模板定义: 标准 I/O 函数使用 ~FILE~ 结构, 该结构中包含了文件和文件缓冲
      区相关的信息. ~FILE~ 结构在头文件 ~stdio.h~ 中
    - 类型定义: 标准 I/O 函数使用指向 ~FILE~ 的指针作为参数. 通常, ~stdio.h~ 用
      ~#define~ 或 ~typedef~ 把 ~FILE~ 定义为指向结构的指针. 类似地, ~size_t~ 和
      ~time_t~ 类型也定义在在头文件中

      
    如果开发一系列相关的函数或结构, 使用自己开发的标准头文件特别有价值.

    还可以使用头文件声明外部变量供其他文件共享. eg: 已经开发了共享某个变量的一系
    列函数, 该变量报告某种状况(eg: 错误情况), 这种方法就很有效. 该情况下, 可以在
    包含函数声明的源代码文件定义一个文件作用域的外部链接变量:

    #+begin_src c
      int status = 0; // 该变量具有文件作用域, 在源代码文件
    #+end_src

    然后, 可以在与源代码文件相关联的头文件中进行引用式声明:
    #+begin_src c
      extern int status; // 在头文件中
    #+end_src

    这行代码会出现在包含了该头文件的文件中, 这样使用该系列函数的文件都能使用这个
    变量. 
    虽然源代码文件中包含该头文件后也包含了该声明. 但是 *只要声明的类型一致*, 在
    一个文件中同时使用定义式声明和引用式声明没问题.

    需要包含头文件的另一种情况是: 使用具有文件作用域, 内部链接和 ~const~ 限定符
    的变量或数组. ~const~ 防止值被意外修改, ~static~  意味着每个包含该头文件的文
    件都获得一份副本. 因此, 不需要在一个文件中进行定义式声明, 在其他文件中引用式
    声明.

    ~#include~ 和 ~#define~ 指令是最常用的 2 个 C 预处理器特性
** 其他指令
   程序员可能要为不同的话工作环境准备 C 程序和 C 库包. 不同的环境可能使用不同的
   代码类型. 预处理器提供一些指令, 程序员通过修改 ~#define~ 的值即可生成可移植的
   代码. ~#undef~ 指令取消之前的 ~#define~ 定义, ~#if~, ~#ifdef~, ~#ifndef~,
   ~#else~, ~#elif~ 和 ~#endif~ 指令用于指定什么情况下编写哪些代码. ~#line~ 指令
   用于重置行和文件信息, ~#error~ 指令用于给出错误消息, ~#pragma~ 指令用于向编译
   器发出指令.

*** ~#undef~ 指令
    该指令用于 "取消" 已定义的 ~#define~ 指令.

    eg: 假设有如下定义:
    #+begin_src c
      #define LIMIT 400
    #+end_src

    下面的指令将移除上面的定义
    #+begin_src c
      #undef LIMIT
    #+end_src

    这样, 现在就可以把 ~LIMIT~ 重新定义为一个新值. 
    即使原来没有定义 ~LIMIT~, *取消 ~LIMIT~ 的定义仍然有效*. 

    如果想使用一个名称, 又不确定之前是否已经用过, 为安全起见, 可以用 ~#undef~ 指
    令取消该名字的定义

*** 从 C 预处理角度看已定义
    处理器在识别标识符时, 遵循与 C 相同的规则: 标识符可以由大写字母, 小写字母,
    数字和下划线字符组成, 且首字符不能是数字. 当预处理器在预处理器指令中发现一个
    标识符时, 它会把该标识符当做已定义的或未定义的. 这里的已定义表示由预处理器定
    义. 如果标识符是同一个文件中由前面的 ~#define~ 指令创建的宏名, 而且没有
    ~#undef~ 指令关闭, 那么该标识符是已定义的. 如果标识符不是宏, 假设是一个文件
    作用域的 C 变量, 那么该标识符对预处理器而言就是未定义的

    已定义宏可以是对象宏, 包括空宏或类函数宏

    #+begin_src c
      #define LIMIT 1000 // LIMIT 是已定义的
      #define GOOD // GOOD 是已定义的
      #define A(X) ((-(X))*(X)) // A 是已定义的
      int q; // q 不是宏, 因此是未定义的
      #undef GOOD // GOOD 取消定义, 是未定义的
    #+end_src

    *注意*: ~#define~ 宏的作用域从它在文件中的声明处开始, 直到用 ~#undef~ 指令取
    消宏位置, 或延伸至文件尾 (以二者中想满足的条件作为宏作用域的结束). 另外还要
    注意, 如果宏通过头文件引入, 那么 ~#define~ 在文件中的位置取决于 ~#include~
    指令的位置

    稍后将介绍几个预定义宏: eg: ~__DATE__~ 和 ~__FILE__~. 这些宏一定是已定义的, 
    *而且不能取消定义*
*** 条件编译
    可以使用其他指令创建 *条件编译(conditinal compilation)*. 也就是是说, 可以使
    用这些指令告诉编译器 *根据编译时的条件执行或忽略信息(或代码)块*

**** ~#ifdef~, ~#else~ 和 ~#endif~ 指令
     可以用一个简短的示例来演示条件编译的情况. 考虑下面的代码:
     #+begin_src c
       #ifdef MAVIS
       #include "horse.h" // 如果已经用 #define 定义了 MAVIS, 则执行下面的指令
       #define STABLES 5
       #else
       #include "cow.h" // 如果没有用 #define 定义 MAVIS, 则执行下面的指令
       #define STABLES 15
       #endif
     #+end_src

     这里使用的较新的编译器和 ANSI 标注支持的缩进格式. 如果使用旧的编译器, 必须
     左对齐所有的指令或至少左对齐 ~#~ 号, 如下所示:

     #+begin_src c
       #ifdef MAVIS
       #include "horse.h" // 如果已经用 #define 定义了 MAVIS, 则执行下面的指令
       #define STABLES 5
       #else
       #include "cow.h" // 如果没有用 #define 定义 MAVIS, 则执行下面的指令
       #define STABLES 15
       #endif
     #+end_src

     ~#ifdef~ 指令说明, 如果预处理器已定义了后面的标识符(~MAVIS~), 则执行
     ~#else~ 或 ~#endif~ 指令之前的所有指令并编译所有 C 代码(先出现哪个指令就执
     行到哪里). 如果预处理器未定义 ~MAVIS~, 且有 ~#else~ 指令, 则执行 ~#else~ 和
     ~#endif~ 指令之间的所有代码

     ~#ifdef~ ~#else~ 很像 C 的 if else. 两者的主要区别是: 预处理器不识别用于标
     记的花括号 ({}), 因此它使用 ~#else(如果需要)~ 和 ~#endif(必须存在)~ 来标记
     指令块, 这些指令结构可以嵌套. 也可以用这些指令标记 C 语句块, 如 ~ifdef.c~

     如果省略 ~JUST_CHECKING~ 定义(注释或者使用 ~#undef~ 指令取消它的定义) 并重
     新编译该程序, 只会输出最后一行. 可以用这种方法调试程序.

     定义 ~JUST_CHECING~ 并合理使用 ~#ifdef~, 编译器将执行用于调试的程序代码, 打
     印中间值. 调试结束后, 可移除 ~JUST_CHECKING~ 定义并重新编译. 如果以后还需要
     使用这些信息, 重新插入定义即可. 这样做生蛆了再次输入额外打印语句的麻烦.
     ~#ifdef~ 还可用于根据不同的 C 实现选择合适的代码块

**** ~#ifndef~ 指令
     与 ~#ifdef~ 指令的用法类似, 也可以和 ~#else~, ~#endif~ 一起使用, 但是它们的
     逻辑相反. ~#ifndef~ 指令判断后面的标识符是否是未定义的, 常用语定义之前未定
     义的变量

     eg:
     #+begin_src c
       #ifndef SIZE
       #define SIZE 100
       #endif
     #+end_src

     (旧的实现可能不允许使用缩进的 ~#define~)

     通常, 包含多个头文件时, 其中的文件可能包含了相同宏定义. ~#ifndef~ 指令可以
     防止相同的宏被重复定义. 在首次定义一个宏的头文件中使用 ~#ifndef~ 指令激活定
     义, 随后在其他头文件中的定义都被忽略
     
     ~#ifndef~ 指令还有另一种用法. 假设有上面的 ~arrays.h~ 头文件, 然后把下面的
     一行代码放入一个头文件中:
     #+begin_src c
       #incldue "arrarys.h"
     #+end_src

     ~SIZE~ 被定义为 100, 但是, 如果把下面的代码放入该头文件:
     #+begin_src c
       #define SIZE 10
       #include "arrays.h"
     #+end_src

     ~SIZE~ 则被设置为 10. 这里, 当之前到 ~#include "arrays.h"~ 这行, 处理
     ~arrays.h~ 中的代码时, 由于 ~SIZE~ 是已定义的, 所以 *跳过* 了 ~#define SIZE
     100~ 这行代码. 鉴于此, 可以利用这种方法, 用一个较小的数组测试程序. 测试完毕
     后, 移除 ~#define SIZE 10~ 并重新编译. 这样, 就不用修改头文件数组本身了

     ~#ifndef~ 指令通常用于防止多次包含一个文件. 
     eg:
     #+begin_src c
       #ifndef THINGS_H_
       #define THINGS_H_
       #endif
     #+end_src

     因为许多被包含的文件中都包含着其他文件, 所以显式包含的文件中可能包含着已经
     包含的其他文件.
     问题: 在被包含的文件中有某些项只能在一个文件中出现一次.
     问题: 如何确保待测试的标识符没有在别处定义. 通常, 实现的供应商使用这些方法
     解决这个问题: 用文件名作为标识符, 使用大写字母, 用下划线字符代替文件名中的
     点字符, 用下划线字符做前缀或后缀(可能使用双下划线).

     eg: 查看 ~stdio.h~ 头文件, 类似代码:
     #+begin_src c
       #ifndef _STDIO_H
       #define _STDIO_H
       // ...
       #endif
     #+end_src

     由于变准保留使用下划线作为前缀, 尽量避免冲突

     ~names.h~ 与 ~doubincl.c~ 程序演示了避免重复包含
**** ~#if~ 和 ~#elif~ 指令
     ~#if~ 指令很像 C 语言中的 ~if~. ~#if~ 后面跟整形常量表达式为非零, 则表达式
     为真. 可以在指令中使用 C 的关系运算符和逻辑运算符:
     #+begin_src c
       #if SYS == 1
       #indlude "ibm.h"
       #endif
     #+end_src

     可以按照 if else 的形式使用 ~#elif(早期的实现不支持#elif)~.
     eg:
     #+begin_src c
       #if SYS == 1
       #include "ibmpc.h"
       #elif SYS == 2
       #include "mac.h"
       #else
       #include "general.h"
       #endif
     #+end_src

     较新的编译器提供另一种方法测试名称是否已定义, 即用 ~#if defined(VAX)~ 代替
     ~#ifdef VAX~

     这里, ~defined~ 是一个预处理运算符, 如果它的从桉树是用 ~#defined~ 定义过,
     则返回 1; 否则返回 0. 这种新方法的有点是: 它可以和 ~#elif~ 一起使用, 下面用
     这种形式重写前面的示例:
     #+begin_src c
       #if defined(IBMPC)
       #include "ibmpc.h"
       #elif defined(MAX)
       #include "vax.h"
       #elif defined(MAC)
       #include "mac.h"
       #else
       #include "general.h"
       #endif
     #+end_src

     如果在 ~VAX~ 机上运行这几行代码, names 应该在文件前面用下面的代码定义 ~VAX~
     #+begin_src c
       #define VAX
     #+end_src
     
     条件编译还有一个用途是让程序更容易移植. 改变文件开头部分的几个关键的定义,
     即可根据不同的系统设置不同的值和包含不同的文件

*** 预定义宏
    C 标准规定了一些预定义宏
    | 宏               | 含义                                                            |
    |------------------+-----------------------------------------------------------------|
    | __DATE__         | 预处理的日期("Mmm dd yyyy" 形式的字符串字面量, 如: Nov 23 2013) |
    | __FILE__         | 表示当前源代码文件名的字符串字面量                              |
    | __LINE__         | 表示当前源代码文件中行号的整型常量                              |
    | __STDC__         | 设置为 1 时, 表明实现遵循 C 标准                                |
    | __STDC_VERSION__ | 支持 C99 标准, 设置为 19901L; 支持 C11 标准, 设置为 201112L     |
    | __TIME__         | 翻译代码的时间, 格式为: "hh:mm:ss"                              |

    C99 标准提供一个名为 ~__func__~ 的预定义标识符, 它展开为一个代表函数名的字符
    串(该函数包含该标识符). 那么, ~__func__~ 必须具有函数作用域, 而从本质上看宏
    具有文件作用域. 因此, ~__func__~ 是 C 语言的 *预定义标识符*, 而不是预定义宏

    ~predef.c~ 中使用一些预定义宏和预定义标识符. *注意*: 其中一些是 C99 新增的,
    所以不支持 C99 的编译器可能无法识别它们. 如果使用 GCC, 必须设置 ~-std=c99~
    或 ~-std=c11~
    
*** ~#line~ 和 ~#error~
    ~#line~ 指令重置 ~__LINE__~ 和 ~__FILE__~ 宏报告的行号和文件名. 可以这样使用
    ~#line~:
    #+begin_src c
      #line 1000 // 把当前行号重置为 1000
      #line 10 "cool.c" // 把行号重置为 10, 把文件名重置为 cool.c
    #+end_src

    ~#error~ 指令让预处理器发出一条错误消息, 该消息包含指令中的文本. 如果可能的
    话, *编译过程应该中断*.
    eg:
    #+begin_src c
      #if __STDC_VERSION__ != 201112L
      #error Not C11
      #endif
    #+end_src

    使用 ~gcc~ 编译以上代码生成后(见 ~newish.c~), 输出如下:
    #+begin_src bash
      gcc newish.c
      # clang
      clang -std=c89 .\newish.c
    #+end_src

    #+begin_src text
      newish.c:2:2: #error Not C11
    #+end_src

    使用 C11:
    #+begin_src bash
      gcc -std=c11 newish.c
      # 或
      clang -std=c11 newish.c
    #+end_src
    
    如果编译器不支持 C11, 失败. 支持则成功
*** ~#pragma~
    在现在的编译器中, 可以通过命令行参数或 IDE 菜单修改编译器的一些设置.

    ~#pragma~ 把编译器指令放入源代码中.

    eg: 在开发 C99 时, 标准被称为 C9X, 可以使用下面的编译指示(pragma) 让编译器支
    持 C9X:
    #+begin_src c
      #pragma c9x on
    #+end_src

    一般而言, 编译器都有自己的编译指示集.
    eg: 编译提示可能用于控制分配给自动变量的内存量, 或者设置错误检查的严格程度,
    或者启用非标准语言特性等. C99 标准提供了 3 个标准编译指示, 但是超出了当前讨
    论范围.

    C99 还提供 ~_Pragma~ 预处理器运算符, 该运算符把字符串转换成普通的编译指示.
    eg:
    #+begin_src c
      _Pragma("nonstandardtreatmenttypeB on")
    #+end_src

    等价于下面的指令
    #+begin_src c
      #pragma nonstandardtreatmenttypeB on
    #+end_src

    由于该运算符不使用 # 符号, 所以可以把它作为宏展开的一部分:
    #+begin_src c
      #define PRAGMA(X) _Pragma(#X)
      #define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)
    #+end_src

    然后, 可以使用类似下面的代码:
    #+begin_src c
      LIMRG(ON)
    #+end_src

    以下定义看上去没问题, 但是 *无法运行*
    #+begin_src c
      #define LIMRG(X) _Pragma(STDC CX_LIMITED_RANGE #X)
    #+end_src

    问题在于这行代码依赖字符串的串联功能, 而 *预处理器过程完成之后才会串联字符
    串*
    
    ~_Pragma~ 运算符完成 "解字符串"(destringizing) 的工作.
    即把字符串中的转移序列转换成它所代表的字符. 因此:
    #+begin_src c
      _Pragma("use_bool\"true\"false")
    #+end_src
    变成了
    #+begin_src c
      #pragma use_bool "true "false
    #+end_src
*** 泛型选择(C11)
    在程序设计中, 泛型变成(generic programming) 指那些没有特定类型, 但是一旦指定
    一种类型, 就可以转换成指定类型的代码.
    eg: C++ 在模板中可以创建泛型算法, 然后编译器根据指定的类型自动使用实例化代码.
    C 没有这个功能. raner, C11 新增了 *泛型选择表达式(generaic selection
    expression)*, 可根据表达式的类型(即表达式的类型是  ~int~, ~double~ 还是其他
    类型) 选择一个值. 泛型选择表达式不是预处理器指令, 但是在一些泛型编程中它常用
    作 ~#define~ 宏定义的一部分.

    eg: 泛型选择表达式:
    #+begin_src c
      _Generic(x, int: 0, float: 1, double: 2, default: 3)
    #+end_src

    ~_Generic~ 是 C11 的关键字. ~_Generic~ 后面的圆括号中包含多个用逗号分隔的项.
    第一个项是表达式, 后面的每个项都由一个类型, 一个冒号和一个值组成.(eg:
    ~float: 1~). 第一个项的类型匹配哪个表情, 整个表达式的值是该标签后面的值.
    eg: 上面表达式中 ~x~ 是 ~int~ 类型的变量, ~x~ 的类型匹配 ~int:~ 表情, names
    整个表达式的值就是 0. 如果没有与类型匹配的表情, 表达式的值就是 ~default:~ 标
    签后面的值. 泛型选择语句与 ~switch~ 语句类似, 只是前者用表达式的类型匹配标签,
    而后者用表达式的值匹配标签.

    eg: 把泛型选择语句和宏定义组合:
    #+begin_src c
      #define MYTYPE(X) _Generic((X),\
          int: "int",\
          float: "float",\
          double: "double",\
          default: "other"\
                                 )
    #+end_src

    宏必须定义为一条逻辑行, 但是可以用 ~\~ 把一条逻辑行分隔成多条物理行. 在这种
    情况下, 对泛型选择表达式求值得字符串. 
    eg: 对 ~MYTYPE(5)~ 求值得 "int", 因为值 5 的类型与 ~int:~ 标签匹配.
    ~mytype.c~ 演示了用法
    
    ~MYTYPE()~ 最后 2 个示例所用的类型与标签不匹配, 所以打印 ~default~ 对应的字
    符串. 可以使用更多类型标签来扩展宏的能力, 但是该程序主要是为了演示基本工作原
    理

    对一个泛型选择表达式求值时, 程序不会相对第一个项求值, 它只确定类型. 只有匹配
    标签的类型后才会对表达式求值.

    可以像使用独立类型("泛型") 函数那样使用 ~_Generic~ 定义宏. 后续 ~math~ 库介
    绍会给出一个示例
*** 内联函数(C99)
     通常, 函数调用都有一定的开销, 因为函数的调用过程包括建立调用, 传递函数,跳转
     到函数代码并返回. 使用宏使代码内联, 可以避免这样的开销.

     C99 还提供另一种方法: *内联函数(inline function)*. 
     "把函数变成内联函数建议尽可能快地调用该函数, 其具体效果由实现定义". 
     因此, 把函数变成内联函数, 编译器可能会用内联代码替换函数调用, 并(或) 执行一
     些其他的优化, 但是也可能不起作用

     创建内联函数的定义有多种方法. 标准规定 *具有内部链接的函数可以成为内联函数*,
     还规定了 *内联函数的定义与调用该函数的代码必须在同一个文件中*.

     因此, 最简单的方法是使用函数说明符 ~inline~ 和存储类别说明符 ~static~. 
     通常, 内联函数应定义在首次使用它的文件中, 所以内联函数也相当于函数原型.
     
     eg:
     #+begin_src c
       #include <stdio.h>

       inline static void eatline() // 内联函数定义/原型
       {
         while (getchar() != '\n') {
           continue;
         }
       }

       int main()
       {
         // ...
         eatline(); // 函数调用
  
       }
     #+end_src

     编译器查看内联函数的定义(也是原型), 可能会用函数体中的代码替换 ~eatline()~
     函数调用. 也就是说, 效果相当于在函数调用的位置输入函数体中的代码

     #+begin_src c
       #include <stdio.h>
       inline static void eatline() // 内联函数定义/原型
       {
         while (getchar() != '\n') {
           continue;
         }
       }

       int main(int argc, char *argv[])
       {
         while (getchar() != '\n') { // 替换函数调用
           continue;
         }
         return 0;
       }
     #+end_src

     *由于并未给内联函数预留单独的代码块*, 所以 *无法获得内联函数的地址*
     (实际上可以获取地址, 不过这样做之后, 编译器会生成一个非内联函数). 另外, 内
     联函数无法在调试器中显示
     
     内联函数应该比较短小. 把较长的函数变成内联并未节约多少时间, 因为执行函数体
     的时间比调用函数的时间长的多

     编译器优化内联函数必须知道该函数体定义的内容. 这意味着内联函数定义与函数调
     用必须在同一个文件中. 鉴于此, 一般情况下内联函数都具有内部链接. 因此, 如果
     程序有多个文件都要使用某个内联函数, 那么这些文件中都 *必须包含该内联函数的
     定义*. 最简单的方法是, 把内联函数定义放入头文件, 并在使用该内联函数的文件中
     包含该头文件即可.

     一般不在头文件中放置可执行代码, 内联函数是个特例. 因为内联函数具有内部链接,
     所以在多个文件中定义同一个内联函数不会产生什么问题.

     与 C++ 不同的是, C 还允许 *混合使用内联函数定义和外部函数定义(具有外部链接
     的定义)*.

     eg: 一个程序中使用下面 3 个文件
     
     eg: file1.c
     #+begin_src c
       inline static double square(double);

       int main()
       {
         double q = square(1.3);
       }
     #+end_src
     

     eg: file2.c
     #+begin_src c
       double square(double x) {
         return (int) (x*x);
       }

       void spam(double v)
       {
         double kv = square(v);
       }
     #+end_src

     eg: file3.c
     #+begin_src c
       inline double square(double x) {
         return (int) (x * x + 0.5);
       }

       void masp(double w)
       {
         double kw = square(w);
       }
     #+end_src

     3 个文件中都定义了 ~square()~ 函数. ~file1.c~ 文件中是 ~inline static~ 定
     义; ~file2.c~ 文件中是普通的函数定义(因此具有外部链接); ~file3.c~ 文件中是
     ~inline~ 定义, 省略了 ~static~

     3 个文件中的函数都调用了 ~square~ 函数, ~file1.c~ 文件中的 ~main()~ 使用
     ~square()~ 的局部 ~static~ 定义. 由于该定义也是 ~inline~ 定义, 所以编译器有
     可能优化代码, 也许会内联该函数, 该定义具有外部链接, 其他文件也可见.
     ~file3.c~ 文件中, 编译器既可以使用该文件中 ~square()~ 函数的内联定义, 也可
     以使用 ~file2.c~ 文件中的外部链接定义. 如果像 ~file3.c~ 那样, 省略
     ~file1.c~ 文件 ~inline~ 定义中的 ~static~, 那么该 ~inline~ 定义被视为可替换
     的外部定义

     *注意*: GCC 在 C99 之前就使用了一些不同的规则实现了内联函数, 所以 GCC 可以
     根据当前编译器的标记来解释 ~inline~
     
