* C 预处理器和 C 库
  本章介绍以下内容:
  
  - 预处理器指令: 
    + ~#define~
    + ~#include~
    + ~#ifdef~
    + ~#else~
    + ~#endif~
    + ~#ifndef~
    + ~#if~
    + ~#elif~
    + ~#line~
    + ~#error~
    + ~#pragma~
  - 关键字:
    + ~_Generic~
    + ~_Noreturn~
    + ~_Static_assert~
  - 函数/宏
    + ~sqrt()~
    + ~atan()~
    + ~atan2()~
    + ~exit()~
    + ~atexit()~
    + ~assert()~
    + ~memcpy()~
    + ~memmove()~
    + ~va_start()~
    + ~va_arg()~
    + ~va_copy()~
    + ~va_end()~
  - C 预处理器的其他功能
  - 通用选择表达式
  - 内联函数
  - C 库概述和一些特殊用途的方便函数
  
  C 语言建立在适当的关键字, 表达式, 语句以及使用它们的规则上. 然而, C 标准不仅描
  述 C 语言, 还描述如何执行 C 预处理器, C 标准库有哪些函数, 以及详述这些函数的工
  作原理

  C 预处理在 *程序执行之前* 查看程序(故称之为预处理器). 根据程序中的预处理器指令,
  预处理器把符号缩写替换成其表示的内容. 预处理器可以包含程序所需的其他文件, 可以
  选择让编译器查看哪些代码. 预处理器 *并不知道 C*. 基本上它的工作是把一些文本转
  换成另外一些文本.

** 翻译程序的第一步
   在预处理器之前, 编译器必须对该程序进行一些翻译处理. 首先, 编译器把源代码中出
   现的 *字符映射到源字符集*. 该过程处理多字节字符和三字符序列 -- 字符扩展让 C 更加
   国际化

   第二, 编译器 *定位每个反斜杠后面跟着换行符的实例*, 并删除它们.
   eg: 下面的 *物理行(physical line)*:
   #+begin_src c
     printf("That's wond\
     erful!\n");
   #+end_src

   转换成一个 *逻辑行(logical line)*:
   #+begin_src c
     printf("That's wonderful!\n");
   #+end_src

   *注意*: 在这种场合中, "换行符" 的意思是通过按下 ~Enter~ 键在源代码文件中换行
   所生成的字符, 而不是指符号表征 ~\n~
    
   由于预处理器表达式的长度必须是一个逻辑行, 所以这一步为预处理器做好了准备工作.
   一个逻辑行可以是多个物理行

   第三, 编译器把文本划分成预处理器记号序列, 空白序列和注释序列(记号是由空格, 制
   表符活换行符分隔的项). 这里要注意的是, 编译器将由一个空格字符替换每一条注释.

   eg: 下面代码:
   #+begin_src c
     int/* 这看起来并不像一个空格 */fox;
   #+end_src

   处理后:
   #+begin_src c
     int fox;
   #+end_src
   
   而且, 实现可以用 *一个空格替换所有的空白字符序列* (不包括换行符). 最后, 程序
   已经 *准备好进入预处理阶段*, 预处理器查找一行中以 ~#~ 号开始的预处理命令
** 明示常量: ~#define~
   ~#define~ 预处理器指令和其他预处理器指令一样, 以 ~#~ 号 作为一行的开始. ANSI
   和后来的标准都允许 ~#~ 号前面有空格或制表符, 而且还允许在 ~#~ 和 指令的其余部
   分之间有空格. 旧版本的 C 要求质量从一行最左边开始, 而且 ~#~ 和指令其余部分之
   间不能有空格. 

   指令可以出现在源文件的任何地方, 其定义从指令出现的地方到该文件末尾有效. 我们
   大量使用 ~#define~ 指令来 *定义明示常量(manifest constant)(也叫做符号常量)*,
   但是该指令还有许多其他用途. 见 ~prepro.c~ 用法.

   预处理器指令从 ~#~ 开始运行, 到后面的 *第一个换行符为止*. 也就是说, 指令的长
   度仅限于一行. 然而, 前面提到过, 在预处理开始前, 编译器会把多行物理行处理为一
   行逻辑行

   每行(逻辑行) ~#define~ 都由 3 部分组成.
   1. ~#define~ 指令本身
   2. 选定的缩写, 也称为宏. 有些宏代表值(如本例), 这些宏被称为 *类对象宏*
      (object-like macro). C 语言还有 *类函数宏* (function-like macro).
      宏的名称中 *不允许有空格*, 而且不洗遵循 C 变量的命名规则
   3. 指令行的其余部分: 替换列表或替换体.
      一旦预处理器在程序中找到宏的实例后, 就会用替换体代替该宏(也有例外). 从宏变
      成最终替换文本的过程称为 *宏展开* (macro expansion).

      *注意*: 可以在 ~#define~ 行使用标准 C 注释

      
   由于编译器会在编译期对说哟逇常量表达式(只包含常量的表达式) 求值, 所以预处理器
   *不会进行实际的乘法运算*, 这一过程在 *编译时* 进行. 预处理器不做计算, 不对表
   达式求值, 它只进行替换

   *注意*: 宏定义还可以包含其他宏(一些编译器不支持嵌套):

   #+begin_src c
     printf(FMT, x);
   #+end_src

   变成了:
   #+begin_src c
     printf("X is %d.\n", x);
   #+end_src

   相应的字符串替换了 ~FMT~

   可以在 *一行的结尾加一个反斜杠字符使该行扩展至下一行*
   *注意*: 下一行要与第一行左对齐

   使用字符常量的时机: 对于绝大部分 *数字常量, 应该使用字符常量*. 如果在算式中用
   字符常量代替数字, 常量明能更清楚地表达该数字的含义. 如果是数组大小的数字, 用
   符号常量后更容易改变数组的大小和循环次数. 如果是数字是系统代码(eg: *EOF*), 用
   符号常量表示的代码 *更容易移植*.

   符号常量有价值的特性: *助记*, *易更改*, *可移植*

   C 语言也支持 ~const~ 关键字, 可以创建在程序运行过程中不能改变的变量. 创建的变
   量可具有文件作用域或块作用域, *宏常量可用于指定标准数组的大小和 ~const~ 变量
   的初始值*

   #+begin_src c
     #define LIMIT 20
     const int LIM = 50;

     static int data1[LIMIT]; // 有效
     static int data2[LIM]; // 无效
     const int LIM2 = 2 * LIMIT; // 有效
     const int LIM3 = 2 * LIM; // 无效
   #+end_src

   在 C 中, 非自动数组的大小应该是 *整型常量表达式*, 这意味着表示数组大小的必须
   是 *整形常量的组合*, *不包括 ~const~ 声明的值. 但是, Clang 4.6 允许此声明, 为
   了可移植性, 谨慎使用.
*** 记号
*** 记号
    从技术角度来看, 可以把 *宏的替换体看作是记号(token)型字符串*, 而不是字符型字
    符串. C 预处理器记号是宏定义的替换体中单独的 "词". 用空白把这些词分开.

    eg:
    #+begin_src c
      #define FOUR 2 * 2
    #+end_src

    该宏定义有一个记号: 2 * 2 序列. 但是, 下面的宏定义中:
    #+begin_src c
      #define SIX 2 * 3
    #+end_src
    
    有 3 个记号: ~2~, ~*~, ~3~.

    替换体中有多个空格时, 字符型字符串和记号型字符串的处理方式不同.

    eg:
    #+begin_src c
      #define EIGHT 4 * 8
    #+end_src
    
    如果预处理器把该替换体解释为字符型字符串, 将用 4 * 8 替换 ~EIGHT~.
    即: 额外的空格是替换体的一部分.

    如果预处理器把该替换体解释为记号型字符串, 则用 3 个的记号 4 * 8(分别由单个空
    格分隔) 来替换 ~EIGHT~.

    换而言之, 解释为字符型字符串, *把空格视为替换体的一部分*; 解释为记号型字符串,
    *把空格视为替换体中各记号的分隔符*. 在实际应用中, 一些 C 编译器把宏替换体视
    为字符串而不是记号. 在比这个例子更复杂的情况下, 两者的区别才有实际意义
    
    顺带一提, C 编译器处理记号的方式比预处理器复杂. 由于编译器理解 C 语言的规则,
    *所以不要求代码中用空格来分割记号*. eg: C 编译器可以把 ~2 * 2~ 直接视为 3 个记
    号, 因为它可以识别 2 是常量, * 是运算符

*** 重定义常量
    不同的实现才用不同的重定义方案, 除非新定义与就定义相同, 否则有些实现会将其视
    为错误. 另外一些实现允许重定义, 但会给出警告. ANSI 标准采用第一种方案, 只有
    新定义和就定义完全相同才允许重定义

    具有相同的定义意味着替换体中的 *记号必须相同, 且顺序也相同*.

    eg: 两个定义相同
    #+begin_src c
      #define SIX 2 * 3
      #define SIX 2 * 3
    #+end_src

    这两条定义都有 3 个相同的记号, 额外的空格不算替换体的一部分. 而下面的定义则
    与上面 2 条宏定义不同:
    
    eg: *不同*
    #+begin_src c
      #define SIX 2*3
    #+end_src

    这条宏定义中只有一个记号, 因此与前 2 条定义不同. 如果需要重定义宏, 使用
    ~#undef~ 指令

    如果确实需要重定义常量, 使用 ~const~ 关键字和作用域规则更容易些

** 在 ~#define~ 中使用参数
   在 ~#define~ 中使用参数可以创建外形和作用与函数类似的 *类函数宏*. 带有参数的
   宏看上去很像函数, 因为这样的宏也是用圆括号. 内函数宏定义的圆括号中可以有一个
   或多个参数, 随后这些参数出现在替换体中

   #+begin_src c
     #define MEAN(X, Y) (((X) + (Y)) / 2)
     //      宏 (包含: 宏参数)  替换体
   #+end_src

   eg:
   #+begin_src c
     #define SQUARE(X) X * X
   #+end_src

   用法:
   #+begin_src c
     z = SQUARE(2);
   #+end_src

   看上去像函数调用, 但是它的行为和函数调用完全不同. 

   见 ~mac_arg.c~ 用法

   代码中, ~SQUARE~ 是宏标识符, ~SQUARE(X)~ 中的 ~X~ 是宏参数, ~X * X~ 是替换列
   表, 代码中出现 ~SQUARE(X)~ 的地方都会被 ~X * X~ 替换.

   ~SQUARE(x + 2)~ 被替换为 ~x+2*x+2~, 没有括号, 所以结果为 17

   函数调用在程序运行时把参数的值传递给函数. 宏调用在 *编译之前把参数记号传递给
   程序*. 这两个不同的过程发生在不同时期.
   
   eg: 规避上述问题
   #+begin_src c
     #define SQUARE(x) (x)*(x)
   #+end_src

   并未解决如下问题:
   #+begin_src c
     100/SQUARE(2);
   #+end_src

   替换结果:
   #+begin_src c
     100/2*2
   #+end_src

   适用上述问题的解决方案之一:
   #+begin_src c
     #define SQUARE(x) (x*x)
   #+end_src

   合并解决方案:
   #+begin_src c
     #define SQUARE(x) ((x)*(x))
   #+end_src

   尽管如此, 还是无法避免如下问题:
   #+begin_src c
     SQUARE(++x);
     // 替换结果: ++x*++x=6*7 = 42
   #+end_src

   标准 *并未对这类运算规定顺序*, 所以不同编译器结果不同, 但 ~x~ 的最终值是 7

   尽量避免在宏参数中使用 *递增递减运算符*.

*** 用宏参数创建字符串: ~#~ 运算符
    一个类函数宏:
    #+begin_src c
      #define PSQR(X) printf("The square of X is %d.\n", ((X)*(X));
    #+end_src

    使用:
    #+begin_src c
      PSQR(8);
    #+end_src

    结果:
    #+begin_src text
      The squre of X is 64.
    #+end_src

    双引号的字符串中的 ~X~ 被视为 *普通文本*, 而不是一个可被替换的记号

    C 允许在字符串中包含宏参数. 在类函数宏的替换体中, ~#~ 号作为一个预处理运算符,
    可以把记号转换成字符串.

    eg: x 是一个宏形参, 那么 ~#x~ 就是转换为字符串 "x" 的形参名, 这个过程称为 
    *字符串化 (stringizing)*.

    见 ~subst.c~ 用法

    调用第一个宏时, 用 ~"y"~ 替换 ~#x~. 调用第二个宏时, 用 ~"2 + 4"~ 替换 ~#x~.

    ANSI C 字符串的串联特性将这些字符串与 ~printf()~ 语句的其他字符串组合, 生成
    最终的字符串

    第一次调用:
    #+begin_src c
      printf("The square of " "y" " is %d.\n", ((y)*(y)));
    #+end_src

    然后, 字符串串联功能将 3 个相邻的字符串组合:
    #+begin_src c
      "The squre of y is %d.\n"
    #+end_src
    
*** 预处理器黏合剂: ~##~ 运算符
    与 ~#~ 运算符类似, ~##~ 运算符可用于类函数宏的替换部分. 而且, ~##~ 还可用于
    对象宏的替换部分. ~##~ 运算符把 2 个记号组合成一个记号.

    eg:
    #+begin_src c
      #define XNAME(n) x##n
    #+end_src

    然后, 宏 ~XNAME(4)~ 将展开为 ~x4~.

    见 ~glue.c~ 用法

    *注意*: ~PRINT_XN()~ 宏用 ~#~ 运算符组合字符串, ~##~ 运算符把记号组合为一个
     新的标识符
*** 变参宏: ~...~ 和 ~__VA_ARGS__~
    一些函数(如: ~printf()~) 接受 *数量可变的参数*. ~stdvar.h~ 头文件提供了工具,
    让用户 *自定义带可变参数的函数*. C99/C11 也对宏提供了这样的工具. 虽然标准中
    未使用 "可变"(variadic) 这个词, 但是它已成为描述这种工具的通用词(虽然 C 标准
    的索引添加了字符串化(stringizing) 词条, 但是并未把固定参数的函数或宏称为固定
    函数和不变宏)

    通过把宏参数列表中最后的参数写成省略号(即: 3 个点 ~...~) 来实现这一功能. 这
    样, 预定义宏 ~__VA_ARGS__~ 可用在替换部分中, 表明省略号代表什么.

    eg: 下面的定义:
    #+begin_src c
      #define PR(...) printf(__VA_ARGS__)
    #+end_src

    假设稍后调用该宏:
    #+begin_src c
      PR("Howdy");
      PR("weight=%d, shipping=$%.2f\n", wt, sp);
    #+end_src

    对于第一次调用, ~__VA_ARGS__~ 展开为一个参数: "Howdy".

    对于第二次调用, ~__VA_ARGS__~ 展开为三个参数: "weight = %d,
    shipping=$%.2f\n", wt, sp

    因此, 展开后的代码是:
    #+begin_src c
      printf("Howdy");
      printf("weight = %d, shipping = $%.2f\n", wt, sp);
    #+end_src
    
    示例: ~variadic.c~ 使用了字符串的串联功能和 ~#~ 运算符

    第一个宏调用, X 的值是 1, 所以 ~#X~ 变成 "1", 展开后为:
    #+begin_src c
      printf("Message""1"":""x=%g\n", x);
    #+end_src

    然后串联 4 个字符
    #+begin_src c
      printf("Message 1: x=%g\n", x);
    #+end_src

    *注意*: 省略号只能代替最后的宏参数:
    错误用法:
    #+begin_src c
      #define WRONG(X, ..., Y) #X#__VA_ARGS__#y
    #+end_src
** 宏和函数的选择
   使用宏比使用普通函数复杂, *稍有不慎会产生奇怪的副作用*.
   *一些编译器规定宏指令定义成一行*

   *宏和函数的选择实际上是时间和空间的权衡*. 宏生成内嵌代码, 即在程序中生成语句.
    如果调用 20 次宏, 即在程序中插入 20 行代码. 如果调用函数 20 次, 程序中只有一
    份函数语句的副本, 所以节省了空间. 然而另一方面, 程序的控制必须 *跳转* 至函数
    内, 随后再返回主调程序, 这显然比内联代码花费更多的时间

    宏的一个优点是, 不用担心变量类型(这是因为 *宏处理的是字符串*, 而不是实际的值).
    因此, 只要能用 ~int~ 或 ~float~ 类型都可以使用 ~SQUARE(x)~ 宏

    C99 提供了内联函数. 后面介绍

    简单的函数, 通常使用宏: 
    #+begin_src c
      #define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
      #define ABS(X) ((X) < 0 ? -(X) : (X))
      #define ISSIGN(X) ((X) == '+' || (X) == '0' ? 1 : 0)
    #+end_src

    *使用时注意*:
    1. 宏名中 *不允许有空格*, 但是在替换字符串中可以有空格. ANSI C 允许在参数列
       表中使用空格
    2. 用圆括号把宏的参数和整个替换体括起来. 这样能确保被括起来的部分在表达式中
       正确展开
       #+begin_src c
         forks = 2 * MAX(guests + 3, last);
       #+end_src
    3. 用大写字母表示宏函数的名称. 可以提醒程序员注意产生的副作用
    4. 如果打算用来加快程序的运行速度, 那么首先要确定使用宏和使用函数是否会导致
       较大差异. 在程序中 *只使用一次的宏无法明显减少程序的运行时间*. 在嵌套循环
       中还是用宏更有助于提高效率. 许多系统提供程序分析器以帮助程序员压缩程序中
       最耗时的部分
       
    假设开发了一些方便的宏函数, 使用 ~#include~ 指令可以复用该宏
** 文件包含: ~#include~
   当预处理器发现 ~#include~ 指令时, 会查看后面的文件名并把文件的内容包含到当前
   文件中, 即替换源文件中的 ~#include~ 指令. 这相当于把被包含文件的全部内容输入
   到源文件 ~#include~ 指令所在的位置. ~#include~ 指令有 2 种形式
   
   #+begin_src c
     #include <stdio.h> // 文件名在尖括号中
     #include "mystuff.h" // 文件名在双引号中
   #+end_src

   在 UNIX 系统中, 尖括号告诉预处理器 *在标准系统目录中* 查找该文件. 双引号告诉
   预处理器 *首先在当前目录中* (或文件名中指定的其他目录) 查找该文件, 如果未找到
   再查找标准系统目录

   #+begin_src c
     #include <stdio.h> // 查找系统目录
     #include "hot.h" // 查找当前工作目录
     #include "/usr/biff/p.h" // 查找 /usr/biff目录
   #+end_src

   集成开发环境(IDE) 也有标准路径或系统头文件的路径. 许多集成开发环境提供菜单选
   项, 指定用尖括号时查找路径. 在 UNIX 中, 使用双引号意味着先查找本地目录, 但是
   具体查找哪个目录取决于编译器的设定. 有些编译器会搜索源代码文件所在的目录, 有
   些编译器则 搜索当前的工作目录, 还有些搜索项目文件所在的目录.

   ANSI C *不为文件系统提供统一的目录模型*, 因为不同的计算机所用的系统不同. 一般
   而言, 明明文件的方法因系统而异, 但是尖括号和双引号的规则与系统无关.

   包含文件的目的: 编译器需要这些文件中的信息. 
   eg: ~stdio.h~ 文件中通常包含 ~EOF~, ~NULL~, ~getchar()~ 和 ~putchar()~ 的定
   义. ~getchar()~ 和 ~putchar()~ 被定义为宏函数. 此外, 该文件中还包含 C 的其他
   I/O 函数

   C 语言习惯用 *.h 后缀表示头文件*, 这些文件包含需要放在程序 *顶部* 的信息. 头
   文件经常包含一些预处理器指令. 有些头文件(eg: ~stdio.h~) 由系统提供, 也可以自
   己创建.
   
   包含一个大型头文件不一定显著增加程序的大小. 在大部分情况下, 头文件的内容是编
   译器生成最终代码时所需的信息, 而不是添加到最终代码中的材料

*** 头文件示例
    假设开发了一个存放人名的结构, 还编写了一些使用该结构的函数. 可以把不同的什么
    放在头文件中, ~names_st.h~ 头文件演示了该例子

    该头文件包含了一些头文件中常见的内容: ~#define~ 指令, 结构声明, ~typedef~ 和
    函数原型.

    *注意*: 这些内容是编译器在 *创建可执行时所需的信息, 而不是可执行代码*. 为安
     全起见, 通常, 应该用 ~#ifndef~ 和 ~#define~ 防止多重包含头文件.

     可执行代码通常在源文件代码中, 而不是在头文件中. 例如, ~names_st.c~ 中有头文
     件中函数原型的定义. 该程序包含了 ~names_st.h~ 头文件, 所以编译器知道
     ~names~ 类型

     ~get_names()~ 函数通过 ~s_gets()~ 函数调用了 ~fgets()~ 函数, 避免了目标数组
     溢出. ~useheader.c~ 使用了头文件与源文件

     *注意*: 两个源代码文件都是用 ~names_st~ 类型结构, 所以都必须包含
      ~names_st.h~ 头文件

      必须编译和链接 ~names_st.c~ 和 ~useheader.c~ 源代码文件

      声明和指令放在 ~names_st.h~ 头文件中, 函数定义放在 ~names_st.c~ 源代码文件
      中
*** 使用头文件
    浏览任何一个标准头文件都可以了解头文件的基本信息. 
    头文件中最常用的形式如下:

    - 明示常量: eg: ~stdio.h~ 中定义的 ~EOF~, ~NULL~ 和 ~BUFSIZE(标准 I/O 缓冲区
      大小)~
    - 宏函数: eg: ~getc(stdin)~ 通常用 ~getchar()~ 定义, 而 ~getc()~ 经常用于定
      义较复杂的宏, 头文件 ~ctype.h~ 通常包含 ~ctype~ 系列函数的宏定义.
    - 函数声明: eg: ~string.h~ 头文件(一些旧系统中是 ~strings.h~) 包含字符串函数
      系列的函数声明. 在 ANSI C 和后面的标准中, 函数声明都是函数原型形式.
    - 结构模板定义: 标准 I/O 函数使用 ~FILE~ 结构, 该结构中包含了文件和文件缓冲
      区相关的信息. ~FILE~ 结构在头文件 ~stdio.h~ 中
    - 类型定义: 标准 I/O 函数使用指向 ~FILE~ 的指针作为参数. 通常, ~stdio.h~ 用
      ~#define~ 或 ~typedef~ 把 ~FILE~ 定义为指向结构的指针. 类似地, ~size_t~ 和
      ~time_t~ 类型也定义在在头文件中

      
    如果开发一系列相关的函数或结构, 使用自己开发的标准头文件特别有价值.

    还可以使用头文件声明外部变量供其他文件共享. eg: 已经开发了共享某个变量的一系
    列函数, 该变量报告某种状况(eg: 错误情况), 这种方法就很有效. 该情况下, 可以在
    包含函数声明的源代码文件定义一个文件作用域的外部链接变量:

    #+begin_src c
      int status = 0; // 该变量具有文件作用域, 在源代码文件
    #+end_src

    然后, 可以在与源代码文件相关联的头文件中进行引用式声明:
    #+begin_src c
      extern int status; // 在头文件中
    #+end_src

    这行代码会出现在包含了该头文件的文件中, 这样使用该系列函数的文件都能使用这个
    变量. 
    虽然源代码文件中包含该头文件后也包含了该声明. 但是 *只要声明的类型一致*, 在
    一个文件中同时使用定义式声明和引用式声明没问题.

    需要包含头文件的另一种情况是: 使用具有文件作用域, 内部链接和 ~const~ 限定符
    的变量或数组. ~const~ 防止值被意外修改, ~static~  意味着每个包含该头文件的文
    件都获得一份副本. 因此, 不需要在一个文件中进行定义式声明, 在其他文件中引用式
    声明.

    ~#include~ 和 ~#define~ 指令是最常用的 2 个 C 预处理器特性
** 其他指令
   程序员可能要为不同的话工作环境准备 C 程序和 C 库包. 不同的环境可能使用不同的
   代码类型. 预处理器提供一些指令, 程序员通过修改 ~#define~ 的值即可生成可移植的
   代码. ~#undef~ 指令取消之前的 ~#define~ 定义, ~#if~, ~#ifdef~, ~#ifndef~,
   ~#else~, ~#elif~ 和 ~#endif~ 指令用于指定什么情况下编写哪些代码. ~#line~ 指令
   用于重置行和文件信息, ~#error~ 指令用于给出错误消息, ~#pragma~ 指令用于向编译
   器发出指令.

*** ~#undef~ 指令
    该指令用于 "取消" 已定义的 ~#define~ 指令.

    eg: 假设有如下定义:
    #+begin_src c
      #define LIMIT 400
    #+end_src

    下面的指令将移除上面的定义
    #+begin_src c
      #undef LIMIT
    #+end_src

    这样, 现在就可以把 ~LIMIT~ 重新定义为一个新值. 
    即使原来没有定义 ~LIMIT~, *取消 ~LIMIT~ 的定义仍然有效*. 

    如果想使用一个名称, 又不确定之前是否已经用过, 为安全起见, 可以用 ~#undef~ 指
    令取消该名字的定义

*** 从 C 预处理角度看已定义
    处理器在识别标识符时, 遵循与 C 相同的规则: 标识符可以由大写字母, 小写字母,
    数字和下划线字符组成, 且首字符不能是数字. 当预处理器在预处理器指令中发现一个
    标识符时, 它会把该标识符当做已定义的或未定义的. 这里的已定义表示由预处理器定
    义. 如果标识符是同一个文件中由前面的 ~#define~ 指令创建的宏名, 而且没有
    ~#undef~ 指令关闭, 那么该标识符是已定义的. 如果标识符不是宏, 假设是一个文件
    作用域的 C 变量, 那么该标识符对预处理器而言就是未定义的

    已定义宏可以是对象宏, 包括空宏或类函数宏

    #+begin_src c
      #define LIMIT 1000 // LIMIT 是已定义的
      #define GOOD // GOOD 是已定义的
      #define A(X) ((-(X))*(X)) // A 是已定义的
      int q; // q 不是宏, 因此是未定义的
      #undef GOOD // GOOD 取消定义, 是未定义的
    #+end_src

    *注意*: ~#define~ 宏的作用域从它在文件中的声明处开始, 直到用 ~#undef~ 指令取
    消宏位置, 或延伸至文件尾 (以二者中想满足的条件作为宏作用域的结束). 另外还要
    注意, 如果宏通过头文件引入, 那么 ~#define~ 在文件中的位置取决于 ~#include~
    指令的位置

    稍后将介绍几个预定义宏: eg: ~__DATE__~ 和 ~__FILE__~. 这些宏一定是已定义的, 
    *而且不能取消定义*
*** 条件编译
    可以使用其他指令创建 *条件编译(conditinal compilation)*. 也就是是说, 可以使
    用这些指令告诉编译器 *根据编译时的条件执行或忽略信息(或代码)块*

**** ~#ifdef~, ~#else~ 和 ~#endif~ 指令
     可以用一个简短的示例来演示条件编译的情况. 考虑下面的代码:
     #+begin_src c
       #ifdef MAVIS
       #include "horse.h" // 如果已经用 #define 定义了 MAVIS, 则执行下面的指令
       #define STABLES 5
       #else
       #include "cow.h" // 如果没有用 #define 定义 MAVIS, 则执行下面的指令
       #define STABLES 15
       #endif
     #+end_src

     这里使用的较新的编译器和 ANSI 标注支持的缩进格式. 如果使用旧的编译器, 必须
     左对齐所有的指令或至少左对齐 ~#~ 号, 如下所示:

     #+begin_src c
       #ifdef MAVIS
       #include "horse.h" // 如果已经用 #define 定义了 MAVIS, 则执行下面的指令
       #define STABLES 5
       #else
       #include "cow.h" // 如果没有用 #define 定义 MAVIS, 则执行下面的指令
       #define STABLES 15
       #endif
     #+end_src

     ~#ifdef~ 指令说明, 如果预处理器已定义了后面的标识符(~MAVIS~), 则执行
     ~#else~ 或 ~#endif~ 指令之前的所有指令并编译所有 C 代码(先出现哪个指令就执
     行到哪里). 如果预处理器未定义 ~MAVIS~, 且有 ~#else~ 指令, 则执行 ~#else~ 和
     ~#endif~ 指令之间的所有代码

     ~#ifdef~ ~#else~ 很像 C 的 if else. 两者的主要区别是: 预处理器不识别用于标
     记的花括号 ({}), 因此它使用 ~#else(如果需要)~ 和 ~#endif(必须存在)~ 来标记
     指令块, 这些指令结构可以嵌套. 也可以用这些指令标记 C 语句块, 如 ~ifdef.c~

     如果省略 ~JUST_CHECKING~ 定义(注释或者使用 ~#undef~ 指令取消它的定义) 并重
     新编译该程序, 只会输出最后一行. 可以用这种方法调试程序.

     定义 ~JUST_CHECING~ 并合理使用 ~#ifdef~, 编译器将执行用于调试的程序代码, 打
     印中间值. 调试结束后, 可移除 ~JUST_CHECKING~ 定义并重新编译. 如果以后还需要
     使用这些信息, 重新插入定义即可. 这样做生蛆了再次输入额外打印语句的麻烦.
     ~#ifdef~ 还可用于根据不同的 C 实现选择合适的代码块

**** ~#ifndef~ 指令
     与 ~#ifdef~ 指令的用法类似, 也可以和 ~#else~, ~#endif~ 一起使用, 但是它们的
     逻辑相反. ~#ifndef~ 指令判断后面的标识符是否是未定义的, 常用语定义之前未定
     义的变量

     eg:
     #+begin_src c
       #ifndef SIZE
       #define SIZE 100
       #endif
     #+end_src

     (旧的实现可能不允许使用缩进的 ~#define~)

     通常, 包含多个头文件时, 其中的文件可能包含了相同宏定义. ~#ifndef~ 指令可以
     防止相同的宏被重复定义. 在首次定义一个宏的头文件中使用 ~#ifndef~ 指令激活定
     义, 随后在其他头文件中的定义都被忽略
     
     ~#ifndef~ 指令还有另一种用法. 假设有上面的 ~arrays.h~ 头文件, 然后把下面的
     一行代码放入一个头文件中:
     #+begin_src c
       #incldue "arrarys.h"
     #+end_src

     ~SIZE~ 被定义为 100, 但是, 如果把下面的代码放入该头文件:
     #+begin_src c
       #define SIZE 10
       #include "arrays.h"
     #+end_src

     ~SIZE~ 则被设置为 10. 这里, 当之前到 ~#include "arrays.h"~ 这行, 处理
     ~arrays.h~ 中的代码时, 由于 ~SIZE~ 是已定义的, 所以 *跳过* 了 ~#define SIZE
     100~ 这行代码. 鉴于此, 可以利用这种方法, 用一个较小的数组测试程序. 测试完毕
     后, 移除 ~#define SIZE 10~ 并重新编译. 这样, 就不用修改头文件数组本身了

     ~#ifndef~ 指令通常用于防止多次包含一个文件. 
     eg:
     #+begin_src c
       #ifndef THINGS_H_
       #define THINGS_H_
       #endif
     #+end_src

     因为许多被包含的文件中都包含着其他文件, 所以显式包含的文件中可能包含着已经
     包含的其他文件.
     问题: 在被包含的文件中有某些项只能在一个文件中出现一次.
     问题: 如何确保待测试的标识符没有在别处定义. 通常, 实现的供应商使用这些方法
     解决这个问题: 用文件名作为标识符, 使用大写字母, 用下划线字符代替文件名中的
     点字符, 用下划线字符做前缀或后缀(可能使用双下划线).

     eg: 查看 ~stdio.h~ 头文件, 类似代码:
     #+begin_src c
       #ifndef _STDIO_H
       #define _STDIO_H
       // ...
       #endif
     #+end_src

     由于变准保留使用下划线作为前缀, 尽量避免冲突

     ~names.h~ 与 ~doubincl.c~ 程序演示了避免重复包含
**** ~#if~ 和 ~#elif~ 指令
     ~#if~ 指令很像 C 语言中的 ~if~. ~#if~ 后面跟整形常量表达式为非零, 则表达式
     为真. 可以在指令中使用 C 的关系运算符和逻辑运算符:
     #+begin_src c
       #if SYS == 1
       #indlude "ibm.h"
       #endif
     #+end_src

     可以按照 if else 的形式使用 ~#elif(早期的实现不支持#elif)~.
     eg:
     #+begin_src c
       #if SYS == 1
       #include "ibmpc.h"
       #elif SYS == 2
       #include "mac.h"
       #else
       #include "general.h"
       #endif
     #+end_src

     较新的编译器提供另一种方法测试名称是否已定义, 即用 ~#if defined(VAX)~ 代替
     ~#ifdef VAX~

     这里, ~defined~ 是一个预处理运算符, 如果它的从桉树是用 ~#defined~ 定义过,
     则返回 1; 否则返回 0. 这种新方法的有点是: 它可以和 ~#elif~ 一起使用, 下面用
     这种形式重写前面的示例:
     #+begin_src c
       #if defined(IBMPC)
       #include "ibmpc.h"
       #elif defined(MAX)
       #include "vax.h"
       #elif defined(MAC)
       #include "mac.h"
       #else
       #include "general.h"
       #endif
     #+end_src

     如果在 ~VAX~ 机上运行这几行代码, names 应该在文件前面用下面的代码定义 ~VAX~
     #+begin_src c
       #define VAX
     #+end_src
     
     条件编译还有一个用途是让程序更容易移植. 改变文件开头部分的几个关键的定义,
     即可根据不同的系统设置不同的值和包含不同的文件

*** 预定义宏
    C 标准规定了一些预定义宏
    | 宏               | 含义                                                            |
    |------------------+-----------------------------------------------------------------|
    | __DATE__         | 预处理的日期("Mmm dd yyyy" 形式的字符串字面量, 如: Nov 23 2013) |
    | __FILE__         | 表示当前源代码文件名的字符串字面量                              |
    | __LINE__         | 表示当前源代码文件中行号的整型常量                              |
    | __STDC__         | 设置为 1 时, 表明实现遵循 C 标准                                |
    | __STDC_VERSION__ | 支持 C99 标准, 设置为 19901L; 支持 C11 标准, 设置为 201112L     |
    | __TIME__         | 翻译代码的时间, 格式为: "hh:mm:ss"                              |

    C99 标准提供一个名为 ~__func__~ 的预定义标识符, 它展开为一个代表函数名的字符
    串(该函数包含该标识符). 那么, ~__func__~ 必须具有函数作用域, 而从本质上看宏
    具有文件作用域. 因此, ~__func__~ 是 C 语言的 *预定义标识符*, 而不是预定义宏

    ~predef.c~ 中使用一些预定义宏和预定义标识符. *注意*: 其中一些是 C99 新增的,
    所以不支持 C99 的编译器可能无法识别它们. 如果使用 GCC, 必须设置 ~-std=c99~
    或 ~-std=c11~
    
*** ~#line~ 和 ~#error~
    ~#line~ 指令重置 ~__LINE__~ 和 ~__FILE__~ 宏报告的行号和文件名. 可以这样使用
    ~#line~:
    #+begin_src c
      #line 1000 // 把当前行号重置为 1000
      #line 10 "cool.c" // 把行号重置为 10, 把文件名重置为 cool.c
    #+end_src

    ~#error~ 指令让预处理器发出一条错误消息, 该消息包含指令中的文本. 如果可能的
    话, *编译过程应该中断*.
    eg:
    #+begin_src c
      #if __STDC_VERSION__ != 201112L
      #error Not C11
      #endif
    #+end_src

    使用 ~gcc~ 编译以上代码生成后(见 ~newish.c~), 输出如下:
    #+begin_src bash
      gcc newish.c
      # clang
      clang -std=c89 .\newish.c
    #+end_src

    #+begin_src text
      newish.c:2:2: #error Not C11
    #+end_src

    使用 C11:
    #+begin_src bash
      gcc -std=c11 newish.c
      # 或
      clang -std=c11 newish.c
    #+end_src
    
    如果编译器不支持 C11, 失败. 支持则成功
*** ~#pragma~
    在现在的编译器中, 可以通过命令行参数或 IDE 菜单修改编译器的一些设置.

    ~#pragma~ 把编译器指令放入源代码中.

    eg: 在开发 C99 时, 标准被称为 C9X, 可以使用下面的编译指示(pragma) 让编译器支
    持 C9X:
    #+begin_src c
      #pragma c9x on
    #+end_src

    一般而言, 编译器都有自己的编译指示集.
    eg: 编译提示可能用于控制分配给自动变量的内存量, 或者设置错误检查的严格程度,
    或者启用非标准语言特性等. C99 标准提供了 3 个标准编译指示, 但是超出了当前讨
    论范围.

    C99 还提供 ~_Pragma~ 预处理器运算符, 该运算符把字符串转换成普通的编译指示.
    eg:
    #+begin_src c
      _Pragma("nonstandardtreatmenttypeB on")
    #+end_src

    等价于下面的指令
    #+begin_src c
      #pragma nonstandardtreatmenttypeB on
    #+end_src

    由于该运算符不使用 # 符号, 所以可以把它作为宏展开的一部分:
    #+begin_src c
      #define PRAGMA(X) _Pragma(#X)
      #define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)
    #+end_src

    然后, 可以使用类似下面的代码:
    #+begin_src c
      LIMRG(ON)
    #+end_src

    以下定义看上去没问题, 但是 *无法运行*
    #+begin_src c
      #define LIMRG(X) _Pragma(STDC CX_LIMITED_RANGE #X)
    #+end_src

    问题在于这行代码依赖字符串的串联功能, 而 *预处理器过程完成之后才会串联字符
    串*
    
    ~_Pragma~ 运算符完成 "解字符串"(destringizing) 的工作.
    即把字符串中的转移序列转换成它所代表的字符. 因此:
    #+begin_src c
      _Pragma("use_bool\"true\"false")
    #+end_src
    变成了
    #+begin_src c
      #pragma use_bool "true "false
    #+end_src
*** 泛型选择(C11)
    在程序设计中, 泛型变成(generic programming) 指那些没有特定类型, 但是一旦指定
    一种类型, 就可以转换成指定类型的代码.
    eg: C++ 在模板中可以创建泛型算法, 然后编译器根据指定的类型自动使用实例化代码.
    C 没有这个功能. raner, C11 新增了 *泛型选择表达式(generaic selection
    expression)*, 可根据表达式的类型(即表达式的类型是  ~int~, ~double~ 还是其他
    类型) 选择一个值. 泛型选择表达式不是预处理器指令, 但是在一些泛型编程中它常用
    作 ~#define~ 宏定义的一部分.

    eg: 泛型选择表达式:
    #+begin_src c
      _Generic(x, int: 0, float: 1, double: 2, default: 3)
    #+end_src

    ~_Generic~ 是 C11 的关键字. ~_Generic~ 后面的圆括号中包含多个用逗号分隔的项.
    第一个项是表达式, 后面的每个项都由一个类型, 一个冒号和一个值组成.(eg:
    ~float: 1~). 第一个项的类型匹配哪个表情, 整个表达式的值是该标签后面的值.
    eg: 上面表达式中 ~x~ 是 ~int~ 类型的变量, ~x~ 的类型匹配 ~int:~ 表情, names
    整个表达式的值就是 0. 如果没有与类型匹配的表情, 表达式的值就是 ~default:~ 标
    签后面的值. 泛型选择语句与 ~switch~ 语句类似, 只是前者用表达式的类型匹配标签,
    而后者用表达式的值匹配标签.

    eg: 把泛型选择语句和宏定义组合:
    #+begin_src c
      #define MYTYPE(X) _Generic((X),\
          int: "int",\
          float: "float",\
          double: "double",\
          default: "other"\
                                 )
    #+end_src

    宏必须定义为一条逻辑行, 但是可以用 ~\~ 把一条逻辑行分隔成多条物理行. 在这种
    情况下, 对泛型选择表达式求值得字符串. 
    eg: 对 ~MYTYPE(5)~ 求值得 "int", 因为值 5 的类型与 ~int:~ 标签匹配.
    ~mytype.c~ 演示了用法
    
    ~MYTYPE()~ 最后 2 个示例所用的类型与标签不匹配, 所以打印 ~default~ 对应的字
    符串. 可以使用更多类型标签来扩展宏的能力, 但是该程序主要是为了演示基本工作原
    理

    对一个泛型选择表达式求值时, 程序不会相对第一个项求值, 它只确定类型. 只有匹配
    标签的类型后才会对表达式求值.

    可以像使用独立类型("泛型") 函数那样使用 ~_Generic~ 定义宏. 后续 ~math~ 库介
    绍会给出一个示例
** 内联函数(C99)
    通常, 函数调用都有一定的开销, 因为函数的调用过程包括建立调用, 传递函数,跳转
    到函数代码并返回. 使用宏使代码内联, 可以避免这样的开销.

    C99 还提供另一种方法: *内联函数(inline function)*. 
    "把函数变成内联函数建议尽可能快地调用该函数, 其具体效果由实现定义". 
    因此, 把函数变成内联函数, 编译器可能会用内联代码替换函数调用, 并(或) 执行一
    些其他的优化, 但是也可能不起作用

    创建内联函数的定义有多种方法. 标准规定 *具有内部链接的函数可以成为内联函数*,
    还规定了 *内联函数的定义与调用该函数的代码必须在同一个文件中*.

    因此, 最简单的方法是使用函数说明符 ~inline~ 和存储类别说明符 ~static~. 
    通常, 内联函数应定义在首次使用它的文件中, 所以内联函数也相当于函数原型.
     
    eg:
    #+begin_src c
      #include <stdio.h>

      inline static void eatline() // 内联函数定义/原型
      {
        while (getchar() != '\n') {
          continue;
        }
      }

      int main()
      {
        // ...
        eatline(); // 函数调用
  
      }
    #+end_src

    编译器查看内联函数的定义(也是原型), 可能会用函数体中的代码替换 ~eatline()~
    函数调用. 也就是说, 效果相当于在函数调用的位置输入函数体中的代码

    #+begin_src c
      #include <stdio.h>
      inline static void eatline() // 内联函数定义/原型
      {
        while (getchar() != '\n') {
          continue;
        }
      }

      int main(int argc, char *argv[])
      {
        while (getchar() != '\n') { // 替换函数调用
          continue;
        }
        return 0;
      }
    #+end_src

    *由于并未给内联函数预留单独的代码块*, 所以 *无法获得内联函数的地址*
    (实际上可以获取地址, 不过这样做之后, 编译器会生成一个非内联函数). 另外, 内
    联函数无法在调试器中显示
     
    内联函数应该比较短小. 把较长的函数变成内联并未节约多少时间, 因为执行函数体
    的时间比调用函数的时间长的多

    编译器优化内联函数必须知道该函数体定义的内容. 这意味着内联函数定义与函数调
    用必须在同一个文件中. 鉴于此, 一般情况下内联函数都具有内部链接. 因此, 如果
    程序有多个文件都要使用某个内联函数, 那么这些文件中都 *必须包含该内联函数的
    定义*. 最简单的方法是, 把内联函数定义放入头文件, 并在使用该内联函数的文件中
    包含该头文件即可.

    一般不在头文件中放置可执行代码, 内联函数是个特例. 因为内联函数具有内部链接,
    所以在多个文件中定义同一个内联函数不会产生什么问题.

    与 C++ 不同的是, C 还允许 *混合使用内联函数定义和外部函数定义(具有外部链接
    的定义)*.

    eg: 一个程序中使用下面 3 个文件
     
    eg: file1.c
    #+begin_src c
      inline static double square(double);

      int main()
      {
        double q = square(1.3);
      }
    #+end_src
     

    eg: file2.c
    #+begin_src c
      double square(double x) {
        return (int) (x*x);
      }

      void spam(double v)
      {
        double kv = square(v);
      }
    #+end_src

    eg: file3.c
    #+begin_src c
      inline double square(double x) {
        return (int) (x * x + 0.5);
      }

      void masp(double w)
      {
        double kw = square(w);
      }
    #+end_src

    3 个文件中都定义了 ~square()~ 函数. ~file1.c~ 文件中是 ~inline static~ 定
    义; ~file2.c~ 文件中是普通的函数定义(因此具有外部链接); ~file3.c~ 文件中是
    ~inline~ 定义, 省略了 ~static~

    3 个文件中的函数都调用了 ~square~ 函数, ~file1.c~ 文件中的 ~main()~ 使用
    ~square()~ 的局部 ~static~ 定义. 由于该定义也是 ~inline~ 定义, 所以编译器有
    可能优化代码, 也许会内联该函数, 该定义具有外部链接, 其他文件也可见.
    ~file3.c~ 文件中, 编译器既可以使用该文件中 ~square()~ 函数的内联定义, 也可
    以使用 ~file2.c~ 文件中的外部链接定义. 如果像 ~file3.c~ 那样, 省略
    ~file1.c~ 文件 ~inline~ 定义中的 ~static~, 那么该 ~inline~ 定义被视为可替换
    的外部定义

    *注意*: GCC 在 C99 之前就使用了一些不同的规则实现了内联函数, 所以 GCC 可以
    根据当前编译器的标记来解释 ~inline~
** ~_Noreturn~ 函数(C11)
   C99 新增 ~inline~ 关键字时, 它是唯一的函数说明符(关键字 ~extern~ 和 ~static~
   是存储类别说明符, 可应用于数据对象和函数). C11 新增了第二个函数说明符
   ~_Noreturn~, 表明调用完成后函数 *不返回主调函数*. ~exit()~ 函数是 ~_Noreturn~
   函数的一个示例, 一旦调用 ~exit()~, 它不会再返回主调函数.

   *注意*: 这与 ~void~ 返回值不同. ~void~ 类型的函数在执行完毕后返回主调函数, 只
   是它不提供返回值

   ~Noreturn~ 的目的是告诉用户和编译器, 这个特殊的函数不会把控制返回主调程序. 告
   诉用户以避免滥用该函数, 通知编译器可优化一些代码 
** C 库
   最初, 并没有官方的 C 库. 后来, 基于 UNIX 的 C 实现成为了标准. ANSI C 委员会主
   要以这个标准为基础, 开发了一个官方的标准库. 在意识到 C 语言的应用范围不断扩大
   后, 该委员会重新定义了这个库, 使之可以应用于其他系统.

*** 访问 C 库
    如何访问 C 库取决于实现, 因此要了解当前系统的一般情况. 首先, 可以在多个不同
    的位置找到库函数.

    eg: ~getchar()~ 函数通常作为宏定义在 ~stdio.h~ 头文件中, 而 ~strlen()~ 通常
    在库文件中. 其次, 不同的系统搜索这些函数的方法不同.

    3 种可能的方法:

    1. 自动访问
       在一些系统中, 只需编译程序, 就可以使用一些常用的库函数

       *注意*: 在使用函数之前必须先声明函数的类型, 通过包含合适的头文件即可完成.
       在描述库函数的用户手册中, 会指出使用某函数时应该包含哪个头文件. 但是在一
       些就系统上, 可能必须自己输入函数声明. 

       *用户手册指明了函数类型*

       过去, 不同的实现使用的头文件名不同. ANSI C 标准把库函数氛围多个系列, 每个
       系列的函数原型都放在一个特定的头文件中.

    2. 文件包含
       如果函数被定义为宏, 那么可以通过 ~#include~ 指令包含定义宏函数的文件. 通
       常, 类似的宏都放在合适名称的头文件中.

       eg: 许多系统(包括所有的 ANSI C 系统)都有 ~ctype.h~ 文件, 该文件中包含了一
       些确定字符性质(eg: 大写, 数字等)的宏

    3. 库包含
       在编译或链接程序的某些阶段, 可能需要指定库选项. 即使在自动检查标准库的系
       统中, 也会有不常用的函数库. 必须通过编译时选项显式指定这些库.

       *注意*: 这个过程与包含头文件不同. 头文件提供函数声明或原型, 而库选项告诉
       系统到哪里查找函数代码. 

*** 使用库描述
    可以在多个地方找到 *函数文档*. 系统可能有在线手册, 集成开发环境通常都有在线
    帮助. C 实现的供应商可能提供描述库函数的纸质版用户手册, 或者把这些材料放在
    ~CD-ROM~ 中或网上. 有些出版社也出版 C 库函数的参考手册. 这些材料中, 有些是一
    般材料, 有些这是针对特定实现的.

    阅读文档的关键是看懂函数头. 许多内容随时间变化而变化.
    旧的 UNIX 文档:
    #+begin_src c
      #include <stdio.h>
      fread(ptr, sizeof(*ptr), nitems, stream);

      FILE* stream;
    #+end_src

    首先, 给出了应该包含的文件, 但是没有给出 ~fread()~, ~ptr~, ~sizeof(*ptr)~ 或
    ~nitems~ 的类型. 过去, 默认类型都是 ~int~, 但是从描述中可以看出 ~ptr~ 是一个
    指针(在早期的 C 中, 指针被作为整数处理). 参数 ~stream~ 声明为指向 ~FILE~ 的
    指针. 上面的函数声明中的第 2 个参数看上去像是 ~sizeof~ 运算符, 而实际上这个
    参数的值应该是 ~ptr~ 所指向对象的大小. 虽然用 ~sizeof~ 作为参数没什么问题,
    但是用 ~int~ 类型的值作为参数更符合语法.

    后来修改后的描述:
    #+begin_src c
      #include <stdio.h>

      int fread(ptr, size, nitems, stream);

      char* ptr;
      int size, nitems;
      FILE* stream;
    #+end_src

    现在, 所有的类型都显式说明, ~ptr~ 作为指向 ~char~ 的指针.

    ANSI C90 标准提供了下面的描述:
    #+begin_src c
      #include <stdio.h>
      size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);
    #+end_src

    首先, 使用了新的函数原型格式. 其次, 改变了一些类型. ~size_t~ 类型被定义为
    ~sizeof~ 运算符返回值类型 -- 无符号整数类型, 通常是 ~unsigned int~ 或
    ~unsigned long~. ~stddef.h~ 文件中包含了 ~size_t~ 类型的 ~typedef~ 或
    ~#define~ 定义. 其他文件(包括 ~stdio.h~) 通过包含 ~stddef.h~ 来包含这个定义.
    许多函数 (包括 ~fread()~) 的实际参数中都要使用 ~sizeof~ 运算符, 形式参数的
    ~size_t~ 类型中正好匹配这种常见的情况.

    另外, ANSI C 把指向 void 的指针作为一种通用指针, 用于指针指向不同类型的情况.
    eg: ~fread()~ 的第一个参数可能是指向一个 ~double~ 类型是做的指针, 也可能是指
    向其他类型结构的指针. 如果假设实际参数是一个指向内含 20 个 ~double~ 类型元素
    数组的指针, 且形式参数都是指向 ~void~ 的指针, 那么编译器会选用合适的类型, 不
    会出现类型冲突的问题

    C99/C11 标准在以上的描述中加入了新的关键字 ~restric~:
    #+begin_src c
      #include <stdio.h>

      size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);
    #+end_src
   
** 数学库
   数学库数学库中包含许多有用的数学函数. ~math.h~ 头文件提供这些函数的原型.

   下表列出一些声明在 ~math.h~ 中的函数. 
   *注意*: 函数中设计的角度都以弧度为单位(1 弧度=180/π=57.296 度).
   参考资料 5 "新增 C99 和 C11 标准的 ANSI C 库" 列出了 C99 和 C11 标准的所有函
   数

   | 原型                             | 描述                                   |
   |----------------------------------+----------------------------------------|
   | double acos(double x)            | 返回余弦值为 x 的角度(0 ~ π 弧度)      |
   | double asin(double x)            | 返回正弦值为 x 的角度(-π/2 ~ π/2 弧度) |
   | double atan(double x)            | 返回正切值为 x 的角度(-π/2 ~ π/2 弧度) |
   | double atan2(double y, double x) | 返回正切值为 y/x 的角度(-π ~ π 弧度)   |
   | double cos(double x)             | 返回 x 的余弦值, x 的单位为弧度        |
   | double sin(double x)             | 返回 x 的正弦值, x 的单位为弧度        |
   | double tan(double x)             | 返回 x 的正切值, x 的单位为弧度        |
   | double exp(double x)             | 返回 x 的指数函数的值(e^x)             |
   | double log(double x)             | 返回 x 的自然对数值                    |
   | double log10(double x)           | 返回 x 以 10 为底的对数值              |
   | double pow(double x, double y)   | 返回 x 的 y 次幂                       |
   | double sqrt(double x)            | 返回 x 的平方值                        |
   | double cbrt(double x)            | 返回 x 的立方值                        |
   | double ceil(double x)            | 返回不小于 x 的最小整数值              |
   | double fabs(double x)            | 返回 x 的绝对值                        |
   | double floort(double x)          | 返回不大于 x 的最大整数值              |

   
*** 三角问题
    可以用数学库解决一些常见问题: 把 x/y 坐标转换为长度和角度.
    eg: 在网格上画了一条线, 该线条水平穿过了 4 个单元(x 的值), 垂直穿过了 3 个单
    元(y 的值). 那么, 该线的长度(量)和方向是:
    #+begin_example
      大小 = square root(x^2 + y^2)

      角度 = arctan(y / x)
    #+end_example

    数学库提供平方根函数和一对反正切函数, 所以可以用 C 程序表示这个问题.
    平方根函数是 ~sqrt()~, 接受一个 ~double~ 类型的参数, 并返回参数的平方根, 也
    是 ~double~ 类型.

    ~atan()~ 函数接受一个 ~double~ 类型的参数(即正切值), 并返回一个角度(该角度的
    正切值就是参数值). 但是, 当线的 x 值和 y 值均为 -5 时, ~atan()~ 函数产生混乱.
    因为 (-5)/(-5) 得 1, 所以 ~atan()~ 返回 45°, 该值与 x 和 y 均为 5 时的返回值
    相同. 也就是说, ~atan()~ 无法区分角度相同但方向相反的线(实际上, ~atan()~ 返
    回值的单位是弧度而不是度)

    C 库还提供了 ~atan2()~ 函数. 它接受 2 个参数: x 的值和 y 的值. 这样, 通过检
    查 x 和 y 的正负号就可以得出正确的角度值. ~atan2()~ 和 ~atan()~ 均返回弧度值.
    把弧度转换为度, 只需将弧度值 * 180, 再 /pi 即可. pi 的值通过计算表达式 ~4 *
    atan(1)~ 得到.

    见 ~rect_pol~ 演示步骤, 还复习了结构和 ~typedef~ 相关知识

    若编译时出现如下消息:
    #+begin_example
      Undefinded: _sqrt
    #+end_example

    或
    #+begin_example
      'sqrt': unresolved external
    #+end_example

    或其他类似消息, 表明编译器链接器没有找到数学库. UNIX 系统会要求使用 ~-lm~ 标
    记(flag) 指示链接器搜索数学库

    #+begin_src bash
      cc rect_pol.c -lm
    #+end_src

    *注意*: ~-lm~ 标记在命令行的 *末尾*. 因为链接器编译 C 文件后才开始处理. 在
     Linux 中使用 GCC 编译器可能要这样写:
     #+begin_src bash
       gcc rect_pol.c -lm
     #+end_src
 
*** 类型变体
    基本的浮点型数学函数接受 double 类型的参数, 并返回 double 类型的值. 当然, 也
    可以把 float 或 long double 类型的参数传递给这些函数, 它们仍然能正常工作, 因
    为这些类型的参数会被转换成 double 类型. 这样做很方便, 但不是最好的处理方式.
    如果不需要双精度, 那么用 float 类型的单精度值来计算会更快些. 而且把 long
    double 类型的值传给 double 类型的形参会 *损失精度*, 形参获得的值可能不是原来
    的值. 为了解决这些潜在的问题, C 标准专门为 float 类型和 long double 类型提供
    了标准函数, 即在原函数名前加上 f 或 l 前缀. 因此, ~sqrf()~ 是 ~sqrt()~ 的
    float 版本, ~sqrtl()~ 是 ~sqrt()~ 的 long double 版本

    ~generic.c~ 演示了 利用 泛型选择表达式定义泛型宏, 并根据参数类型选择最合适的
    数学函数版本

    *注意*: 与书中结果可能不一致

    ~SQRT(i)~ 和 ~SQRT(xx)~ 的返回值相同, 因为它们的参数类型分别是 int 和
    double, 所以只能与 ~default~ 标签对应

    ~SIN()~ 的定义让每个带标号的值都是函数调用, 所以 ~_Generic~ 表达式的值是一个
    特定的函数调用, eg: ~sinf((X) / RAD_TO_DEG)~, 用传入 ~SIN()~ 的参数替换 X

    ~SQRT()~ 的定义也许更简洁. ~_Generic~ 表达式的值就是函数名, 如 ~sinf~. 函数
    的地址可以代替该函数名, 所以 ~_Generic~ 表达式的值是一个指向函数的指针. 然而,
    紧随整个 ~Generic~ 表达式之后的是 ~(X)~, 函数指针(参数)表示函数指针. 因此,
    这是一个带指定的参数的函数指针

    简而言之, 对于 ~SIN()~, 函数调用在泛型选择表达式内部; 而对于 ~SQRT()~, 先对
    泛型选择表达式求值得一个指针, 然后通过该指针调用它所指向的函数

*** ~tgmath.h~ 库 (C99)
    C99 标准提供的 ~tgmath.h~ 头文件中定义了泛型类型宏, 其效果与 ~generic.c~ 类
    似. 如果在 ~math.h~ 中为一个函数定义了 3 种类型(float, double 和 long
    double) 的版本, names ~tgmath.h~ 文件就创建一个泛型类型宏, 与原来 double 版
    本的函数名同名.

    eg: 根据提供的参数类型, 定义 ~sqrt()~ 宏展开为 ~sqrf()~, ~sqrt()~ 或
    ~sqrtl()~ 函数. 换言之, ~sqrt()~ 宏的行为和 ~generic.c~ 中的 ~SQRT()~ 宏类似.

    如果编译器支持复数运算, 就会支持 ~complex.h~ 头文件, 其中声明了与复数运算相
    关的函数.
    eg: ~csqrtf()~, ~csqrt()~, ~csqrtl()~, 这些函数分别返回 float complex,
    double complex 和 long double complex 类型的 *复数平方根*. 如果提供这些支持,
    那么 ~tgmath.h~ 中的 ~sqrt()~ 宏也能展开为相应的复数平方根函数.

    如果包含了 ~tgmath.h~, 要调用 ~sqrt()~ 函数而不是 ~sqrt()~ 宏, 可以用圆括号
    把被调用的函数名括起来:
    #+begin_src c
      #include <tgmath.h>

      // ...
      float x = 44.0;
      double y;
      y = sqrt(x); // 调用宏, 所以说 sqrtf(x)
      y = (sqrt)(x); // 调用函数 sqrt()
    #+end_src

    这样操作没问题, 因为类函数宏的名称必须用圆括号括起来. 圆括号只会影响操作顺序,
    不会影响括起来的表达式, 所以这样做得到的仍是函数调用的结果.

    *由于 C 语言奇怪而矛盾的函数指针规则, 还也可以使用(*sqrt)()的形式来调用函数*

    不借助 C 标准意外的机制, C11 新增的 ~_Generic~ 表达式是实现 ~tgmath.h~ 最简
    单的方式
** 通用工具库
   通用工具库包括随机数生成器, 查找和排序函数, 转换函数和内存管理函数, 转换函数
   和内存管理函数.
   
   第 12 章介绍过 ~rand()~, ~srand()~, ~malloc()~ 和 ~free()~ 函数.

   在 ANSI C 标准中, 这些函数的原型都在 ~stdlib.h~ 头文件中.

   附录 B 参考资料 5 列出了该系列的所有函数

*** ~exit()~ 和 ~atexit()~ 函数
    在 ~main()~ 返回系统时将自动调用 ~exit()~ 函数. ANSI 标准还新增了一些不错的
    功能, 其中最重要的是 *可以指定在执行 ~exit()~ 时调用的特定函数.

    ~atexit()~ 函数通过退出时注册呗调用的函数提供这种功能, ~atexit()~ 函数接受一
    个函数指针作为参数. ~byebye.c~ 演示了它的用法

    1. ~atexit()~ 函数的用法
       这个函数使用函数指针. 要使用 ~atexit()~ 函数, 只需把退出时要调用的函数地
       址传给 ~atexit()~ 即可. 函数名作为函数参数时相当于该函数的地址. 然后
       *~atexit()~ 注册函数列表中的函数, 当调用 ~exit()~ 时就会执行这些函数*.
       ANSI 保证, 在这个列表中至少可以放 32 个函数. 最后调用 ~exit()~ 函数时,
       ~exit()~ 会执行这些函数(执行顺序与列表中的函数顺序相反, 即最后添加的函数
       最先执行)
       
       ~atexit()~ 注册的函数(如: ~sign_off()~ 和 ~too_bad()~) 应该不带任何参数且
       返回类型为 void. 通常, 这些函数会执行一些清理任务, eg: 更新监视程序的文件
       或重置环境变量.

       *注意*: 即使没有显式调用 ~exit()~, ~main()~ 结束时会隐式调用 ~exit()~

    2. ~exit()~ 函数的用法
       ~exit()~ 执行完 ~atexit()~ 函数后, 会完成一些清理工作: 刷新所有输出流, 关
       闭所有打开的流和关闭由标准 I/O 函数 ~tmpfile()~ 创建的临时文件. 然后
       ~exit()~ 把控制权返回主机环境, 如果可能的话, 向主机环境报告终止状态.

       通常, UNIX 程序使用 0 表示成功终止, 用非 0 值表示终止失败. UNIX 返回的代
       码并不适用于所有的系统, 所以 ANSI C 为了可移植性的要求, 定义了一个名为
       ~EXIT_FAILURE~ 的宏表示终止失败. 类似地, ANSI C 还定义了 ~EXIT_SUCCESS~
       表示成功终止. 不过, ~exit()~ 函数也接受 0 表示成功终止. 在 ANSI C 中, 在
       非递归的 ~main()~ 函数中使用 ~exit()~ 函数等价于使用关键字 ~return~. 尽管
       如此, 在 ~main()~ 以外的函数中使用 ~exit()~ 也会终止整个程序

*** ~qsort()~ 函数
    对较大型的数组而言, "快速排序"方法是最有效的排序算法之一. 该算法由
    C.A.R.Hoare 于 1962 年开发. 它把数组不断分成更小的数组, 直到变成单元素数组.
    首先, 把数组分成两部分, 一部分的值都小于另一部分的值. 这个过程一直持续到数组
    完全排序好为止.

    快速排序算法在 C 实现中的名称是 ~qsort()~. ~qsort()~ 函数排序数组的数据对象,
    原型如下:
    #+begin_src c
      void qsoort(void* base, size_t nmemb, size_t size,
                  int (*compar)(const void*, const void*));
    #+end_src

    第一个参数是指针, 指向待排序数组的首元素. ANSI C 允许把指向任何数据类型的指
    针强制转换成指向 void 的指针, 因此, ~qsort()~ 的第一个实际参数可以引用任何类
    型的数组.

    第二个参数是待排序的数量, 函数原型把该值转换为 ~size_t~ 类型. ~size_t~ 定义
    在标准头文件中, 是 ~sizeof~ 运算符返回的整数类型

    由于 ~qsort()~ 把第一个参数转换为 void 指针, 所以 ~qsort()~ 不知道数组中每个
    元素的大小. 为此, 函数原型用第三个参数补偿这一信息, 显式指名待排序数组中每个
    元素的大小. 
    eg: 如果排序 double 类型的数组, 那么第三个参数应该是 ~sizeof(double)~.

    最后, ~qsort()~ 还需要一个指向函数的指针, 这个被指针指向的比较函数用于确定排
    序的顺序. 该函数应接收 2 个参数: 分别指向待比较两项的指针. 如果第一项的值大
    于第二项, 比较函数则返回正数; 如果相同返回 0, 如果小于返回复数. ~qsort()~ 根
    据给定的其他信息计算出两个指针的值, 然后把它们传递给比较函数

    ~qsort()~ 原型中的第四个参数确定了比较函数的形式:
    #+begin_src c
      int (*compar)(const void*, const void*);
    #+end_src

    这表明 ~qsort()~ 最后一个参数是一个指向函数的指针, 该函数返回 int 类型的值且
    接受两个指向 ~const void~ 的指针作为参数, 这两个指针指向待比较项

    ~qsorter.c~ 程序和后面的讨论解释了如何定义一个比较函数, 以及如何使用
    ~qsort()~. 该程序创建了一个内含随机浮点值的数组, 并排序了这个数组

    分析: ~qsort()~ 的用法和 ~mycomp()~ 的定义
    1. ~qsort()~ 的用法
       ~qsort()~ 函数排序数组的数据对象. 该函数的 ANSI 原型如下:
       #+begin_src c
         void qsort(void* base, size_t nmemb, size_t size,
                    int (*compar)(const void* const void*));
       #+end_src

       第一个参数指向待排序数组首元素的指针, 程序中实参为 double 类型的数组名
       vals, 因此指针指向该数组的首元素. 根据该函数的原型, 参数 vals 会被强制转
       换成指向 void 的指针. 由于 ANSI C 允许把指向任何数据类型的指针强制转换成
       指向 void 的指针, 所以 ~qsort()~ 的第一个实际参数可以引用任何类型的数组

       第二个参数是待排序项的数量, 即数组元素的数量

       第三个参数是数组中每个元素占用的空间大小, 本例为 ~sizeof(double)~

       最后一个参数是 ~mycomp~, 函数名即是函数的地址, 该函数用于比较元素

    2. ~mycomp()~ 的定义
       ~qsort()~ 的原型规定了该函数返回 int 类型的值并且接受两个指向 ~const
       void~ 的指针作为参数.

       ~qsort()~ 函数把两个待比较元素的地址传递给比较函数. 

       *注意*: ~qsort()~ 的第一个参数是引用整个数组, 比较函数中的两个参数引用数
       组中的两个元素. 这里存在一个问题: 为了比较指针所指向的值, 必须解应用指针.
       因为值是 double 类型, 所以要把指针解引用为 double 类型的值. 然而,
       ~qsort()~ 要求指针指向 void. 要解决这个问题, *必须在比较函数的内部声明两
       个类型正确的指针*, 并初始化它们分别指向作为参数传入的值

       为了让该方法更具有通用性, ~qsort()~ 和比较函数使用了指向 void 的指针. 因
       此, 必须把数组中的每个元素的大小明确告诉 ~qsort()~, 并且在比较函数的定义
       中, 必须把该函数的指针参数转换为对具体应用而言类型正确的指针.

       *注意*: C 和 C++ 中的 void*
       C 和 C++ 对待指向 void 的指针有锁不同. 它们都可以把任何类型的指针赋给
       void 类型的指针. 但是, C++ 要求在把 void* 指针付给任何类型的指针时 *必须
       进行强制类型转换*, 而 C 没有这样的要求
       #+begin_src c
         const double* a1 = (const double*)p1;
       #+end_src

       这种转换在 C 中可选, C++ 中必须.

       
    另一个比较函数的例子: 假设如下声明:
    #+begin_src c
      struct names
      {
        char first[40];
        char last[40];
      };

      struct names staff[100];
    #+end_src

    调用方式:
    #+begin_src c
      qsort(staff, 100, sizeof(struct names), comp);
    #+end_src

    假设要先按姓排序, 再按名排序:
    #+begin_src c
      #include <string.h>

      int comp(const void* p1, const void* p2)
      {
        const struct names* ps1 = (const struct names*)p1;
        const struct names* ps2 = (const struct names*)p2;

        int res;
        res = strcmp(ps1->last, ps2->last); // 姓

        if (res != 0) {
          return res;
        } else {
          // 比较名
          return strcmp(ps1->first, ps2->first);
        }
      }
    #+end_src

    该指针使用 ~strcmp()~ 函数进行比较. 返回值与函数的要求相匹配
    
** 断言库
   ~assert.h~ 头文件支持的断言库是一个用于辅助调试程序的小型库. 它由 ~assert()~
   宏组成, 接受一个整型表达式作为参数. 如果表达式求值为假(非零), ~assert()~ 宏就
   在标准错误流(~stderr~) 中写入一条错误信息, 并调用 ~abort()~ 函数终止程序
   (~abort()~ 函数的原型在 ~stdlib.h~ 头文件中). ~assert()~ 宏是为了标识出程序中
   某些条件为真的关键位置, 如果其中的一个具体条件为假, 就用 ~assert()~ 语句终止
   程序. 通常, ~assert()~ 的参数是一个条件表达式或逻辑表达式. 如果 ~assert()~ 中
   止了程序, 它首先会显示失败的测试, 包含测试的文件名和行号

*** ~assert~ 的用法
    ~assert.c~ 演示了用法. 在求平方根之前, 断言 ~z~ 是否大于等于 0. 程序还错误地
    减去一个值而不是加上一个值, 故意让 ~z~ 得到不合适的值

    错误消息指明没有满足表达式的条件

    用 if 语句也能完成任务, 但用 ~assert()~ 不仅能 *自动标识文件和出问题的行号*,
    还有一种无须更改代码就能开启或关闭 ~assert()~ 的机制. 如果认为已经排除了程序
    的 bug, 就可以把下面的宏定义写在 *包含 ~assert.h~ 的位置前面*
    #+begin_src c
      #define NDEBUG
    #+end_src

    这样编译器就会 *禁用文件中的所有 ~assert()~ 语句, 如果出现问题可以移除该语句,
    方便调试

*** ~_Static_assert(C11)~
    ~assert()~ 表达式是在 *运行时* 进行检查. C11 新增了 一个特性: ~_Static_assert~
    声明, 可以在 *编译时* 检查 ~assert()~ 表达式. 因此, ~assert()~ 可以导致正在
    运行的 *程序中止*, 而 ~_Static_assert()~ 可以导致程序 *无法通过编译*. 

    ~_Static_assert()~ 接受 2 个参数. 第一个参数是整形常量表达式, 第二个参数是一
    个字符串. 

    如果第一个表达式求值为 0 (或 ~_False~), 编译器会显示字符串, 而且 *不编译* 该
    程序.

    ~statasrt.c~ 演示了用法

    MSVC, Clang 编译结果:
    #+begin_example
      .\statasrt.c:4:1: error: static_assert failed due to requirement '8 == 16' "16-bit char falsey, assumed"
      _Static_assert(CHAR_BIT == 16, "16-bit char falsey, assumed");
      ^              ~~~~~~~~~~~~~~
      1 error generated.
    #+end_example

    根据语法, ~_Static_assert()~ 被视为声明. 因此, 它可以出现在函数中, 或者在这
    种情况下出现在函数逇外部

    ~_Static_assert~ 要求它的第一个参数是 *整形常量表达式*, 这保证了能在编译期求
    值(~sizeof~ 表达式被视为整形常量). 不能将 ~assert.c~ 中的 ~assert()~ 换为
    ~_Static_assert~, 因为 ~z > 0~ 不是常量表达式, 运行期才能求值. 可以用
    ~assert()~ 更换 ~_Static_assert()~, 但在运行期才生成错误信息, 效率低下
** ~string.h~ 库中的 ~memcpy()~ 和 ~memmove()~
   不能把一个数组赋给另一个数组, 所以要通过循环把数据中的每个元素赋给另一个数组
   相应的元素.

   有一个例外的情况是: 使用 ~strcpy()~ 和 ~strncpy()~ 函数来处理字符数组.
   ~memcpy()~ 和 ~memmove()~ 函数提供类似的方法处理任意类型的数组.

   下面是函数原型:
   #+begin_src c
     void* memcpy(void* restrict s1, const void* restrict s1, size_t n);
     void* memmove(void* s1, const void* s2, size_t n);
   #+end_src

   这两个函数都是从 s2 指向的位置 *拷贝 n 字节* 到 s1 指向的位置, 而且都返回 s1
   的值. 不同的是 ~memcpy()~ 的参数带关键字 ~restrict~, 即 ~memcpy()~ 假设两个内
   存区域之间 *没有重叠*; 而 ~memmove()~ 不做这样的假设, 所以拷贝过程类似于先把
   所有字节拷贝到一个 *临时缓冲区*, 然后再拷贝到最终目的地.

   如果使用 ~memcpy()~ 时, 区域出现重叠, 行为是未定义的, 函数可能正常工作, 也可
   能失败. 编译器不会在本不该使用 ~memcpy()~ 时禁止使用, 需要程序员自行判断确保
   两个区域不重叠.

   由于这两个参数设计用于处理 *任何数据类型*, 所以它们的参数都是两个指向 void 的
   指针. 因此, 这两个参数使用第三个参数 *指名待拷贝的字节数*.

   *注意*: 对数组而言, 字节数一般与元素个数不同.
   eg: 10 个 double 类型的元素: ~10 * sizeof(double)~, 而不是 10

   ~mems.c~ 程序假设 double 类型的 int 类型的两倍大小, 并使用 ~_Static_assert~
   特性测试断言

   程序最后一次调用 ~memcpy()~ 从 double 类型数组中把数据拷贝到 int 类型数组中,
   演示了 ~memcpy()~ 函数不知道也 *不关心类型*, 它只负责从一个位置把一些字节拷贝
   到另一个位置(eg: 结构中拷贝数据到字符数组). 而且拷贝过程中也 *不会进行数据转
   换*. 如果用循环对数组中的每个元素赋值, double 类型的值会在复制过程中被转换为
   int 类型的值. 这种情况下, 按原样拷贝字节, 然后程序把这些位组合解释成 int 类型.
** 可变参数: ~stdarg.h~
   本章提到的变参宏, 可以接受可变数量的参数. ~stdarg.h~ 头文件为函数提供了一个类
   似的功能, 但是用法复杂. 步骤如下:

   1. 提供一个使用省略号的参数原型
   2. 在函数定义中创建一个 ~va_list~ 类型的变量
   3. 用宏把该变量初始化为一个参数列表
   4. 用宏访问参数列表
   5. 用宏完成清理工作
      
   分析步骤. 这种函数的原型有一个形参列表, 其中 *至少有一个形参和一个省略号*:
   #+begin_src c
     void f1(int n, ...); // 有效
     int f2(const char* s, int k, ...); // 有效
     char f3(char c1, ..., char c2); // 无效, 省略号不在最后
     double f3(...); // 无效, 没有形参
   #+end_src

   最右边的形参(即省略号的 *前一个形参*) 起着特殊的作用, 标准中用 ~parmN~ 这个术
   语来描述该形参. 在上面的例子中, 第一行 ~f1()~ 中 ~parmN~ 为 n, 第二行 ~f2()~
   中 ~parmN~ 为 k. 传递给该形参的实际参数是省略号部分代表的参数数量.

   eg: 可以这样使用前面声明的 ~f1()~ 参数:
   #+begin_src c
     f1(2, 200, 400); // 2 个额外的参数
     f1(4, 13, 117, 18, 23); // 4 个额外的参数
   #+end_src

   接下来, 声明在 ~stdarg.h~ 中的 ~va_list~ 类型代表一种用于储存形参对应的形参列
   表中省略号部分的数据对象. 变参函数的定义起始部分类似如下:
   #+begin_src c
     double sum(int lim, ...)
     {
       va_list ap; // 声明一个储存参数的对象
     }
   #+end_src
   
   在该例中, ~lim~ 是 ~parmN~ 形参, 它表明变参列表中参数的数量

   然后, 该函数将使用定义在 ~stdarg.h~ 中的 ~va_start()~ 宏, 把参数列表拷贝到
   ~va_list~ 类型的变量中. 该宏有两个参数: ~va_list~ 类型的变量和 ~parmN~ 形参.
   接着上面的例子陶瑞了, ~va_list~ 类型的变量是 ~ap~, ~parmN~ 形参是 ~lim~. 所以,
   应该如下调用:
   #+begin_src c
     va_start(ap, lim); // 把 ap 初始化为参数列表
   #+end_src

   下一步是访问参数列表的内容, 这涉及使用另一个宏 ~va_arg()~. 该宏接受两个参数:
   一个 ~va_list~ 类型的变量和一个类型名. 第一次调用 ~va_arg()~ 时, 它返回参数列
   表的第一项; 第二次调用时返回第二项. 一以此类推. 表示类型的参数指定了返回值的
   类型. 

   eg: 如果参数列表中的第一个参数是 double 类型, 第二个是 int, 可以这样做:
   #+begin_src c
     double tic;
     int toc;

     tic = va_arg(ap, double); // 检索第一个参数
     toc = va_arg(ap, int); // 检索第二个参数
   #+end_src

   注意: 传入的参数类型必须与宏参数的类型相匹配. 如果第一个参数是 10.0, tic 对应
   的一行代码可以正常功过. 如果参数是 10, 这行代码可能会出错. 
   这里 *不会像赋值那样把 double 类型自动转换成 int 类型*
   
   最后, 要使用 ~va_end()~ 宏完成清理工作.
   eg: 释放动态分配用于储存参数的内存. 该宏接受一个 ~va_list~ 类型的变量:
   #+begin_src c
     va_end(ap); // 清理工作
   #+end_src

   调用 ~va_end(ap)~ 后, 只有用 ~va_start~ *重新初始化* ap 后, 才能使用变量
   ap.

   因为 ~va_arg()~ *不提供退回之前参数的方法*, 所以有必要保存 ~va_list~ 类型变量的
   副本. C99 新增了 ~va_copy()~ 宏用于处理这种情况. 接受两个 ~va_list~ 类型的变
   量作为参数, 它把第二个参数拷贝给第一个参数:
   #+begin_src c
     va_list ap;
     va_list apcopy;
     double
     double tic;
     int tic;

     // ...

     va_start(ap, lim); // 把 ap 初始化为一个参数列表
     va_copy(apcopy, ap);// 把 apcopy 作为 ap 的副本
     tic = va_arg(ap, double); // 检索第一个参数
     toc = va_arg(ap, int); // 检索第二个参数
   #+end_src

   此时, 即使删除了 ap, 也可以从 apcopy 中检索两个参数

   ~varargs.c~ 演示了如何创建这样的函数, 该函数对可变参数求和. ~sum()~ 的第一个
   参数是待求和项的数目.

   第一次调用 ~sum()~ 时对 3 个数求和, 第二次对 6 个数求和

   使用变参函数比使用变参宏更复杂, 但应用范围更广
** 关键概念
   C 标准不仅描述 C 语言, 还描述了组成 C 语言的软件包, C 预处理和 C 标准库. 通过
   预处理器可以控制 *编译过程*, 列出要替换的内容, 指名要编译的代码行和影响编译器
   其他方面的行为. C 库扩展了 C 语言的作用范围, 为许多编程问题提供现成的解决方案

** 本章小结
   C 预处理器和 C 库是 C 语言的两个重要的附件. C 预处理器遵循预处理器的指令, 在
   编译源代码之前调整源代码. C 库提供许多有助于完成各种任务的函数, 包括输入, 输
   出, 文件处理, 内存管理, 排序与搜索, 数学运算, 字符串处理等.
