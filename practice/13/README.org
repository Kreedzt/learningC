* 第 13 章 文件输入/输出
  本章介绍:
  - io 函数
  - 如何使用 C 标准 I/O 系列的函数处理文件
  - 文件模式和二进制模式, 文本和二进制格式, 缓冲和无缓冲 I/O
  - 使用即可以顺序访问文件也可以随机访问文件的函数

** 与文件进行通信
   需要程序充文件中读取信息或把信息写入文件. 这种程序与文件交互的形式就是文件重
   定向. 

   C 提供了更强大的文件通信方法, 可以在程序中打开文件, 然后使用特殊的 I/O 函数读取
   文件中的信息或把信息写入文件.

*** 文件是什么
    文件(file)通常是在磁盘或固态硬盘上的一段已命名的存储区. 对我们而言,
    ~stdio.h~ 就是一个文件的名称, 该文件中包含一些有用的信息. 然而, 对操作系统而
    言, 文件更复杂一些. 

    eg: 大型文件会分开储存, 或者包含一些额外的数据, 方便操作系统确定文件的种类.
    这些都是操作系统所关心的, 程序员关心的是 C 程序如何处理文件(除非正在编写操作系
    统)

    C 把文件看作是一系列连续的 *字节*, 每个 *字节* 都能被单独读取. 这与 UNIX 环境中
    (C 的发源地)的文件结构相对应. 由于其他环境中可能无法完全对应这个模型, C 提供 2
    种文件模式: *文本模式* 和 *二进制模式*.

*** 文本模式和二进制模式
    首先要区分文本内容和二进制内容, 文本格式和二进制文件格式, 以及文件的文本模式
    和二进制模式.

    所有文件的内容都以二进制形式(0 或 1)储存. 但是, 如何文件是最初使用二进制编码
    的字符(例如: ASCⅡ或 Unicode)表示文本(就像 C 字符串那样), 该文件就是文本文件, 其
    中包含文本内容. 

    如果文件中的二进制值代表及其语言代码或数值数据(使用相同的内部表示, 假设, 用
    于 long 或 double 类型的值)或图片或音乐编码, 该文件就是二进制文件, 其中包含
    二进制内容.

    UNIX 用同一种文件格式处理文本文件和二进制文件的内容.
    C 是作为开发 UNIX 的工具创建的, C 和 UNIX 在文本中都使用 ~\n~ (换行符)表示换行.
    UNIX 目录中有一个统计文件大小的技术, 程序可使用该计数器确定是否读到文件结尾. 
    UNIX 目录中有一个统计文件大小的技术, 程序可使用该计数确定是否读到文件结尾, 然
    而, 其他系统再次之前就有其他方法处理文件, 专门用于保存文本. 

    以前的 OS X Macintosh 文件用 ~\r~ (回车符)表示新的一行, 早期的 ~MS-DOS~ 文件使
    用 ~\r\n~ 组合表示新的一行, 用嵌入的 ~Ctrl+Z~ 字符表示文件结尾, 即使实际文件
    用添加空字符的的方法使其总大小是 256 的倍数(在 Windows 中, Nodepad *仍然* 生成
    MS-DOS 格式的文本文件, 但是新的编辑器使用类 UNIX 格式居多). 其他系统可能保持
    文本文件中的每一行长度相同, 如有必要, 用空字符填充每一行, 使其长度保持一致.
    或者, 系统可能在每行的开始标出每行的长度

    
    为了规范文件的处理, C 提供 2 种访问文件的途径: *二进制模式* 和 *文本模式*.
    在二进制模式中, 程序可以访问文件的 *每个字节*. 而在文本模式中, *程序所见的内
    容和文件的实际内容不同*. 程序以文本模式读取文件时, 把本地环境表示的行末尾或文
    件结尾映射为 C 模式. 例如, C 程序在旧式 Macintosh 中以文本模式读取文件时, 把文件
    中的 ~\r~ 转换成 ~\n~; 写入文件时, 把 ~\n~ 转换成 ~\r\n~. 在其他环境中编写的
    文本模式程序也会做类似的转换.

    如果读写一个旧式 MS-DOS 文本文件, 程序会看到中间中的 ~\r~ 和 ~\n~ 字符, *不会
    发生映射*. 如果要编写旧式 Mac 格式, MS-DOS 格式或 UNIX/Linux 格式的文件模式程序,
    应该使用 *二进制模式*, 这样程序才能确定实际的文件内容并执行相应的动作

    两种模式的 *实现可以相同*, 因为 UNIX 使用一种文件格式, 这 2 种模式对于 UNIX 实现而
    言完全相同. Linux 也是如此.
*** I/O 的级别
    除了选择文件的模式, 大多数情况下, 还可以选择 I/O 的 2 个级别(即处理文件访问的 2 个
    级别). 底层 I/O(low-level I/O)使用操作系统提供的基本 I/O 服务. 标准高级
    I/O(standard high-lebel I/O)使用 C 库的标准包和 ~stdio.h~ 头文件定义. 因为无法
    保证所有的操作系统都使用相同的底层 I/O 模式, *C 标准只支持标准 I/O 包*. 有些实现会
    提供底层库, 但是 C 标准建立了 *可移植的 I/O* 模式, 我们主要讨论这些 I/O.

*** 标准文件
    C 程序会自动打开 3 个文件, 它们被称为标准输入(standard input), 标准输出
    (standard output) 和标准错误输出(standard error output). 在默认情况下, 标准
    输入是系统的普通输入设备, 通常为键盘; 标准输出和标准错误输出是系统的普通输出
    设备, 通常为显示屏.

    通常. 标准输入为程序提供输入, 它是 ~getchar()~ 和 ~scanf()~ 使用的文件.
    程序通常输入到标准输出, 它是 ~putchar()~, ~puts()~ 和 ~printf()~ 使用的文件.
    第 8 张提到的重定向把其他文件视为标准输入或标准输出. 标准错误输出提供了一个逻
    辑上不同的地方来发送错误消息.
    
    eg: 使用重定向把输出发送给文件而不是屏幕, 那么发送至标准错误输出的内容仍然会
    被发送到屏幕上

*** 标准 I/O
    与底层 I/O 相比, 标准 I/O 包除了可移植外还有 2 个好处
    1. 标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题.
       eg: ~printf()~ 把不同形式的数据转换成与终端相适应的字符串输出.
    2. 输出和输出都是 *缓冲* 的.
       一次转义一大块信息而不是一字节信息(通常至少 512 字节)
       
       eg: 当程序读取文件时, 一块数据被拷贝到缓冲区(一块中介存储区域). 这种缓冲
       极大地提高了数据传输速率. 程序可以检查缓冲区中的字节. 缓冲在后台处理, 所
       以让人有逐字符访问的错觉(若使用底层 I/O, 要自己完成大部分工作). 

*** 检查命令行参数
    尽管 ~argv[0]~ 这一参数可以检查参数, 但是 *一些操作系统可能不识别*
    ~argv[0]~, 这种用法并非完全可移植.

    ~exit()~ 函数关闭所有打开的文件并结束程序. ~exit()~ 的参数被传递给一些操作系
    统, 包括 UNIX, Linux, Windows 和 MS-DOS, 以供其他程序使用.
    通常的惯例是: 正常结束的程序传递 0, 异常结束的程序传递非 0 值.
    *不同的退出值可用于区分程序失败的不同原因*, 这也是 UNIX 和 DOS 变成的通常做法.

    并不是所有的操作系统都能识别相同范围内的反馈至. 因此, C 标准规定了一个最小的
    限制范围. 标准要求 0 或宏 ~EXIT_SUCCESS~ 用于表明成功结束程序, 宏
    ~EXIT_FAILURE~ 用于表明结束程序失败. 这些宏和 ~exit()~ 原型都位于 ~stdlib.h~
    头文件中.

    根据 ANSI C 的规定, 在最初调用的 ~main()~ 中使用 ~return~ 与带哦用 ~exit()~
    的效果相同. 因此, 在 ~main()~, 下面的语句:

    #+begin_src c
      return 0;
    #+end_src

    和下面的这条语句的作用相同:
    #+begin_src c
      exit(0);
    #+end_src
    
    但是要注意, 我们说的是 "最初的调用". 如果 ~main()~ 在一个递归程序中,
    ~exit()~ 仍然会终止程序, 但是 ~return~ 只会把控制权交给上一级递归, 直至最初
    的一级. 然后 ~return~ 结束程序. ~return~ 和 ~exit()~ 的另一个区别是, 即使在
    其他函数中 (除 ~main()~ 以外) 调用 ~exit()~ 也能结束整个程序.

*** ~fopen()~ 函数
    
    ~fopen()~ 函数打开文件的第一个参数是待打开文件的名称, 包含该文件名的字符串地
    址, 第二个参数是一个字符串, 指定待打开的模式.

    | 模式字符串                                                 | 含义                                                                                                                       |
    |------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------|
    | "r"                                                        | 以读模式打开文件                                                                                                           |
    | "w"                                                        | 以写模式打开文件, 把现有的文件商都截为 0, 如果文件不存在, 则创建一个文件                                                   |
    | "a"                                                        | 以写模式打开文件, 在现有的文件末尾添加内容, 如果文件不存在, 则创建一个新文件                                               |
    | "r+"                                                       | 以更新模式打开文件(即可读写文件)                                                                                           |
    | "w+"                                                       | 以更新模式打开文件(即, 读写), 如果文件存在, 则将其长度截为 0; 如果文件不存在, 则创建一个新文件                             |
    | "a+"                                                       | 以更新模式打开文件(即, 读写), 在现有的文件添加内容, 如果文件不存在则创建一个新文件, 可以读整个文件, 但是只能从末尾添加内容 |
    | "rb", "wb", "ab", "ab+", "a+b", "wb+", "w+b", "ab+", "a+b" | 与上一个模式类似, 但是以二进制模式而不是文本模式打开文件                                                                   |
    | "wx", "wbx", "w+x", "wb+x" 或 "w+bx"                       | (C11) 类似非 x 模式, 但是如果文件以存在或独占模式打开文件, 则打开文件失败                                                                              |

    像 UNIX 和 Linux 这样只有一种文件类型的系统, 带 b 字母的模式和不带 b 字母的
    模式相同.

    新的 C11 新增了带 x 字母的写模式, 与以前的写模式相比具有更多特性:

    1. 如果以传统的一种写模式打开一个现有文件, ~fopen()~ 会把该文件的长度截为 0,
       丢失内容, 但是使用带 x 字母的写模式, 即使 ~fopen()~ 操作失败, 源文件的内容
       也不会删除.
    2. 如果环境允许, x 模式的 *独占特性* 使得其他程序或线程无法访问正在被打开的文
       件

       

    *警告*:
    如果使用任何一种 "w" 模式(不带 x)打开一个现有文件, 该文件的内容会被删除, 以便
    程序在一个空白文件中开始操作. 然而, 如果使用带 x 字母的任何一种模式, *将无法打
    开一个现有文件*.
    
    程序成功打开文件后, ~fopen()~ 将返回文件指针(file pointer), 其他 I/O 函数可以
    使用这个指针指定该文件. 文件指针的类型是指向 ~FILE~ 的指针, ~FILE~ 是一个定
    义在 ~stdio.h~ 中的派生类型. 文件指针并不指向实际的文件, 它指向一个 *包含文
    件信息的数据对象*, 其中包含操作文件的 I/O 函数所用的缓冲区信息. 因为标准库中的
    I/O 函数使用缓冲区, 所以它们不仅要知道缓冲区的位置, 还要知道缓冲区被填充的程
    序以及操作哪一个文件. 标准 I/O 函数根据这些信息在必要时决定再次填充或情况缓冲
    区.

       
