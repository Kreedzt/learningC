* 第 13 章 文件输入/输出
  本章介绍:
  - io 函数
  - 如何使用 C 标准 I/O 系列的函数处理文件
  - 文件模式和二进制模式, 文本和二进制格式, 缓冲和无缓冲 I/O
  - 使用即可以顺序访问文件也可以随机访问文件的函数

** 与文件进行通信
   需要程序充文件中读取信息或把信息写入文件. 这种程序与文件交互的形式就是文件重
   定向. 

   C 提供了更强大的文件通信方法, 可以在程序中打开文件, 然后使用特殊的 I/O 函数读取
   文件中的信息或把信息写入文件.

*** 文件是什么
    文件(file)通常是在磁盘或固态硬盘上的一段已命名的存储区. 对我们而言,
    ~stdio.h~ 就是一个文件的名称, 该文件中包含一些有用的信息. 然而, 对操作系统而
    言, 文件更复杂一些. 

    eg: 大型文件会分开储存, 或者包含一些额外的数据, 方便操作系统确定文件的种类.
    这些都是操作系统所关心的, 程序员关心的是 C 程序如何处理文件(除非正在编写操作系
    统)

    C 把文件看作是一系列连续的 *字节*, 每个 *字节* 都能被单独读取. 这与 UNIX 环境中
    (C 的发源地)的文件结构相对应. 由于其他环境中可能无法完全对应这个模型, C 提供 2
    种文件模式: *文本模式* 和 *二进制模式*.

*** 文本模式和二进制模式
    首先要区分文本内容和二进制内容, 文本格式和二进制文件格式, 以及文件的文本模式
    和二进制模式.

    所有文件的内容都以二进制形式(0 或 1)储存. 但是, 如何文件是最初使用二进制编码
    的字符(例如: ASCⅡ或 Unicode)表示文本(就像 C 字符串那样), 该文件就是文本文件, 其
    中包含文本内容. 

    如果文件中的二进制值代表及其语言代码或数值数据(使用相同的内部表示, 假设, 用
    于 long 或 double 类型的值)或图片或音乐编码, 该文件就是二进制文件, 其中包含
    二进制内容.

    UNIX 用同一种文件格式处理文本文件和二进制文件的内容.
    C 是作为开发 UNIX 的工具创建的, C 和 UNIX 在文本中都使用 ~\n~ (换行符)表示换行.
    UNIX 目录中有一个统计文件大小的技术, 程序可使用该计数器确定是否读到文件结尾. 
    UNIX 目录中有一个统计文件大小的技术, 程序可使用该计数确定是否读到文件结尾, 然
    而, 其他系统再次之前就有其他方法处理文件, 专门用于保存文本. 

    以前的 OS X Macintosh 文件用 ~\r~ (回车符)表示新的一行, 早期的 ~MS-DOS~ 文件使
    用 ~\r\n~ 组合表示新的一行, 用嵌入的 ~Ctrl+Z~ 字符表示文件结尾, 即使实际文件
    用添加空字符的的方法使其总大小是 256 的倍数(在 Windows 中, Nodepad *仍然* 生成
    MS-DOS 格式的文本文件, 但是新的编辑器使用类 UNIX 格式居多). 其他系统可能保持
    文本文件中的每一行长度相同, 如有必要, 用空字符填充每一行, 使其长度保持一致.
    或者, 系统可能在每行的开始标出每行的长度

    
    为了规范文件的处理, C 提供 2 种访问文件的途径: *二进制模式* 和 *文本模式*.
    在二进制模式中, 程序可以访问文件的 *每个字节*. 而在文本模式中, *程序所见的内
    容和文件的实际内容不同*. 程序以文本模式读取文件时, 把本地环境表示的行末尾或文
    件结尾映射为 C 模式. 例如, C 程序在旧式 Macintosh 中以文本模式读取文件时, 把文件
    中的 ~\r~ 转换成 ~\n~; 写入文件时, 把 ~\n~ 转换成 ~\r\n~. 在其他环境中编写的
    文本模式程序也会做类似的转换.

    如果读写一个旧式 MS-DOS 文本文件, 程序会看到中间中的 ~\r~ 和 ~\n~ 字符, *不会
    发生映射*. 如果要编写旧式 Mac 格式, MS-DOS 格式或 UNIX/Linux 格式的文件模式程序,
    应该使用 *二进制模式*, 这样程序才能确定实际的文件内容并执行相应的动作

    两种模式的 *实现可以相同*, 因为 UNIX 使用一种文件格式, 这 2 种模式对于 UNIX 实现而
    言完全相同. Linux 也是如此.
*** I/O 的级别
    除了选择文件的模式, 大多数情况下, 还可以选择 I/O 的 2 个级别(即处理文件访问的 2 个
    级别). 底层 I/O(low-level I/O)使用操作系统提供的基本 I/O 服务. 标准高级
    I/O(standard high-lebel I/O)使用 C 库的标准包和 ~stdio.h~ 头文件定义. 因为无法
    保证所有的操作系统都使用相同的底层 I/O 模式, *C 标准只支持标准 I/O 包*. 有些实现会
    提供底层库, 但是 C 标准建立了 *可移植的 I/O* 模式, 我们主要讨论这些 I/O.

*** 标准文件
    C 程序会自动打开 3 个文件, 它们被称为标准输入(standard input), 标准输出
    (standard output) 和标准错误输出(standard error output). 在默认情况下, 标准
    输入是系统的普通输入设备, 通常为键盘; 标准输出和标准错误输出是系统的普通输出
    设备, 通常为显示屏.

    通常. 标准输入为程序提供输入, 它是 ~getchar()~ 和 ~scanf()~ 使用的文件.
    程序通常输入到标准输出, 它是 ~putchar()~, ~puts()~ 和 ~printf()~ 使用的文件.
    第 8 张提到的重定向把其他文件视为标准输入或标准输出. 标准错误输出提供了一个逻
    辑上不同的地方来发送错误消息.
    
    eg: 使用重定向把输出发送给文件而不是屏幕, 那么发送至标准错误输出的内容仍然会
    被发送到屏幕上

*** 标准 I/O
    与底层 I/O 相比, 标准 I/O 包除了可移植外还有 2 个好处
    1. 标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题.
       eg: ~printf()~ 把不同形式的数据转换成与终端相适应的字符串输出.
    2. 输出和输出都是 *缓冲* 的.
       一次转义一大块信息而不是一字节信息(通常至少 512 字节)
       
       eg: 当程序读取文件时, 一块数据被拷贝到缓冲区(一块中介存储区域). 这种缓冲
       极大地提高了数据传输速率. 程序可以检查缓冲区中的字节. 缓冲在后台处理, 所
       以让人有逐字符访问的错觉(若使用底层 I/O, 要自己完成大部分工作). 

*** 检查命令行参数
    尽管 ~argv[0]~ 这一参数可以检查参数, 但是 *一些操作系统可能不识别*
    ~argv[0]~, 这种用法并非完全可移植.

    ~exit()~ 函数关闭所有打开的文件并结束程序. ~exit()~ 的参数被传递给一些操作系
    统, 包括 UNIX, Linux, Windows 和 MS-DOS, 以供其他程序使用.
    通常的惯例是: 正常结束的程序传递 0, 异常结束的程序传递非 0 值.
    *不同的退出值可用于区分程序失败的不同原因*, 这也是 UNIX 和 DOS 变成的通常做法.

    并不是所有的操作系统都能识别相同范围内的反馈至. 因此, C 标准规定了一个最小的
    限制范围. 标准要求 0 或宏 ~EXIT_SUCCESS~ 用于表明成功结束程序, 宏
    ~EXIT_FAILURE~ 用于表明结束程序失败. 这些宏和 ~exit()~ 原型都位于 ~stdlib.h~
    头文件中.

    根据 ANSI C 的规定, 在最初调用的 ~main()~ 中使用 ~return~ 与带哦用 ~exit()~
    的效果相同. 因此, 在 ~main()~, 下面的语句:

    #+begin_src c
      return 0;
    #+end_src

    和下面的这条语句的作用相同:
    #+begin_src c
      exit(0);
    #+end_src
    
    但是要注意, 我们说的是 "最初的调用". 如果 ~main()~ 在一个递归程序中,
    ~exit()~ 仍然会终止程序, 但是 ~return~ 只会把控制权交给上一级递归, 直至最初
    的一级. 然后 ~return~ 结束程序. ~return~ 和 ~exit()~ 的另一个区别是, 即使在
    其他函数中 (除 ~main()~ 以外) 调用 ~exit()~ 也能结束整个程序.

*** ~fopen()~ 函数
    
    ~fopen()~ 函数打开文件的第一个参数是待打开文件的名称, 包含该文件名的字符串地
    址, 第二个参数是一个字符串, 指定待打开的模式.

    | 模式字符串                                                 | 含义                                                                                                                       |
    |------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------|
    | "r"                                                        | 以读模式打开文件                                                                                                           |
    | "w"                                                        | 以写模式打开文件, 把现有的文件商都截为 0, 如果文件不存在, 则创建一个文件                                                   |
    | "a"                                                        | 以写模式打开文件, 在现有的文件末尾添加内容, 如果文件不存在, 则创建一个新文件                                               |
    | "r+"                                                       | 以更新模式打开文件(即可读写文件)                                                                                           |
    | "w+"                                                       | 以更新模式打开文件(即, 读写), 如果文件存在, 则将其长度截为 0; 如果文件不存在, 则创建一个新文件                             |
    | "a+"                                                       | 以更新模式打开文件(即, 读写), 在现有的文件添加内容, 如果文件不存在则创建一个新文件, 可以读整个文件, 但是只能从末尾添加内容 |
    | "rb", "wb", "ab", "ab+", "a+b", "wb+", "w+b", "ab+", "a+b" | 与上一个模式类似, 但是以二进制模式而不是文本模式打开文件                                                                   |
    | "wx", "wbx", "w+x", "wb+x" 或 "w+bx"                       | (C11) 类似非 x 模式, 但是如果文件以存在或独占模式打开文件, 则打开文件失败                                                  |

    像 UNIX 和 Linux 这样只有一种文件类型的系统, 带 b 字母的模式和不带 b 字母的
    模式相同.

    新的 C11 新增了带 x 字母的写模式, 与以前的写模式相比具有更多特性:

    1. 如果以传统的一种写模式打开一个现有文件, ~fopen()~ 会把该文件的长度截为 0,
       丢失内容, 但是使用带 x 字母的写模式, 即使 ~fopen()~ 操作失败, 源文件的内容
       也不会删除.
    2. 如果环境允许, x 模式的 *独占特性* 使得其他程序或线程无法访问正在被打开的文
       件

       

    *警告*:
    如果使用任何一种 "w" 模式(不带 x)打开一个现有文件, 该文件的内容会被删除, 以便
    程序在一个空白文件中开始操作. 然而, 如果使用带 x 字母的任何一种模式, *将无法打
    开一个现有文件*.
    
    程序成功打开文件后, ~fopen()~ 将返回文件指针(file pointer), 其他 I/O 函数可以
    使用这个指针指定该文件. 文件指针的类型是指向 ~FILE~ 的指针, ~FILE~ 是一个定
    义在 ~stdio.h~ 中的派生类型. 文件指针并不指向实际的文件, 它指向一个 *包含文
    件信息的数据对象*, 其中包含操作文件的 I/O 函数所用的缓冲区信息. 因为标准库中的
    I/O 函数使用缓冲区, 所以它们不仅要知道缓冲区的位置, 还要知道缓冲区被填充的程
    序以及操作哪一个文件. 标准 I/O 函数根据这些信息在必要时决定再次填充或情况缓冲
    区.

*** ~getc()~ 和 ~putc()~ 函数
    ~getc()~ 和 ~putc()~ 函数与 ~getchar()~ 和 ~putchar()~ 函数类似.
    ~getc()~ 与 ~putc()~ 函数需要指定文件.

    "从标准输入中获取一个字符":

    #+begin_src c
      ch = getchar();
    #+end_src

    "从 fp 指定的文件中获取一个字符":
    #+begin_src c
      ch = getc(fp);
    #+end_src

    "把字符 ch 放入 FILE 指针 fpout 指定的文件中":
    #+begin_src c
      // 第一个参数: 待写入的字符, 第二个参数: 文件指针
      putc(ch, fpout);
    #+end_src
    
*** 文件结尾
    可以通过 ~getc()~ 返回的字符与 ~EOF~ 相比较来判断是否文件结尾

    为了避免读到空文件, 应该使用入口条件循环(不是 do while 循环)进行文件输入.

    程序应该在 *进入循环体之前先尝试读取*:
    #+begin_src c
      int ch;
      FILE *fp = fopen("wacky.txt", "r");
      ch = getc(fp);

      while (ch != EOF) {
        putchar(ch); // 处理输入
        ch = getc(fp); // 获取下一个输入
      }
    #+end_src

    简化版:
    #+begin_src c
      int ch;
      FILE* fp;
      fp = fopen("wacky.txt", "r");

      while ((ch = getc(fp) != EOF) {
          putchar(ch); // 处理输入
      }
    #+end_src

    
    其他输入函数也会用到这种处理方案, 它们在读到文件结尾时也会返回一个错误信号
    (~EOF~ 或 ~NULL~ 指针)

*** ~fclose()~ 函数
    ~fclose(fp)~ 函数关闭 ~fp~ 指定的文件, 必要时刷新缓冲区. 对于较正式的程序,
    应该检查是否成功关闭文件.

    如果成功关闭, ~fclose()~ 函数返回 0, 否则返回 ~EOF~.

    #+begin_src c
      if (fclose(fp) != 0)
        printf("Error in closing file %s\n", argv[1]);
    #+end_src

    如果磁盘已满, 移动硬盘被移除或出现 I/O 错误, 都会导致调用 ~fclose()~ 函数失败

*** 指向标准文件的指针
    ~stdio.h~ 头文件把 3 个文件指针与 3 个标准文件相关联, C 程序会自动打开这 3 个标准文
    件

    | 标准文件 | 文件指针 | 通常使用的设备 |
    |----------+----------+----------------|
    | 标准输入 | stdin    | 键盘           |
    | 标准输出 | stdout   | 显示器         |
    | 标准错误 | stderr   | 显示器            |

    这些指针都是指向 ~FILE~ 的指针, 所以它们可用作标准 I/O 函数的参数, 如
    ~fclose(fp)~ 中的 ~fp~.
** 一个简单的文件压缩程序
   下面的程序示例把一个文件中选定的数据拷贝到另一个文件中. (~reducto.c~)
   该程序同时打开了 2 个文件, 以 "r" 模式打开一个, 以 "w" 模式打开另一个.
   该程序以保留每 3 个字母中的第 1 个字符的方式压缩第 1 个文件的内容.
   最后, 把压缩后的文本存入第 2 个文件.第 2 个文件的名称是第 1 个文件名加上 ~.red~ 后
   缀(reduced).

   使用命令行参数, 同时打开多个文件, 以及在原文件名后面加上后缀, 都是相当有用的
   技巧

   ~fprintf()~ 和 ~printf()~ 类似, 但是 ~fprintf()~ 的第 1 个参数必须是一个文件指
   针. 程序中使用 ~stderr~ 指针把错误消息发送至标准错误, C 标准通常都这么做.

   参数 ~LEN-5~ 为 ~.red~ 后缀和末尾的空字符预留了空间. 如果 ~argv[2]~ 字符串比
   ~LEN-5~ 长, 就拷贝不了空字符.

   程序中还检查了是否成功打开名为 ~eddy.red~ 的文件, 这个步骤在一些环境中 *相当
   重要* , 传统的 DOS 环境中, 不能再后缀名后面添加后缀名(MS-DOS 使用的方法是用
   ~.red~ 替换现有后缀名, 所以 ~strage.c~ 将变成 ~strage.red~, 可以用 ~strchr()~
   函数定位, 只拷贝点前面的部分)

   程序都是 *单独打开和关闭每个文件*. 同时打开的文件数量是有限的, 这个限制取决于
   系统和实现, 范围一般是 10~20.

   相同的文件指针可以处理不同的文件, 前提是这些文件不需要同时打开.

** 文件 I/O: ~fprintf()~, ~fscanf()~, ~fgets()~ 和 ~fputs()~

   I/O 的函数都类似于文件 I/O 函数. 文件 I/O 函数要用 ~FILE~ 指针指定待处理的文件, 与
   ~getc()~, ~putc()~ 类似, 这些函数都要求用指向 ~FILE~ 的指针(如: stdout)指定一
   个文件, 或者使用 ~fopen()~ 的返回值

*** ~fprintf()~ 和 ~fscanf()~ 函数
    ~addaword.c~ 演示 ~fprintf()~, ~fscanf()~ 和 ~rewind()~ 函数的用法


    该程序可以在文件中添加单词, 使用 "a+" 模式, 程序可以读写, 首次使用时, 创建
    wordy 文件, 以便把单词存入其中. 随后, 在文件末添加单词, 虽然 "a+" 模式只允许
    在文件末尾添加内容, 但是该模式下可以读整个文件.
    
    ~rewind()~ 函数让程序回到开始处, 方便 ~while~ 循环打印整个文件的内容.
    ~rewind()~ 接收一个文件指针作为参数

    与 ~putc()~ 不同的是, ~fprintf()~ 和 ~fscanf()~ 函数都把 ~FILE~ 作为第 1 个参
    数, 而不是最后一个参数
*** ~fgets()~ 和 ~fputs()~ 函数
    ~fgets()~ 的第一个参数和 ~gets()~ 函数一样, 也是表示储存输入位置的地址(char*
    类型), 第 2 个参数是一个整数, 表示待输入字符串的大小, 最后一个参数是文件指针,
    指定待读取的文件.

    #+begin_src c
      fgets(buf, STLEN, fp);
    #+end_src

    这里. buf 是 char 类型数组的名称, STLEN 是字符串的大小, fp 是指向 FILE 的指
    针

    ~fgets()~ 读取输入知道第 1 个换行符的后面, 或读到文件结尾, 或者读取 ~STLEN -
    1~ 字符(以上面的 ~fgets()~ 为例)). 然后, ~fgets()~ 在末尾添加一个空字符使之
    成为一个字符串. 字符串的大小是其字符数加上一个空字符.
    如果 ~fgets()~ 在读到字符上限之前已读完一整行, 它会把表示行结尾的换行符放在
    空字符前面. ~fgets()~ 函数在遇到 ~EOF~ 时将返回 ~NULL~ 值, 可以利用这一机制
    检查是否到达文件结尾; 如果未遇到 ~EOF~ 则之前返回传给它的地址.

    ~fputs()~ 函数接受 2 个参数:
    1. 字符串的地址
    2. 文件指针  

    该函数根据传入地址找到的字符串写入指定的文件中. 和 ~puts()~ 函数不同,
    ~fputs()~ 在打印字符串时不会在其末尾添加换行符

    #+begin_src c
      fputs(buf, fp);
    #+end_src
    
    这里, buf 是字符串的地址, fp 用于指定模板文件

    由于 ~fgets()~ 保留了换行符, ~fputs()~ 就不会再添加换行符.
** 随机访问: ~fseek()~ 和 ~ftell()~
   有了 ~fseek()~ 函数, 便可把文件看作是数组, 在 ~fopen()~ 打开的文件中直接移动
   到任意字节处. 

   ~reverse.c~ 演示 ~fseek()~ 和 ~ftell()~ 的用法. 

   ~fseek()~ 有 3 个参数, 返回 ~int~ 类型的值,
   ~ftell()~ 函数返回一个 ~long~ 类型的值, 表示文件中的当前位置

*** ~fseek()~ 和 ~ftell()~ 的工作原理
    ~fseek()~ 的第一个参数是 ~FILE~ 指针, 指向待查找的文件, ~fopen()~ 应该已打开
    该文件.

    ~fseek()~ 的第 2 个参数是偏移量(offset). 该参数表示从起始点开始要移动的距离.

    该参数必须是一个 ~long~ 类型的值, 可以为正(前移), 负(后移), 或 0(保持不动).

    ~fseek()~ 的第 3 个参数是模式, 该参数确定起始点. 根据 ASNI 标准, 在 ~stdio.h~ 头
    文件中规定了几个表示模式的明示常量(manifest constant):

    | 模式     | 偏移量的起始点 |
    |----------+----------------|
    | SEEK_SET | 文件开始处     |
    | SEEK_CUR | 当前位置       |
    | SEEK_END | 文件末尾           |

    
    旧的实现可能缺少这些定义, 可以使用数值 0L, 1L, 2L 分别表示这 3 种模式.
    L 后缀表名其值是 long 类型. 或者, 实现可能把这些明示常量定义在别的头文件中.

    调用 ~fseek()~ 函数的一些示例:(fp 是文件指针):
    #+begin_src c
      fseek(fp, 0L, SEEK_SET); // 定位至文件开始处
      fseek(fp, 10L, SEEK_SET); // 定位至文件中的第10个字节
      fseek(fp, 2L, SEEK_CUR); // 从文件当前位置往前移2个字节
      fseek(fp, 0L, SEEK_END); // 定位至文件结尾
      fseek(fp, -10L, SEEK_END); // 从文件结尾处回退10个字节
    #+end_src

    如果一切正常, ~fseek()~ 的返回值为 0, 如果出现错误(如: 试图移动的距离超出文件
    的范围), 其返回值为 -1.

    ~ftell()~ 函数的返回类型是 ~long~, 它返回的是当前的位置. ANSI C 把它定义在
    ~stdio.h~ 中. 在最初实现的 UNIX 中, ~ftell()~ 通过返回距文件开始处的 *字节
    数* 来确定文件的位置. 文件的第 1 个字节到文件开始处的距离是 0, 以此类推.
    ANSI C 规定, 该定义适用于以二进制模式打开的文件, 以文件模式打开的文件情况不
    同, 这也是 ~reverse.c~ 以二进制模式打开文件的原因

*** 二进制模式和文本模式
    我们设计的程序清单 ~reverse.c~ 在 UNIX 和 MS-DOS 环境下都可以运行.
    UNIX *只有一种文件格式*, 所以不需要进行特殊的转换.
    MS-DOS 要格外注意, 许多 MS-DOS 编译器都用 ~Ctrl+Z~ 标记文本文件的末尾.
    以文本模式打开这样的文件时, C 能识别这个作为文件结尾标记的字符. 但是, 以二进
    制模式打开相同的文件时, ~Ctrl+Z~ 字符被看作是文件中的一个字符, 而实际的文件
    结尾符在该字符的后面. 文件结尾符被看作是文件中的一个字符, 而实际的文件结尾符
    在该字符的后面. 文件结尾符可能紧跟在 ~Ctrl+Z~ 字符后面, 或者文件中可能用空字
    符填充, 使该文件的大小是 256 的倍数. 在 DOS 环境下不会打印空字符.

    二进制模式和文本模式的另一个不同之处是: MS-DOS 用 ~\r\n~ 组合表示文本文件换行,
    以 *文本模式* 打开相同的文件时, C 程序把 ~\r\n~ *看成* ~\n~ , 但是, *以二进
    制模式* 打开该文件时, 程序能看见这 2 个字符.

    因此, ~reverse.c~ 还包含了不打印 ~\r~ 的代码. 通常, UNIX 文本文件即没有
    ~Ctrl+Z~, 也没有 ~\r~, 所以这部分代码不会影响大部分 UNIX 文本文件.

    ~ftell()~ 函数在文本模式和二进制模式中的工作方式不同. 许多系统的文本文件格式
    与 UNIX 的模型有很大不同, 导致从文件开始处统计 IDE 字节数成为一个毫无意义的值.

    ANSI C 规定, 对于文本模式, ~ftell()~ 返回的值可以作为 ~fseek()~ 的第 2 个参数.
    
    对于 MS-DOS, ~ftell()~ 返回的值把 ~\r\n~ 当作一个字节计数.

*** 可移植性
    理论上, ~fseek()~ 和 ~ftell()~ 应该符合 UNIX 模型. 但是, 不同系统存在着差异,
    有时确实无法做到 UNIX 模型一致. 因此, ANSI 对这些函数降低了要求.

    限制: 在二进制模式中,实现不必支持 SEEK_END 模式. 因此无法保证程序清单
    ~reverse.c~ 的可移植性. 移植性更高的方法是逐字节读取整个文件直到文件末尾.

    C 预处理器的 *条件编译指令* 提供了一种系统方法来处理这种情况(16 章)

    在文本模式中, 只有以下调用能保证其相应的行为

    | 函数调用                           | 效果                                               |
    |------------------------------------+----------------------------------------------------|
    | fseek(file, 0L, SEEK_SET)          | 定位至文件开始处                                   |
    | fseek(file, 0L, SEEK_CUR)          | 保持当前位置不动                                   |
    | fseek(file, 0L, SEEK_END)          | 定位至文件结尾                                     |
    | fseek(file, ftell - pos, SEEK_SET) | 到距文件开始处 ftell-pos 的位置(该值是 ftell()返回值) |

    许多常见的环境都支持更多的行为
*** ~fgetpos()~ 和 ~fsetpost()~ 函数
    ~fseek()~ 和 ~ftell()~ 的潜在问题是, 它们都把大小限制在 long 类型能表示的范围
    内.
    long 类型可能无法描述超出字节的数目

    ANSI C 新增了 2 个处理较大文件的新定位函数: ~fgetpos()~ 和 ~fsetpos()~.
    这 2 个函数不使用 long 类型的值表示位置, 它们使用一种新的类型: ~fpos_t~ (file
    position type. 文件定位类型).

    ~fpos_t~ 类型 *不是基本类型*, 它根据其他类型来定义. ~fpos_t~ 类型的变量或数
    据对象可以在文件中指定一个位置, 它 *不能是数组类型*, 除此之外, *没有其他限
    制*. 实现可以提供一个满足特殊平台要求的类型, 例如, ~fpos_t~ 可以实现为结构

    ANSI C 定义了如何使用 fpos_t 类型. ~fgetpos()~ 函数的原型如下:

    #+begin_src c
      int fgetpos(FILE* restrict stream, fpos_t* restrict pos);
    #+end_src

    调用该函数时, 它把 ~fpos_t~ 类型的值放在 ~pos~ 指向的位置上, 该值描述了文件
    中的一个位置. 如果成功, ~fgetpos()~ 函数返回 0; 如果失败则非 0

    ~fsetpos()~ 函数的原型如下:

    #+begin_src c
      int fsetpos(FILE* stream, const fpos_t* pos);
    #+end_src

    调用该函数时, 使用 pos 指向位置上的 ~fpos_t~ 类型值来设置文件指针指向该值指定
    的位置. 如果成功, ~fsetpos()~ 函数返回 0; 如果失败, 返回非 0.
    ~fpos_t~ 类型的值应通过之前调用 ~fgetpos()~ 获得
** 标准 I/O 的机理
   本节要就一个典型的概念模型: 分析标准 I/O 的工作原理
   
   通常, 使用标准 I/O 的第 1 步是调用 ~fopen()~ 打开文件(C 程序会自动打开 3 种标准文
   件). ~fopen()~ 函数不仅打开一个文件, 还创建了一个缓冲区(在读写模式下会创建 2 个
   缓冲区)以及一个包含文件和缓冲区数据的结构. 另外, ~fopen()~ 返回一个指向该结构
   的指针, 以便其他函数知道如何找到该结构. 假设把该指针赋给一个指针变量 fp, 我们
   说 ~fopen()~ *"打开一个流"*. 如果以文本模式打开, 获得一个文本流; 如果以二进制
   模式打开, 获得一个二进制流.

   这个结构通常包含:
   - 一个指定流中当前位置的文件位置指示器.
   - 错误指示器
   - 文件结尾的指示器
   - 一个指向缓冲区开始处的指针
   - 一个文件标识符
   - 一个计数(统计实际拷贝进缓冲区的字节数)

     
   我们主要考虑文件输入. 冗长, 使用标准 I/O 的第 2 步是调用一个定义在 ~stdio.h~
   中的输入函数: 如 ~fscanf()~, ~getc()~ 或 ~fgets()~. 一调用这些函数, 文件中的
   数据块就被拷贝到缓冲区中. 缓冲区的大小因实现而异, 一般是 512 字节或是它的倍数,
   如 4096 或 16384(随着硬盘容量而增长). 最初调用函数, 除了填充缓冲区外, 还要设
   置 fp 所指向的结构中的值.
   尤其要设置流中的当前位置和拷贝进缓冲区的字节数. 通常, 当前位置从字节 0 开始.

   在初始化结构和缓冲区后, 输入函数按要求从缓冲区读取数据. 在它读取数据时, 文件
   位置指示器被设置为指向刚读取字符的下一个字符. 由于 ~stdio.h~ 系列的所有输入函
   数都使用相同的缓冲区, *所以调用任何一个函数都将从上一次函数停止调用的位置开始*.

   当输入发现已读完缓冲区中的所有字符时, 会请求把下一个缓冲大小的数据块从文件拷
   贝到该缓冲区中. 以这种方式, 输入函数可以读取文件中的所有内容, 直到文件结尾.
   函数在读取缓冲区中的最后一个字符后, 把结尾指示器设置为真. 于是, 下一次被调用
   的函数将返回 ~EOF~.

   输出函数以类似的方式把数据写入缓冲区. 当缓冲区被填满时, 数据将被拷贝至文件中
** 其他标准 I/O 的函数
   ANSI 标准库的标准 I/O 系列有几十个函数. 这里列出函数的原型, 表名函数的参数和
   返回类型. 讨论的函数中, 除了 ~setvbuf()~, 其他函数均可在 ANSI 之前的实现中使
   用.
   全部 ANSI C 标准 I/O 包见 "参考资料 5"中的 "新增 C99 和 C11 的标准 ANSI C 库"

*** ~int ungetc(int c, FILE* fp)~ 函数
    ~int ungetc()~ 函数把 c 指定的字符放回输入流中. 如果把一个字符放回输入流, 下次
    调用标准输入时将读取该字符.

    eg: 要读取下一个冒号之前的所有字符, 但是不包括冒号本身, 可以使用 ~getchar()~
    或 ~getc()~ 函数读取字符到冒号, 然后使用 ~ungetc()~ 函数把冒号放回输入流中.

    ANSI C 标准保证每次只会放回一个字符. 如果实现允许把一行中的多个字符放回输入
    流, 那么下一次输入函数读取的字符顺序与放回时的顺序相反.

*** ~int fflush()~ 函数

    原型:
    #+begin_src c
      int fflush(FILE* fp);
    #+end_src

    调用 ~fflush()~ 函数引起输出缓冲区中所有的未写入数据被发送到 fp 指定的输出文件.
    这个过程称为 *刷新缓冲区*.
    Tip: 如果 fp 是空指针, *所有缓冲区都被刷新*.

    *在输入流中使用 ~fllush()~ 函数的效果是未定义的*.

    只要最近一次操作不是输入操作, 就可偶一用该函数来更新流(任何读写模式).
*** ~int setvbuf()~ 函数
    原型:
    
    #+begin_src c
      int setvbuf(FILE* restrict fp, char* restrict buf, int mode, size_t size);
    #+end_src

    ~setvbuf()~ 函数 *创建了一个供标准 I/O 函数替换使用的缓冲区*. *在打开文件后未对流
    进行其他操作之前*, 调用该函数.

    指针 fp 识别待处理的流, buf 指向待使用的存储区. 如果 buf 的值不是 NULL, 则必须创建
    一个缓冲区. 

    eg: 声明一个内含 1024 个字符的数组, 并传递该数组的地址. 然而, 如果把数组的大小
    (~size_t~ 是一种派生的整数类型). mode 的选择如下:
    - _IOFBF: 表示完全缓冲(在缓冲区满时刷新)
    - _IOLBF: 表示行缓冲(在缓冲区满时或写入一个换行符时)
    - _IONBF: 表示无缓冲

      如果操作成功, 函数返回 0, 否则返回非 0

      
    假设程序要储存一种数据对象, 每个数据对象的大小是 3000 字节. 可以使用
    ~setvbuf()~ 函数创建一个缓冲区, 其大小是该数据对象大小的倍数
*** 二进制 I/O: ~fread()~ 和 ~fwrite()~
    之前用到的标准 I/O 函数都是面向文本的, 用于处理字符和字符串.
    如何要在文件中保存数值数据? 用 ~fprintf()~ 函数和 ~%f~ 转换说明只是把数值
    保存为字符串

    #+begin_src c
      double num = 1./3.;
      fprintf(fp, "%f", num);
    #+end_src

    把 ~num~ 储存为 8 个字符: ~0.333333~. 使用 ~%.2f~ 转换说明将其储存为 4 个字符:
    ~0.33~, 改变转换说明将改变储存该值所需的空间数量, 也会导致储存不同的值.

    把 ~num~ 储存为 ~0.33~ 后, 读取文件时就无法将其恢复为更高的精度. 一般而言,
    ~fprintf()~ 把数值转换为字符数据, *这种转换可能会改变值*

    *为保证数值在储存前后一致, 最精确的做法是使用与计算机相同的位组合来储存*.
    因此, ~double~ 类型的值应该储存在一个 ~double~ 大小的单元中.
    如果以程序所用的表示法把数据储存在文件中, 则称二进制形式储存数据.
    *不存在从数值像是到字符单词的转换过程*. 对于标准 I/O, ~fread()~ 和 ~fwrite()~
    函数用于 *以二进制形式处理数据*.

    实际上, 所有的数据 都是以二进制形式储存的, 甚至连字符都以字节码的二进制表示
    来储存. 如果文件中的所有数据都被解释成字节码, 则称该文件包含文本数据. 如果部
    分或所有的数据都被解释成二进制形式的数值数据, 则称该文件包含二进制数据(用数
    据表示及其语言指令的文件都是二进制文件)

    二进制和文本的用法很容易混淆. ANSI C 和许多操作系统都识别 2 种文件格式: 二进制
    和文本. 能以二进制数据或文本数据形式存储或读取信息. 可以用二进制模式打开文本
    格式的文件, 可以把文本储存在二进制形式的文件中. 可以调用 ~getc()~ 拷贝包含
    二进制数据的文件. 然而, 一般而言, *用二进制模式在二进制格式文件中储存二进制
    数据*. 类似地, 最常用的还是以文本格式打开文本文件中的文本数据(通常文字处理器生
    成的文件都是二进制文件, 因为这些文件中包含了大量非文本信息, 如字体和格式等)
    
*** ~size_t fwrite()~ 函数
    原型:
    #+begin_src c
      size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp);
    #+end_src

    ~fwrite()~ 把二进制数据写入文件. ~size_t~ 是根据标准 C 类型定义的类型, 它是
    ~sizeof~ 运算符返回的类型, 通常是 ~unsigned int~.
    指针 ~ptr~ 是待写入数据块的地址. ~size~ 表示待写入数据块的大小(以字节为单
    位), ~nmemb~ 表示待写入数据块的数量. 和其他函数一样, ~fp~ 指定待写入的文件.red
    
    eg: 要保存一个大小为 256 字节的数据对象(如数组):
    #+begin_src c
      char buffer[256];
      fwrite(buffer, 256, 1, fp);
    #+end_src

    以上调用把 1 块 256 字节的数据从 buffer 写入文件. 

    eg: 保存一个内含 10 个 double 类型值的数组:
    #+begin_src c
      double earnings[10];
      fwrite(earnings, sizeof(double), 10, fp);
    #+end_src

    以上调用把 ~earnings~ 数组中的数据写入文件, *数据被分成 10 块*, 每块都是 double
    的大小

    注意: ~fwrite()~ 原型中的 ~const void* restrict ptr~ 声明. ~fwrite()~ 的一个
    问题是: *第 1 个参数不是固定的类型*.

    在 ANSI C 函数原型中, 这些实际参数都被转换成指向 ~void~ 的指针类型, 这种指针可
    作为一种 *通用类型指针* (ANSI C 之前, 这些参数使用 ~char*~ 类型, 需要把实参强
    制转换成 ~char*~ 类型)

    ~fwrite()~ 函数返回成功写入项的数量. 正常情况下, 该返回值就是 ~nmemb~, 如果
    出现错误, 返回值会比 ~nmemb~ 小

*** ~size_t fread()~ 函数
    原型:
    #+begin_src c
      size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp);
    #+end_src

    ~fread()~ 函数接受的参数和 ~fwrite()~ 函数相同. 在 ~fread()~ 函数中, ~ptr~
    是待读取文件数据在内存中的地址, ~fp~ 指定待读取的文件. 该函数用于读取被
    ~write()~ 写入文件的数据.

    eg: 要恢复上例中保存的内含 10 个 ~double~ 类型值的数组:
    #+begin_src c
      double earnings[10];
      fread(earnings, sizeof(double), 10, fp);
    #+end_src

    该调用把 10 个 ~double~ 大小的值拷贝进 ~earnings~ 数组中
    
    ~fread()~ 函数返回成功读取项的数量. 
    正常情况下, 该返回值就是 ~nmemb~, 若出现读取错误或读到文件结尾, 该返回值就会
    比 ~nmemb~ 小
*** ~int feof(FILE* fp)~ 和 ~int ferror(FILE* fp)~ 函数
    如果标准输入函数返回 ~EOF~, 则通常表明函数已到达文件结尾. 然而, 出现读取错误
    时, 函数也会返回 ~EOF~.
    
    ~feof()~ 和 ~ferror()~ 函数用于区分这 2 种情况: (相当于 if 判断)

    *当上一次输入调用检查到文件结尾时*, ~feof()~ 函数返回一个 *非 0 值*

    *当读或写出现错误*, ~ferror()~ 函数返回一个 *非 0 值*
*** 程序示例
    该程序把一系列文件中的内容附加在另一个文件的末尾.

    该程序存在一个问题: 如何给文件传递信息. 可以通过交互或使用命令行参数完成.

    设计方案:

    1. 询问模板文件的名称来打开它
    2. 使用一个循环询问源文件
    3. 以读模式依次打开每个源文件, 并将其添加到模板文件的末尾.
       
    为演示 ~setvbuf()~ 函数的用法, 该程序将使用它指定一个不同的缓冲区大小.

    细化程序打开模板文件的步骤:
    1. 以附加模式打开模板文件
    2. 如果打开失败, 则退出程序
    3. 为该文件创建一个 4096 字节的缓冲区
    4. 如果创建失败, 则退出程序

    细化拷贝部分:
    1. 如果该文件与模板文件相同, 则跳至下一个文件
    2. 如果以读模式打开文件, 则跳至下一个文件
    3. 把文件内容添加至模板文件末尾

    最后, 程序回到目标文件的开始处, 显示当前整个文件的内容
    使用 ~fread()~ 和 ~fwrite()~ 函数进行拷贝

    代码文件: ~append.c~
*** 用二进制 I/O 进行随机访问
    创建一个储存 ~double~ 类型数字的文件, 然后让用户访问这些内容: 
    程序代码: ~randbin.c~
** 关键概念
   C 程序把输入看作是 *字节流*, 输入流来源于 文件, 输入设备(如键盘), 或者甚至是另
   一个程序的输出.

   C 程序把输出也看作是字节流, 输出流的目的地可以是文件, 视频显示等.

   C 如何解释输入流/输出流取决于所使用的输入/输出函数. 程序可以不做任何改动地读取
   和存储字节, 或者把字节一次解释成字符, 随后可以把这些字符解释成普通文本以用文
   本表示数字. 类似地, 对于输出, 所使用的函数决定了 *二进制是被原样转移*, 还是
   *被转换成文本或以文本表示数字*. 如果要在 *不损失精度的前提下保存或恢复数值数
   值*, 请使用 *二进制模式* 以及 ~fread()~ 和 ~fwrite()~ 函数.
   如果打算保存文本信息并创建能在普通文本编辑器查看的文本, 请使用文本模式和函数
   (~getc()~, ~frprintf()~ 等)

   要访问文件, 必须创建文件指针(类型是 FILE*), 并把指针与特定文件名相关联. 随后的
   代码就可以时候用这个指针来处理文件.

   *重点理解 C 如何处理文件结尾*: 通常, 用于读取文件的程序使用一个循环读取输入, 直至文件
    结尾. C 输入函数在读过文件解围后才会检测到文件结尾, 这意味着 *应该在尝试读取
    之后立即判断是否是文件结尾*. 可以使用双文件输入模式

** 本章小结
   大多数 C 程序而言, 写入文件和读取文件必不可少. 为此, 绝大多数 C 实现都提供底
   层 I/O 和标准高级 I/O. 因为 ANSI C 库考虑可移植性, 包含了标准 I/O 包, 但是未提供底层
   I/O.

   标准 I/O 包自动创建输入和输出缓冲区以加快数据传输. ~fopen()~ 函数为标准 I/O 打开
   一个文件, 并创建一个用于存储文件和缓冲区信息的结构, 并返回指向该结构的指针. 
   ~feof()~ 和 ~ferror()~ 函数报告 I/O 操作失败的原因

   C 把输入视为字节流. 如果使用 ~fread()~, C 把输入看作是二进制值并将其储存在指定
   存储位置. 如果使用 ~fscanf()~, ~getc()~, ~fgets()~ 或其他相关函数, C 则将每个
   字节看作是 *字符码*. 然后 ~fscanf()~ 和 ~scanf()~ 函数尝试把字符码翻译成转换
   说明指定的其他类型.

   eg: 输入一个值 23, ~%f~ 转换说明会把 23 发怒以诚一个浮点值, ~getc()~ 和
   ~fgetc()~ 系列函数把输入作为字节码储存, 将其作为单独的字符保存在字符变量中或
   作为字符串储存在字符数组中. 类似的, ~fwrite()~ 将二进制数据直接放入输入流, 而
   其他输出函数把费字符数据转换成字符后才将其放入输入流.

   ANSI C 提供 2 种文件打开模式: 二进制和文本. 以二进制打开时, 可以逐字节读取文件;
   以文本模式打开时, 会把文本内容从文本的系统表示法映射为 C 表示法. 对于 UNIX 和
   Linux 系统, 这 2 种模式完全相同.

   ~fseek()~ 和 ~ftell()~ 函数让程序可以随机访问文件中的任意位置, ~fgetpos()~ 和
   ~fsetpos()~ 把类似的功能扩展至更大的文件. 

   *与文本模式相比, 二进制模式更容易进行随机访问*
** 复习题
   1. 见 ~res1.c~, fp 声明错误, 应为 ~FILE*~ 类型, ~fopen()~ 调用参数不对, 缺少模式, ~fputs~
      参数顺序错误, fclose 错误, 参数应为 fp 指针
   2. 见 ~res2.c~, 读取传入参数的文件中的所有数字, 并打印到 stdout
   3. 见 ~res3.c~
   4. 见 ~res4.c~
   5. 见 ~res5.c~
   6. 解答:
      1) 用数据表示语言及其语言指令的文件都是二进制文件, 所有数据都被解释成字节码是文本文件
      2) 如果使用 ~fopen()~ 以文本模式打开, 就能获得一个文本流, 以二进制打开就获
         得一个二进制流, 二进制流中, 程序可以访问文件的每个字节, 文本模式中, 程
         序缩减的内容和文件的实际内容不同
   7. 解答:
      1) ~fprintf()~ 把数值保存为字符串, ~fwrite()~ 把数值保存为二进制
      2) ~putc()~ 把数值保存为字符, ~fwrite()~ 把数值保存为二进制
   8. 解答:
      1) 在 stdout 打印 Hello, name
      2) 与第一种相同
      3) 以 error 形式打印 Hello, name
   9. "r+"
** 编程练习
   1. 见 ~practice1.c~
   2. 见 ~practice2.c~
   3. 见 ~practice3.c~
