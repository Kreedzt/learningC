* 第 15 章 位操作
  本章介绍以下内容:

  - 运算符: ~~~, ~&~, ~|~, ~^~, ~<<~, ~>>~, ~&=~, ~|=~, ~^=~, ~>>=~, ~<<=~

  - 二进制, 十进制和十六进制计数法(复习)

  - 处理一个值中的位的 2 个 C 工具: 为运算符和位字段

  - 关键字: ~_Alignas~, ~_Alignof~

** 二进制数, 位和字节
   通常都是基于数字 10 来书写数字.

   例: 
   #+begin_example
     2 * 1000 + 1 * 100 + 5 * 10 + 7 * 1
   #+end_example

   #+begin_example
     2 * 10^3 + 1 * 10^2 + 5 * 10^1 + 7 * 10^0
   #+end_example

   然而计算机适合基底为 2 的数制系统. 它用的 2 的 幂而不是 10 的幂.

   以 2 为基底表示的数字被陈伟二进制数(binary number).

   用二进制系统可以把任意整数(如果有足够的位)表示为 0 和 1 的组合.
   由于数字计算机通过关闭和打开状态的组合来表示信息, 这 2 种状态分别用 0 和 1 来
   表示, 所以使用这套数制系统非常方便.

*** 二进制整数
    通常, 1 字节包含 8 位. C 语言用 *字节(byte)* 表示储存系统字符集所需的大小,
    所以 C 字节可能是其他值. 描述存储期芯片和数据传输率中所用的字节指的是 8 位字
    节.

    为了简化起见, 本章假设 1 字节是 8 位. 可以从左往右给这 8 位分别编号为 7 ~ 0.
    在 1 字节中, 编号是 7 的位被称为 *高阶位(high-order bit)*. 编号是 0 的位被称
    为 *低阶位(low-order bit)*. 每 1 位的编号对应 2 的相应指数.

    | 位编号 |   7 |  6 |  5 |  4 | 3 | 2 | 1 | 0 |
    | 二进制 |   0 |  1 |  0 |  0 | 1 | 0 | 0 | 1 |
    | 位值   | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |

    因此, 一字节(8 位) 可以储存 0~255 返回内的数字, 总共 256 个值. 或者, 通过不
    同方式解释 *位组合(bit pattern)*, 程序可以用 1 字节储存 -128 ~ +127 范围内的
    整数, 总共还是 256 个值. 

    eg: ~unsigned char~ 用 1 字节表示的范围是 0 ~ 255, ~singed char~ 用 1 字节表
    示的范围是 -128 ~ +127

*** 有符号整数
    如何表示有符号整数取决于 *硬件*, 而不是 C 语言.
    通常都是用 1 位(eg: 高阶位)储存符号, 只剩下 7 位表示数字本身.

    用这种 *符号量(sign-magnitude)* 表示法, ~10000001~ 表示 -1, ~00000001~ 表
    示 1.

    这种方法的缺点是有 2 个 0: +0 和 -0. 这很容易混淆. 而且用 2 个位组合来表示一
    个值也有些浪费

    *二进制补码(two's-complement)* 方法避免了这个问题, 是当今最常用的系统.

    二进制补码用 1 字节中的后 7 位表示 0 ~ 127, 高阶位设置为 0. 目前, 这种方法和
    符号量的方法相同. 另外, 如果高阶位是 1, 表示的值为负.

    从一个 9 位组合 100000000(256 的二进制形式) 减去一个附属的位组合, 结果是该负
    值的量. 
    eg: 假设一个负值的位组合是 10000000, 作为一个无符号字节, 该组合位表示 128,
    作为一个有符号值, 该组合表示负值, 而且值为 100000000 - 10000000, 即
    10000000(128), 因此, 该数是 -128 *在符号量表示法中, 该位组合表示 -0. 类似地,
    10000001 表示 -127, 11111111 是 -1. 该方法可以表示 -128 ~ +127 范围内的数

    要得到一个 二进制补码的相反数, 最简单的方法是 *反转每一位*, 然后加 1. 
    eg:  1 是 0000001, 那么 -1 则是 11111110 + 1, 或 11111111, 这与上面一致

    二进制反码(one's-complement)  方法通过反转位组合中的每一位形成一个负数.
    eg: 00000001 是 1, 那么 11111110 是 -1. 这种方法也有一个 -0: 11111111. 该方
    法能表示 -127 ~ +127 之间的数
*** 二进制浮点数
    浮点数分 2 部门储存: 二进制小数和二进制指数. 
    
**** 二进制小数
     eg: 0.527
     #+begin_example
       5/10 + 2/100 + 7/1000
     #+end_example

     从左往右, 各分母都是 10 的递增次幂. 在二进制小数中, 使用 2 的幂作为分母.

     所以二进制小数 .101 表示为:
     #+begin_example
       1/2 + 0/4 + 1/8
     #+end_example
     
     十进制法表示为:
     #+begin_example
       0.50 + 0.00 + 0.125
     #+end_example

     即为 0.625

     许多分数(eg: 1/3) 不能用十进制表示法精确地表示. 类似, *许多分数也不能用二进
     制表示法准确地表示*. 实际上, 二进制表示法只能准确地表示多个 1/2 的幂的和.
     因此, 3/4 和 7/8 可以精确地表示为二进制小数, 但是 1/3 和 2/5 却不能

**** 浮点数表示法
     为了在计算机中表示一个浮点数, 要 *留出若干位(系统差异) 储存二进制分数*, *其
     他位储存指数*. 一般而言, 数字的实际值是由二进制小数乘以 2 的指定次幂组成.

     eg: 一个浮点数乘以 4, 那么二进制小数不变, 其指数乘以 2, 二进制分数不变. 如
     果一份浮点数乘以一个不是 2 的幂的数, 会改变二进制小数部分, 如有必要, 也会改
     变指数部分

** 其他进制数
   计算机界通常使用 8 进制和 16 进制计数系统. 因为 8 和 16 都是 2 的幂, 这些系统
   比十进制系统更接近计算机的二进制系统

*** 八进制
    八进制是指 8 进制计数系统. 该系统基于 8 的幂, 用 0~7 表示数字

    了解 8 进制的一个简单的方法是: 每个 8 进制位对应 3 个二进制位. 这种关系使得
    8 进制与 2 进制之间的转换很容易

    | 八进制位 | 等价的二进制位 | 八进制位 | 等价的二进制位 |
    |----------+----------------+----------+----------------|
    |        0 |            000 |        4 |            100 |
    |        1 |            001 |        5 |            101 |
    |        2 |            010 |        6 |            110 |
    |        3 |            011 |        7 |            111 |

*** 十六进制    
    十六进制是指 16 进制计数系统. 该系统基于 16 的幂, 用 0~15 表示数字. 但是由于
    没有单独的数表示 10~15, 所以用字母 A~F 表示

    每个 16 进制位都对应一个 4 位的二进制数, 那么 2 个 16 进制位恰好对应一个 8
    位字节. 因此 *十六进制很适合表示字节值*

    | 十进制 | 十六进制 | 等价二进制 | 十进制 | 十六进制 | 等价二进制 |
    |--------+----------+------------+--------+----------+------------|
    |      0 |        0 |       0000 |      8 | 8        |       1000 |
    |      1 |        1 |       0001 |      9 | 9        |       1001 |
    |      2 |        2 |       0010 |     10 | A        |       1010 |
    |      3 |        3 |       0011 |     11 | B        |       1011 |
    |      4 |        4 |       0100 |     12 | C        |       1100 |
    |      5 |        5 |       0101 |     13 | D        |       1101 |
    |      6 |        6 |       0110 |     14 | E        |       1110 |
    |      7 |        7 |       0111 |     15 | F        |       1111 |

    C 有 2 个操控位的工具, 第一个是一套(6 个)作用于位的 *按位运算符*. 第二个工具
    是 *字段(field)* 的数据形式, 用于访问 int 中的位
