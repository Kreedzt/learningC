* 第 15 章 位操作
  本章介绍以下内容:

  - 运算符: ~~~, ~&~, ~|~, ~^~, ~<<~, ~>>~, ~&=~, ~|=~, ~^=~, ~>>=~, ~<<=~

  - 二进制, 十进制和十六进制计数法(复习)

  - 处理一个值中的位的 2 个 C 工具: 为运算符和位字段

  - 关键字: ~_Alignas~, ~_Alignof~

** 二进制数, 位和字节
   通常都是基于数字 10 来书写数字.

   例: 
   #+begin_example
     2 * 1000 + 1 * 100 + 5 * 10 + 7 * 1
   #+end_example

   #+begin_example
     2 * 10^3 + 1 * 10^2 + 5 * 10^1 + 7 * 10^0
   #+end_example

   然而计算机适合基底为 2 的数制系统. 它用的 2 的 幂而不是 10 的幂.

   以 2 为基底表示的数字被陈伟二进制数(binary number).

   用二进制系统可以把任意整数(如果有足够的位)表示为 0 和 1 的组合.
   由于数字计算机通过关闭和打开状态的组合来表示信息, 这 2 种状态分别用 0 和 1 来
   表示, 所以使用这套数制系统非常方便.

*** 二进制整数
    通常, 1 字节包含 8 位. C 语言用 *字节(byte)* 表示储存系统字符集所需的大小,
    所以 C 字节可能是其他值. 描述存储期芯片和数据传输率中所用的字节指的是 8 位字
    节.

    为了简化起见, 本章假设 1 字节是 8 位. 可以从左往右给这 8 位分别编号为 7 ~ 0.
    在 1 字节中, 编号是 7 的位被称为 *高阶位(high-order bit)*. 编号是 0 的位被称
    为 *低阶位(low-order bit)*. 每 1 位的编号对应 2 的相应指数.

    | 位编号 |   7 |  6 |  5 |  4 | 3 | 2 | 1 | 0 |
    | 二进制 |   0 |  1 |  0 |  0 | 1 | 0 | 0 | 1 |
    | 位值   | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |

    因此, 一字节(8 位) 可以储存 0~255 返回内的数字, 总共 256 个值. 或者, 通过不
    同方式解释 *位组合(bit pattern)*, 程序可以用 1 字节储存 -128 ~ +127 范围内的
    整数, 总共还是 256 个值. 

    eg: ~unsigned char~ 用 1 字节表示的范围是 0 ~ 255, ~singed char~ 用 1 字节表
    示的范围是 -128 ~ +127

*** 有符号整数
    如何表示有符号整数取决于 *硬件*, 而不是 C 语言.
    通常都是用 1 位(eg: 高阶位)储存符号, 只剩下 7 位表示数字本身.

    用这种 *符号量(sign-magnitude)* 表示法, ~10000001~ 表示 -1, ~00000001~ 表
    示 1.

    这种方法的缺点是有 2 个 0: +0 和 -0. 这很容易混淆. 而且用 2 个位组合来表示一
    个值也有些浪费

    *二进制补码(two's-complement)* 方法避免了这个问题, 是当今最常用的系统.

    二进制补码用 1 字节中的后 7 位表示 0 ~ 127, 高阶位设置为 0. 目前, 这种方法和
    符号量的方法相同. 另外, 如果高阶位是 1, 表示的值为负.

    从一个 9 位组合 100000000(256 的二进制形式) 减去一个附属的位组合, 结果是该负
    值的量. 
    eg: 假设一个负值的位组合是 10000000, 作为一个无符号字节, 该组合位表示 128,
    作为一个有符号值, 该组合表示负值, 而且值为 100000000 - 10000000, 即
    10000000(128), 因此, 该数是 -128 *在符号量表示法中, 该位组合表示 -0. 类似地,
    10000001 表示 -127, 11111111 是 -1. 该方法可以表示 -128 ~ +127 范围内的数

    要得到一个 二进制补码的相反数, 最简单的方法是 *反转每一位*, 然后加 1. 
    eg:  1 是 0000001, 那么 -1 则是 11111110 + 1, 或 11111111, 这与上面一致

    二进制反码(one's-complement)  方法通过反转位组合中的每一位形成一个负数.
    eg: 00000001 是 1, 那么 11111110 是 -1. 这种方法也有一个 -0: 11111111. 该方
    法能表示 -127 ~ +127 之间的数
*** 二进制浮点数
    浮点数分 2 部门储存: 二进制小数和二进制指数. 
    
**** 二进制小数
     eg: 0.527
     #+begin_example
       5/10 + 2/100 + 7/1000
     #+end_example

     从左往右, 各分母都是 10 的递增次幂. 在二进制小数中, 使用 2 的幂作为分母.

     所以二进制小数 .101 表示为:
     #+begin_example
       1/2 + 0/4 + 1/8
     #+end_example
     
     十进制法表示为:
     #+begin_example
       0.50 + 0.00 + 0.125
     #+end_example

     即为 0.625

     许多分数(eg: 1/3) 不能用十进制表示法精确地表示. 类似, *许多分数也不能用二进
     制表示法准确地表示*. 实际上, 二进制表示法只能准确地表示多个 1/2 的幂的和.
     因此, 3/4 和 7/8 可以精确地表示为二进制小数, 但是 1/3 和 2/5 却不能

**** 浮点数表示法
     为了在计算机中表示一个浮点数, 要 *留出若干位(系统差异) 储存二进制分数*, *其
     他位储存指数*. 一般而言, 数字的实际值是由二进制小数乘以 2 的指定次幂组成.

     eg: 一个浮点数乘以 4, 那么二进制小数不变, 其指数乘以 2, 二进制分数不变. 如
     果一份浮点数乘以一个不是 2 的幂的数, 会改变二进制小数部分, 如有必要, 也会改
     变指数部分

** 其他进制数
   计算机界通常使用 8 进制和 16 进制计数系统. 因为 8 和 16 都是 2 的幂, 这些系统
   比十进制系统更接近计算机的二进制系统

*** 八进制
    八进制是指 8 进制计数系统. 该系统基于 8 的幂, 用 0~7 表示数字

    了解 8 进制的一个简单的方法是: 每个 8 进制位对应 3 个二进制位. 这种关系使得
    8 进制与 2 进制之间的转换很容易

    | 八进制位 | 等价的二进制位 | 八进制位 | 等价的二进制位 |
    |----------+----------------+----------+----------------|
    |        0 |            000 |        4 |            100 |
    |        1 |            001 |        5 |            101 |
    |        2 |            010 |        6 |            110 |
    |        3 |            011 |        7 |            111 |

*** 十六进制    
    十六进制是指 16 进制计数系统. 该系统基于 16 的幂, 用 0~15 表示数字. 但是由于
    没有单独的数表示 10~15, 所以用字母 A~F 表示

    每个 16 进制位都对应一个 4 位的二进制数, 那么 2 个 16 进制位恰好对应一个 8
    位字节. 因此 *十六进制很适合表示字节值*

    | 十进制 | 十六进制 | 等价二进制 | 十进制 | 十六进制 | 等价二进制 |
    |--------+----------+------------+--------+----------+------------|
    |      0 |        0 |       0000 |      8 | 8        |       1000 |
    |      1 |        1 |       0001 |      9 | 9        |       1001 |
    |      2 |        2 |       0010 |     10 | A        |       1010 |
    |      3 |        3 |       0011 |     11 | B        |       1011 |
    |      4 |        4 |       0100 |     12 | C        |       1100 |
    |      5 |        5 |       0101 |     13 | D        |       1101 |
    |      6 |        6 |       0110 |     14 | E        |       1110 |
    |      7 |        7 |       0111 |     15 | F        |       1111 |

    C 有 2 个操控位的工具, 第一个是一套(6 个)作用于位的 *按位运算符*. 第二个工具
    是 *字段(field)* 的数据形式, 用于访问 int 中的位
** C 按位运算符
   C 提供 *按位运算符* 和 *移位运算符*. 为了方便了解, 用二进制记数法写出值.

*** 按位逻辑运算符
    4 个按位逻辑运算符都用于整形数据, 包括 ~char~. 之所以叫作按位(bitwise)运算,
    是因为这些操作都是 *针对每一个位进行*, 不影响它左右两边的位. 不要把这些运算符与
    常见的逻辑运算符(&&, || 和 !) 混淆, 常规的逻辑运算符操作的是 *整个值*

**** 二进制反码或按位取反: ~~~

     一元运算符 ~~~ 把 1 变 0, 把 0 变为 1.

     eg:
     #+begin_example
       ~(10011010) // 表达式
       (01100101) // 结果值
     #+end_example

     假设 ~val~ 的类型是 ~unsigned char~, 已被赋值为 2, 在二进制中, ~00000010~
     表示 2. 那么 ~~val~ 的值是 ~11111101~, 即 253.

     注意: 该运算符 *不会改变原始值* (val 的值). 但确实创造了一个新值

     
**** 按位与: ~&~

     二元运算符, 逐位比较运算对象, 生成一个新值.
     只有当 2 个运算对象中相应的位都为 1 时, 结果才为 1

     eg:
     #+begin_example
       (10010011) & (00111101) // 表达式
       (00010001) // 结果值
     #+end_example

     C 语言有一个按位与和赋值结合的运算符: ~&=~, 以下 2 句结果相同
     #+begin_src c
       val &= 0377;
       val = val & 0377;
     #+end_src

     
**** 按位或: ~|~

     二元运算符, 逐位比较运算对象, 生成一个新值
     对于每个位, 如果两个运算对象中相应的位为 1, 结果就有 1.

     eg:
     #+begin_example
       (10010011)|(00111101) // 表达式

       (10111111) // 结果值
     #+end_example

     C 有一个按位或和赋值结合的运算符: ~|=~, 以下 2 句结果相同
     #+begin_src c
       val |= 0377;
       val = val | 0377;
     #+end_src

     
**** 按位异或: ~^~
     二元运算符, 逐位比较 2 个运算对象, 如果 2 个运算对象中相应的仅有 1 个位为 1
     (并非都为 1), 结果为 1

     eg:
     #+begin_example
       (10010011)^(00111101) // 表达式
       (10101110) // 结果值
     #+end_example

     C 有一个按位异或和赋值结合的运算符: ~^=~, 以下 2 句结果相同
     #+begin_src c
       val ^= 0377;
       val = val^0377;
     #+end_src
     
*** 用法: 掩码
    按位与运算符常用语掩码(mask). 所谓掩码指的是一些设置为开(1)或关(0)的位组合

    挺高 ~&~ 把一个量与掩码结合后发生的情况:
    eg: 定义符号常量 ~MASK~ 为 2(即为 00000010), 只有 1 号位 是 1.

    #+begin_src c
      flags = flags & MASK;
    #+end_src

    把 ~flags~ 中除 1 号位意外的所有位都设置为 0, 因为使用按位与运算符 (~&~)任何
    位与 0 组合都得 0. 1 号位的值不变

    这个过程叫做 "使用掩码", 因为掩码中的 0 隐藏了 ~flags~ 中响应的位.

    可以这样类比: 把掩码中的 0 看作不透明, 1 看作透明. 表达式 ~flags & MASK~ 相
    当于用掩码覆盖在 ~flags~ 的位组合上, 只有 ~MASK~ 为 1 的位才可见

    用 ~&=~ 运算符可以简化:
    #+begin_src c
      flags &= MASK;
    #+end_src

    按位与常见用法:
    #+begin_src c
      ch &= 0xff; // ch &= 0377;
    #+end_src
    
    ~0xff~ 的二进制形式是 ~11111111~, 八进制形式是 ~0377~, 这个掩码标尺 ~ch~ 中
    最后 8 位不变, 其他位都设置 0. 无论 ~ch~ 原来是 8 位, 16 位, 或是更多位, 最
    终的值 *都被修改为 1 个 8 位字节*. 该例中, 掩码的宽度为 8 位
*** 用法: 打开位(设置位)
    有时, 需要打开一个值中的特定位, 同时保持其他位不变.
    eg: 一台 IBM PC 通过端口发送值来控制硬件.
    eg2: 为了打开内置扬声器, 必须打开 1 号位, 同时保持其他位不变.

    该情况可以使用按位或运算符 (|)

    以上一节的 ~flags~ 和 ~MASK~ (只有 1 号 位 为 1)为例, 下面的语句:
    #+begin_src c
      flags = flags | MASK;
    #+end_src

    把 ~flags~ 的 1 号 位设置为 1, 其他位不变.

    用 ~|=~ 可以简化:
    #+begin_src c
      flags |=  MASK;
    #+end_src
*** 用法: 关闭位(清空位)
    和打开特定的位类似, 有时也需要在 *不影响其他位的情况下关闭指定的位*. 

    eg: 要关闭变量 ~flags~ 中的 1 号位. 可以这样做:
    #+begin_src c
      flags = flags & ~MASK;
    #+end_src

    由于 ~MASK~ 除一号位 1 以外, 其他位全为 0, 所以 ~~MASK~ 除 1 号位为 0, 其他
    都是 1. 使用 ~&~, 只改变 1 号位为 0

    简化形式:
    #+begin_src c
      flags &= ~MASK;
    #+end_src

*** 用法: 切换位
    切换位指的是 *打开已关闭的位*, 或关闭已打开的位. 可以用 按位异或运算符(~^~)
    切换位

    eg: b 是一个位 (1 或 0), 如果 b 为 1, 则 1^b 为 0, 如果 b 为 0, 则 1^b 为 1.

    因此, 使用 ~^~ 组合一个值和一个掩码, 将切换该值与 ~MASK~ 为 1 的位相对应的位.

    #+begin_src c
      flags = flags ^ MASK;
      // 等价
      flags ^= MASK;
    #+end_src
    
*** 用法: 检查位的值
    eg: ~flags~ 中 1 号位的值是否为 1

    必须覆盖 ~flags~ 中的其他位, 只用 1 号位和 ~MASK~ 比较:
    #+begin_src c
      if ((flags & MASK) == MASK)
        puts("Wow!");
    #+end_src
    
    由于按位运算符优先级比 ~==~ 低, 所以需要加上圆括号
    
*** 移位运算符
    1. 左移: ~<<~
       左移运算符将其左侧运算符对象 *每一位的值向左移动其右侧运算对象指定的位数
       *. 
       左侧运算对象移出左末端位的值丢失, 用 0 填充空出的位置
       #+begin_example
         (10001010) << 2 // 表达式
         (00101000) // 结果值
       #+end_example
    
       该操作符产生了一个新的位值, 但是不改变其运算对象.
       eg: ~stonk~ 为 1, 那么 ~stonk<<2~ 为 4, 但是本身不变. 可以使用左移赋值运
       算符(~<<=~) 来改变变量的值. 

       #+begin_src c
         int stonk = 1;
         int onkoo;
         onkoo = stonk << 2; // 把 4 赋给 onkoo
         stonk <<= 2; // 把 stonk 的值改为 4
       #+end_src

    2. 右移: ~>>~
       右移运算符将其左侧运算对象的每一位的值向右移动其右侧运算对象指定的位数.
       左侧运算对象移出右末端位的值丢. 
       对于无符号类型, 用 0 填充空出的位置; *对于有符号类型, 结果取决于机器*. 空
       出的位置可用 0 填充, 或者用符号位(即: 最左端的位)的副本填充.

       有符号:
       #+begin_example
         (10001010) >> 2 // 表达式, 有符号值
         (00100010) // 在某些系统中的值
         (10001010) >> 2 // 表达式, 有符号值
         (11100010) // 在另一些系统上的结果值
       #+end_example
       
       无符号:
       #+begin_example
         (10001010) >> 2 // 表达式, 无符号值
         (00100010) // 所有系统都得到该结果值
       #+end_example

       每个位向右移动 2 个位置, 空出的位用 0 填充.

       右移赋值运算符(~>>=~) 将其左侧的变量向右移动指定数量的位数.

       #+begin_src c
         int sweet = 16;
         int ooosw;

         ooosw = sweet >> 3; // ooosw = 2, sweet 的值仍然为 16

         sweet >>= 3; // sweet 的值为 2
       #+end_src

    3. 用法: 移位运算符
       移位运算符可针对 2 的幂提供快速有效的乘法和除法

       #+begin_src c
         number << n; // number 乘以 2 的 n 次幂
         number >> n; // 如果 numnber 为 非负, 则用 number 除以 2 的 n 次幂
       #+end_src

       这些移位运算符类似于在十进制中移动小数点来乘以或除以 10

       移位运算符还可用于 *从较大单元中提取一些位*.

       eg: 用一个 ~unsigned long~ 类型的值表示颜色值, 低阶位字节 储存红色的强度,
       下一个字节储存绿色的强度, 第 3 个字节储存蓝色的强度, 随后希望把每种颜色的
       强度分别储存在 3 个不同的 ~unsigned char~ 类型的变量中

       #+begin_src c
         #define BYTE_MASK 0xff
         unsigned long color = 0x002a162f;
         unsigned char blue, green, red;

         red = color & BYTE_MASK;
         green = (color >> 8) & BYTE_MASK;
         blue = (color >> 16) & BYTE_MASK;
       #+end_src

       以上代码中, 使用右移运算符将 8 位颜色值移动至低阶字节, 然后使用掩码技术把
       低阶字节赋给指定的变量
*** 编程示例
    在第 9 章中, 我们用递归编写了一个把数字转换为二进制形式的程序. 现在, 要用移
    位运算符来解决相同的问题.

    ~binbit.c~ 中, 读取用户从键盘输入的整数, 将该整数和一个字符串地址传递给
    ~itob()~ 函数(interger to binary string, 整数转换成二进制字符串). 然后, 该函
    数使用移位运算符计算出正确的 10 组合, 并将其放入字符串中


    ~limits.h~ 中 ~CHAR_BIT~ 宏表示 ~char~ 中的位数. ~sizeof~ 运算符返回 ~char~
    的大小, 所以 ~CHAR_BIT * sizeof(int)~ 表示 ~int~ 类型的位数. ~bin_str~ 数组
    的元素个数是 ~CHAR_BIT * sizeof(int) + 1~, 留一个位置给末尾空字符

    ~itobs()~ 函数返回的地址与传入的地址相同, 可以把该函数作为 ~printf()~ 的参数.
    在该函数中, 首次执行 ~for~ 循环时, 对 ~01 & n~ 求值, ~01~ 是一个八进制形式的
    掩码, 该掩码除了 0 号位是 1 以外, 其他所有位都为 0. 因此, ~01 & n~  就是 ~n~
    最后一位的值. 该值为 0 或 1. 但是对数组而言, 需要的是 字符 ~'0'~ 或字符
    ~'1'~.
    加上 ~'0'~ 完成转换. 其结果存放在数组中倒数第二个元素中(最后一个元素用来存放
    空字符).

    Tips: 使用 ~1 & n~ 也可代替 ~01 & n~

    然后, 循环执行: ~i--~ 移动到数组的前一个元素, ~n >>= 1~ 使 ~n~ 中的所有位向
    右移动一个位置, 进入下一轮迭代时, 循环中处理的是 ~n~ 中新的最右端的值. 
    以此类推, ~itobs()~ 函数用这种方式从右往左填充数组

*** 另一个例子
    编写用于切换一个值中的后 ~n~ 位, 待处理值和 ~n~ 都是函数的参数

    ~~~ 运算符切换一个字节的所有位, 而不是选定的少数位. 但是 ~^~ 运算符(按位异或)可
    用于切换单个位. 
    eg: 创建了一个掩码, 把后 ~n~ 位设置为 1, 其余位设置为 0. 然后使用 ~^~ 组合掩
    码和待切换的值便可切换该值的最后 ~n~ 位, 而且其他位不变.

    #+begin_src c
      int invert_end(int num, int bits)
      {
        int mask = 0;
        int bitval = 1;

        while (bits-- > 0) {
          mask |= bitval;
          bitval <<= 1;
        }

        return num ^ mask;
      }
    #+end_src

    ~while~ 循环用于创建所需的掩码.
    步骤:
    1. ~mask~ 所有位都为 0
    2. 第一轮循环: ~mask~ 的 0 号位设置为 1, 以此类推. bits 次后, 后 bits 位都为 1
    3. ~num ^ mask~ 运算得结果
** 位字段
   操作为的第 2 种方法是位字段(bit field). 位字段是一个 ~signed int~ 或
   ~unsigned int~ 类型变量中的一组相邻的位 (C99 和 C11 新增了 ~_Bool~ 类型的位字
   段). 位字段通过一个结构声明来建立, 该结构声明为每个字段提供标签, 并确定该字段
   的宽度.

   eg: 以下声明建立了一个 4 个 1 位的字段:
   #+begin_src c
     struct
     {
       unsigned int autfd : 1;
       unsigned int bldfc : 1;
       unsigned int undln : 1;
       unsigned int itals : 1;
     } prnt;
   #+end_src

   根据该声明, ~prnt~ 包含 4 个 1 位的字段. 现在, 可以通过普通的结构成员运算符
   (~.~) 单独给这些字段赋值:
   #+begin_src c
     prnt.itals = 0;
     prnt.undln = 1;
   #+end_src

   由于每个字段恰好为 1 位, 所以只能为其赋值 1 或 0. 变量 ~prnt~ 被储存在 ~int~
   大小的内存单元中, 但是在本例中只使用了其中的 4 位
   
   带有位字段的结构 *提供一种记录设置的方便途径*. 许多设置(eg: 字体: 粗体/斜体)
   二选一. eg: 开关, 真假. 如果只需要使用一位, 就不需要使用整个变量. 内含位字段
   的结构允许在一个存储单元中储存多个设置.

   *字段不限制 1 位大小*, 多个设置可用以下写法:
   #+begin_src c
     struct
     {
       unsigned int code1: 2;
       unsigned int code2: 2;
       unsigned int code3: 8;
     } prcode;
   #+end_src

   以上代码创建了两个 2 位的字段和一个 8 位的字段. 可以如下赋值:
   #+begin_src c
     prcode.code1 = 0;
     prcode.code2 = 3;
     prcode.code3 = 102;
   #+end_src

   但是要 *确保所赋的值不超出字段可容纳范围*
   
   如果声明的总位数超过了一个 ~unsigned int~ 类型的大小, 会 *用到下一个
   ~unsigned int~ 类型的存储位置*. 一个字段 *不允许跨越 2 个 ~unsigned int~ 之间
   的边界*. 编译器会自动移动跨界的字段, 保持 ~unsigned int~ 的边界对齐. 一旦发生
   这种情况, 第一个 ~unsigned int~ 中会留下一个未命名的 "洞"

   可以用未命名的字段宽度 "填充" 未命名的 "洞". 使用一个宽度为 0 的未命名字段迫
   使下一个字段与下一个整数对齐
   
   #+begin_src c
     struct
     {
       unsigned int field1 : 1;
       unsigned int : 2;
       unsigned int field2 : 1;
       unsigned int : 0;
       unsigned int field3 : 1;
     } stuff;
   #+end_src

   这里, 在 ~stuff.field1~ 和 ~stuff.field2~ 之间, 有一个 2 位的空隙;
   ~stuff.field3~ 将储存在下一个 ~unsigned int~ 中

   字段储存顺序取决于机器, 有些从右向左, 有些从左向右. 所以: *位字段通常都不容易
   移植*, 有些特定硬件设备正需要该所用的形式储存数据

*** 位字段示例
    通常, 把为字段作为一种更紧凑储存数据的方式.

    eg: 要在屏幕上表示一个方框的属性.

    假设有以下属性:
    
    1. 透明/不透明
    2. 填充色: 黑色, 红色, 绿色, 黄色, 蓝色, 紫色, 青色或白色
    3. 边框是否可见
    4. 边框颜色与填充色: 见 2
    5. 边框线样式: 实线, 点线, 虚线

       
    可以使用单独的变量或全长(full-sized)结构成员来表示每个属性, 但是这样做有些浪
    费位. 
    eg: 只需 1 位即可表示边框是否透明, 1 位表示是否隐藏, 8 种颜色可用 3 个单元的
    8 个可能的值, 3 种边框样式也只需要 2 位单元. 总共 10 位足够表示 5 个属性设置

    1. 方案一
       一个字节储存方框内部(透明和填充色的属性), 一个字节储存方框边框的属性, 每
       个字节的空袭用未命名字段填充. ~struct box_props~ 声明如下:
       #+begin_src c
         struct box_props
         {
           bool opaque : 1;
           unsigned int fill_color : 3;
           unsigned int : 4;
           bool show_border : 1;
           unsigned int border_color : 3;
           unsigned int border_style : 2;
           unsigned int : 2;
         };
       #+end_src

       加上未命名的字段, 该结构共占用 16 位. 如果不使用填充, 该结构占用 10 位.
       C 以 ~unsigned int~ 作为位字段结构的基本布局单元, 因此, 即使一个结构的唯
       一成员是 1 位字段, 该结构的大小也是一个 ~unsigned int~ 类型的大小,
       ~unsigned int~ 在我们的系统中是 32 位. 以上代码假设 ~_Bool~ 类型可用

       对于 ~opaque~ 成员, 1 表示边框不透明, 0 表示透明. ~show_border~ 成员也是
       类似的方法. 对于颜色, 可以用简单的 RGB 表示. 这些颜色都是三原色的混合. 显
       示器通过 RGB 像素来产生不同的颜色.

       Tips: 在早期的计算机色彩中, 每个像素都可以打开或关闭, 所以可以使用 1 位来
       表示三原色中每个二进制颜色的亮度.

       常用的顺序是: 左侧位表示蓝色亮度, 中间表示绿色, 右侧位表示红色亮度. 

       简单的颜色表示表格: 
       | 位组合 | 十进制 | 颜色 |
       |--------+--------+------|
       |    000 |      0 | 黑色 |
       |    001 |      1 | 红色 |
       |    010 |      2 | 绿色 |
       |    011 |      3 | 黄色 |
       |    100 |      4 | 蓝色 |
       |    101 |      5 | 紫色 |
       |    110 |      6 | 青色 |
       |    111 |      7 | 白色 |

       ~fill_color~ 成员和 ~border_color~ 成员可以使用这些组合. ~border_style~
       成员可以使用 0, 1, 2 来表示实线, 点线和虚线样式

       ~filelds.c~ 程序使用 ~box_props~ 结构, 该程序用 ~#define~ 创建供结构成员
       使用的符号常量.

       注意: 只打开一位即可表示三原色之一. 其他颜色用三原色的组合来表示.101
       eg: 紫色由打开的蓝色位和红色位组成, 所以, 紫色可表示为 ~BLUE|RED~
*** 位字段和按位运算符
    在同类型的编程问题中, 位字段和按位运算符是两种可替换的方法, 用哪种方法都可以.
    eg: 前面的例子中, 使用和 ~unsigned int~ 类型大小相同的结构储存图形框的信息.
    也可使用 ~unsigned int~ 变量储存相同的信息.

    如果不想用结构成员表示法来访问不同的部分, 也可以使用按位运算符来操作. 一般而
    言, 这种方法比较麻烦.

    演示 2 种方法:
    可以通过一个联合把结构方法和位方法放在一起. 假定声明了 ~struct box_props~ 类
    型, 然后这样声明联合:

    #+begin_src c
      // 把数据看作结构或 unsigned short 类型的变量
      union Views {
        struct box_props st_view;
        unsigned short us_view;
      }
    #+end_src

    在某些系统中, ~unsigned int~ 和 ~box_props~ 类型的结构都占用 16 位内存.
    其他系统中, 都是 32 位.

    无论哪种情况, 通过联合, 都可以使用 ~st_view~ 成员把一块内存看作是一个结构,
    或者使用 ~us_view~ 成员把相同的内存块看作是一个 ~unsigned short~. 
    结构的哪一个字段与 ~unsigned short~ 中的哪一位对应? 这取决于实现和硬件. 下面
    的程序示例假设从字节的低阶位端到高阶位端输入结构. 也就是说, 结构中的第一位字
    段对应计算机的字的 0 号位

    *警告*: 书中定义代码不通用, 要使得通用, ~bool~ 应换成 ~unsigned int~:
    #+begin_src c
      // 使用 unsigned int 避免不同系统的二进制位不同问题, 所导致的移位错误
      struct box_props {
        unsigned int opaque         : 1;
        unsigned int fill_color     : 3;
        unsigned int                : 4;
        unsigned int show_border    : 1;
        unsigned int border_color   : 3;
        unsigned int border_style   : 2;
        unsigned int                : 2;
      };
    #+end_src

    ~dualview.c~ 程序中, ~box.st_view~ 是一个使用位字段的 ~box_props~ 类型的结
    构, ~box.us_view~ 把相同的数据看作是一个 ~unsigned short~ 类型的变量. 联合只
    允许初始化第 1 个成员, 所以初始化值必须与结构相匹配. 该程序分别通过 2 个函数
    显示 ~box~ 函数, 一个函数接受一个结构, 另一个接受 ~unsigned short~ 类型的值.
    这 2 种方法都能访问数据, 但是所用的技术不同.

    要点: 位字段视图和按位视图的区别是: 按位视图需要 *位置信息*.
    eg: 程序中使用 ~BLUE~ 表示蓝色, 该符号常量的数值为 4. 但是, 由于结构排列数据
    方式, 实际储存蓝色设置的是 3 号位(位的编号从 0 开始). 而且储存边框为蓝色的设
    置是 11 号位.

    因此, 定义了如下符号常量:
    #+begin_src c
      #define FILL_BLUE 0x8
      #define BORDER_BLUE 0x800
    #+end_src

    此处, 0x8 是 3 号位为 1 时的值. 可以使用第一个符号常量设置填充色的蓝色位, 用
    第二个符号常量设置边框颜色的蓝色位. 用十六进制计数法更容易看出要设置二进制的
    哪一位, 由于十六进制的每一位代表二进制的 4 位, 那么 0x8 的位组合是 1000, 而
    0x800 的位组合是 1000 0000 0000. 以十进制看: 0x8 是 8, 0x800 是 2048

    如果值是 2 的幂, 那么可以使用左移运算符来表示值.
    eg: 用下面的 ~#define~ 分别替换上面的 ~#define~:
    #+begin_src c
      #define FILL_BLUE 1<<3
      #define BORDER_BLUE 1<<11
    #+end_src

    这里, ~<<~ 的右侧是 2 的指数, 0x8 即为 2^3, 0x800 是 2^11. 这些常量表达式在
    编译时求值

    可以使用枚举代替 ~#define~ 创建符号常量:
    #+begin_src c
      enum {
        OPAQUE = 0x1,
        FILL_BLUE = 0x8,
        FILL_GREEN = 0x4,
        FILL_RED = 0x2,
        FILL_MASK = 0xE,
        BORDER = 0x100,
        BORDER_BLUE = 0x800,
        BORDER_GREEN = 0x400,
        BORDER_RED = 0x200,
        BORDER_MASK = 0xE00,
        B_DOTTED = 0x1000,
        B_DASHED = 0x2000,
        STYLE_MASK = 0x3000
      };
    #+end_src
    
    *Tips*: 按位运算符改变设置更加复杂.
    eg: 设置填充色为青色. 只打开蓝色位和绿色位是不够的:
    #+begin_src c
      box.us_view |= (FILL_BLUE|FILL_GREEN); // 重置填充色
    #+end_src

    问题是该颜色还依赖于红色位的设置. 如果已经设置了该位(比如对于黄色), 这行代码
    保留了红色位的设置, 而且还设置了蓝色位和绿色位, 结果是产生白色. 解决这个问题
    最简单的方法是设置新值前关闭所有的颜色位.

    因此, 如下代码解决问题:
    #+begin_src c
      box.us_view &= ~FILL_MASK; // 把表示填充色的位置清零
      box.us_view |= (FILL_BLUE|FILL_GREEN); // 重置填充色
    #+end_src

    如果不先关闭所有位:
    #+begin_src c
      box.us_view |= BORDER_RED; // 错误的方法
    #+end_src

    由于 ~BORDER_GREEN~ 位已经设置过了, 所以结果颜色是
    ~BORDER_GREEN|BORDER_RED~, 被解释为黄色

    这种情况下, 位字段版本更简单:
    #+begin_src c
      box.st_view.fill_color = CYAN; // 等价的位方法
    #+end_src

    该方法不用先清空所有的位. 而且, 使用位字段成员时, 可以为边框和框内填充色使用
    相同的颜色值. 但是用按位运算符的方法则要使用不同的值(这些值反应实际的位置)

    比较 2 个打印语句:
    #+begin_src c
      printf("The border color is %s.\n", colors[pb->border_color]);

      printf("The border color is %s.\n", colors[(us >> 9)] & 07);
    #+end_src

    第一条语句中, 表达式 ~pb->border_color~ 的值在 0~7 的范围内, 所以该表达式可
    用作索引. 用按位运算符获得相同的信息更加复杂. 一种方法是使用 ~ui >> 9~ 把边
    框颜色右移至最右端(0 号位~2 号位), 然后把该值与掩码 07 组合, 关闭了最右端三
    位以外的所有位. 这样结果也在 0 ~ 7 的范围内, 可作为索引

    *警告*: 位字段和位的位置之间的相互对应关系因实现而异, 运行程序结果可能不同.

    可能把第一位字段载入最高阶位, 而不是最低阶位. 所以结构表示法储存在前 16 位,
    而 ~unsigned int~ 表示法则储存在后 16 位. 因此导致移位错误
** 对齐特性(C11)
   C11 的对齐特性比用位填充字节更自然, 它们还代表了 C 在处理硬件相关问题上的能力.
   在这种上下文中, 对齐指的是如何安排对象在内存中的位置.

   eg: 为了效率最大化, 系统可能要把一个 ~double~ 类型的值储存在 4 字节内存地址上,
   但却允许把 ~char~ 储存在任意地址.

   大部分程序员对对齐不以为然, 但是, 有些情况又受益于对齐控制.
   eg: 把数据从一个硬件位置转移到另一个位置, 或者调用指定同时操作多个数据项.

   ~_Alignof~ 运算符给出一个类型的对齐要求, 在关键字 ~_Alignof~ 后面的圆括号中
   写上类型名即可:
   #+begin_src c
     size_t d_align = _Alignof(float);
   #+end_src

   eg: 假设 ~d_align~ 的值是 4, 意思是 ~float~ 类型对象的对齐要求是 4. 也就是说,
   4 是储存该类型值相邻地址的字节数. 一般而言, 对齐值都应该是 2 的 非负整数次幂.
   较大的对齐值被称为 ~stricter~ 或 ~stronger~, 较小的对齐值被称为 ~weaker~.

   可以使用 ~_Alignas~ 说明符指定一个变量或类型的对齐值. 但是, 不应该要求该值 <
   基本对齐值.
   eg: 如果 ~float~ 类型的对齐要求是 4, 不要请求其对齐值是 1 或 2. 该说明符用作
   声明的一部分, 说明符后面的圆括号内包含对齐值或类型:
   #+begin_src c
     _Alignas(double) char c1;
     _Alignas(8) char c2;
     unsigned char _Alignas(long double) c_arr[sizeof(long double)];
   #+end_src

   *注意*: Clang(版本 3.2) 要求 ~_Alignas(type)~ 说明符在类型说明符后面, 如第三
   行所示. 但 GCC(版本 4.7.3) 都可识别, Clang(版本 3.3) 版本后来也支持了这两种顺
   序

   用法见 ~align.c~
   

   在当前系统中(win10, clang, msvc), ~double~ 对齐值是 8, 这意味着 *地址的类型对
   齐可以被 8 整除*. 
   以 0 或 8 结尾的十六进制地址可被 8 整除. 这就是地址常用两个 ~double~ 类型的变
   量和 ~char~ 类型的变量 ~cz~ 该变量是 ~double~ 对齐值. 因为~char~ 的对齐值是
   1, 对于普通的 ~char~ 类型变量, 编译器可以使用 *任何地址*.

   在程序中包含 ~stdalign.h~ 头文件后, 皆可以把 ~aligns~ 和 ~alignof~ 分别作为
   ~_Alignas~ 和 ~_Alignof~ 的别名. 这样做可以与 ~C++~ 关键字匹配

   C11 在 ~stdlib.h~ 库还添加了一个新的内存分配函数, 用于 *对齐动态分配的内存*.
   原型如下:
   #+begin_src c
     void* aligned_alloc(size_t alignment, size_t size);
   #+end_src

   第一个参数代表指定的对齐, 第 2 个参数是所需的字节数, 其值应是第 1 个参数的倍
   数, 与其他的内存分配函数一样, 要使用 ~free()~ 函数释放之前分配的内存
** 关键概念
   C 区别于许多高级语言的特性之一是 *访问整数中单独位的能力*. *该特性通常是与硬
   件设备和操作系统交互的关键*

   C 有 2 种访问位的方法:
   1. 按位运算符
   2. 在结构中创建位字段

   C11 新增了检查内存对齐要求的功能, 而且可以指定比基本对齐值更大的对齐值

   通常(但不总是), 使用这些特性的程序 *仅限于特定的硬件平台或操作系统*, 而且设计
   为 *不可移植* 的
** 本章小结
   计算机硬件与二进制系数系统密不可分, 因为二进制数的 1 和 0 可用于表示计算机内
   存和寄存器中位的开闭状态. 虽然 C 不允许以二进制形式书写数字, 但是它识别与二进
   制相关的八进制和十六进制计数法. 正如每个二进制数字表示 1 位一样, 每个八进制代
   表 3 位, 每个十六进制代表 4 位. 这种关系使得二进制转为八进制或十六进制较为简
   单

   C 提供多种按位运算符, 之所以称为按位是因为它们单独操作一个值中的每个位. ~~~ 运
   算符将其运算对象的每一位取反, 将 1 转为 0, 将 0 转为 1. 按位与(~&~)运算符 通
   过 2 个运算对象形成一个值. 如果 2 运算对象中相同号位都为 1, 那么该值中对应的
   位为 1; 否则, 该位为 0; 按位或运算符(~|~) 统一通过 2 个运算对象形参一个值. 如
   果 2 运算对象中相同号位有一个位 1 或都为 1, 那么该值中对应的位为 0. 按位异或
   (~^~) 运算符也有类似的操作, 只有 2 运算符对象中相同号位有一个为 1 时, 结果值
   中对应的位才为 1.

   C 还有左移(~<<~)和右移(~>>~)运算符. 这 2 个运算符使位组合中的所有位都向左或向
   右移动指定数量的位, 以行程一个新值. 对于左移运算符, 空出都为位设置为 0. 对于
   右移运算符, 如果是无符号类型的值, 空出的位设为 0; 如果有符号, 行为取决于实现

   可以在结构中使用位字段操控一个值中的单独位或多组位. 具体细节因实现而异.

   可以使用 ~_Alignas~ *强制执行数据存储区上的对齐要求*

   这些工具帮助 C 程序处理硬件问题, 因此它们通常 *依赖于实现的场合中*
** 复习题
   1. 解:
      1) 11
      2) 1101
      3) 111011
      4) 1110111
   2. 解:
      1) 十进制: 21, 八进制: 025, 十六进制: 0x15
      2) 十进制: 85, 八进制: 0125, 十六进制: 0x55
      3) 十进制: 76, 八进制: 0114, 十六进制: 0x4c
      4) 十进制: 157, 八进制: 0235, 十六进制: 0x9d
   3. 解:
      1) 4
      2) 7
      3) 7
      4) 7
      5) 5
      6) 3
      7) 28
   4. 解:
      1) 255
      2) 1
      3) 0
      4) 4
      5) 6
      6) 2
      7) 40
   5. 十进制: 255, 八进制: 0377, 十六进制: 0xff
   6. 是, 否
   7. 解:
      1) 代码:
         #+begin_src c
           struct info
           {
             unsigned int ssum: 2;
             unsigned int : 1;
             unsigned int cdsum: 2;
             unsigned int : 1;
             unsigned int hsum: 2;
           };
         #+end_src
      2) 代码:
         #+begin_src c
           struct info
           {
             unsigned int hsum: 2;
             unsigned int : 1;
             unsigned int cdsum: 2;
             unsigned int : 1;
             unsigned int ssum: 2;
           };
         #+end_src
** 编程练习
   1. 见 ~practice1.c~
   2. 见 ~practice2.c~
   3. 见 ~practice3.c~
   4. 见 ~practice4.c~
   5. 见 ~practice5.c~
   6. 见 ~practice6.c~
   7. 见 ~practice7.c~
