
* 第 12 章 存储类别, 链接和内存管理
  本章内容:
  如何确定变量的作用域(可见范围)和生命期(可存在时间)

** 存储类别(storage class)
   从硬件方面来看, 被储存的每个值都占用一定的物理内存, C 语言把这样的一块内存称为
   对象(object). 对象可以储存一个或多个值. 一个对象可能并为储存实际的值, 但是它
   在储存适当的值时一定具有相应的大小


   1. 变量名指定对象
      #+begin_example c
        int entity = 3;
      #+end_example

      该声明创建了一个名为 ~entity~ 的标识符(idenitifier). 标识符是一个名称, 在
      这种情况下, 标识符可以用来指定(designate)特定对象的内容. 标识符遵循变量的
      命名规则. 在该例中, 标识符 ~entity~ 即是软件(即 C 程序) *指定硬件内存中的对象的方式*. 该声明还提供了储存在对象中的值.

   2. 储存地址
      #+begin_example c
        int* pt = &entity;
        int ranks[10];
      #+end_example

      第一行中, ~pt~ 是一个标识符, 它指定了一个储存地址的对象. 但是, 表达式
      ~*pt~ 不是标识符, 因为它不是一个名称. 然而它确实指定了一个对象, 这种情况下,
      它与 ~entity~ 指定的对象相同. 

      一般而言, 那些指定对象的表达式被称为左值. 所以:
      1) ~entity~ 既是标识符也是左值
      2) ~*pt~ 既是表达式也是左值
      3) ~ranks + 2 * entity~ 既不是标识符(不是名称), 也不是左值(它不指定内存位
         置上的内容)
      4) ~*(ranks + 2 * entity)~ 是一个左值, 因为它的确指定了特定内存位置的值

         
   Tip: ranks 的声明创建了一个可容纳 10 个 ~int~ 类型元素的对象, 该数组的每个元素也
   是一个对象

   如果可以使用左值改变对象中的值, 该左值就是一个可修改的左值(modifiable value)


   #+begin_example c
     const char* pc = "Behold a string literal!";
   #+end_example

   程序根据该声明把相应的字符串字面量储存在内容中, *内含这些字符值的数组* 就是一个
   对象. 由于数组中的每个字符都能被单独访问, 所以 *每个字符* 也是一个对象. 该声
   明还创建了一个标识符为 ~pc~ 的对象, 储存着字符串的地址.

   由于 *可以设置 ~pc~ 重新指向其他字符串*, 所以标识符 ~pc~ 是一个可修改的左值
   (const 只保证刚被 ~pc~ 重新执行的字符串内容不被修改)

   由于 ~*pc~ 指定了储存 ~'B'~ 字符的数据对象, 所以 ~*pc~ 是一个左值, 但不是一个
   可修改的左值. 因为字符串字面量本身指定了储存字符串的对象, 所以它也是一个左值,
   但不是可修改的左值


   可以用 *存储期(storage duration)* 描述对象, 指的是对象在内存中保留了多长时间.
   标识符用于访问对象, 可以用 *作用域(scope)* 和 *链接(linkage)* 描述标识符, 标识符的作
   用域和链接表明了程序的哪些部分可以使用它. 不同的存储类别具有不同的存储期, 作
   用域和链接, 标识符 *可以在源代码中的多文件中共享*, *可用于特定文件的任意函数中*,
   *可仅限于特定函数中使用*, 甚至 *只在函数中的某部分使用*. 对象可存在于程序的执行期
   , 也可以仅存在于它所在函数的执行期. 
   
   对于并发编程, *对象可以在特定线程的执行期存在*. *可以通过函数调用的方式显示分配和释放内存* 
*** 作用域
    作用域描述程序中 *可访问标识符的区域* . 一个变量的作用域可以是 *块作用域*,
    *函数作用域*, *函数原型作用域* 或 *文件作用域*.

    1. 块作用域
       块是用一对花括号括起来的代码区域. 例如: 整个函数体是一个块, 函数中的任意
       符合语句也是一个块. 定义在块中的变量具有块作用域(block scope). 

       块作用域变量的可见范围是 *从定义处到包含该定义的块的结尾*

       虽然函数的形式参数声明在函数的左花括号之前, 但是它们也具有块作用域, 属于
       函数体这个块. 所以目前为止, 我们使用的局部变量(包括函数的形式参数)都具有
       块作用域.

       以下代码都具有块作用域
       #+begin_src c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           // ...

           return patrick;
         }
       #+end_src

       #+begin_example c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           int i;

           for (i = 0; i < 10; ++i) {
             double q = cleo * i; // q的作用域开始
             // ...
             patrick *= q; // q的作用域结束
           }

           return patrick;
         }
       #+end_example

       自 C99 标准起, 允许在块中的任意位置声明变量

       为了适应这个特性, C99 把块的概念扩展到包括 for 循环, while 循环, do while
       循环和 if 语句所控制的代码, 即使这些代码没有用花括号括起来, 也算是块的一
       部分

    2. 函数作用域
       函数作用域(function scope) 仅用于 *goto* 语句的标签. 

       这意味着即使一个标签首次出现在函数的内层块中, 它的所用于也延伸至整个函数.
       如果在 2 个块中使用相同的标签会很混乱, 标签的函数作用域防止了这样的事情发生

    3. 函数原型作用域
       函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名)

       函数原型作用域的范围是从形参定义处到原型结束. 这意味着, 编译器在处理函数
       原型中的形参时只关心它的类型, 而参数名通常无关紧要. 而且, 即使有参数名,
       也不必与函数定义中的形参名相匹配.

       只有在变长数组中, 形参名才有用:
       #+begin_src c
         void use_a_VLA(int n, int m, int ar[n][m]);
       #+end_src

       方括号中必须使用在函数原型中已声明的名称

    4. 文件作用域
       变量的定义在函数的外面, 具有文件作用域(file scope). 具有文件作用域的变量,
       从它的定义处到该定义所在文件的末尾均可见
       
       文件作用域也称为全局变量(global variable)

       
    注意: 翻译单元和文件
    多个文件在编译器中可能以一个文件出现. 通常才源代码(.c 扩展名)中包含一个或多个
    头文件(.h 扩展名). 头文件会依次包含其他头文件, 所以会包含多个单独的物理文件.

    但是, C 预处理器实际上是用包含的头文件内容替换 ~#include~ 指令. 所以,编译器源
    代码文件和所有的头文件都看成是一个包含信息的单独文件. 这个文件被称为翻译单元
    (translation unit). 描述一个具有文件作用域的变量时, 它的实际可见范围是整个翻
    译单元.如果程序由多个源代码文件组成, 那么该程序也将由多个翻译单元组成. 每个
    翻译单元均对应一个源代码文件和它所包含的文件

*** 链接
    C 变量有 3 种链接属性: 外部链接, 内部链接, 无链接.

    具有块作用域, 函数作用域或函数原型作用域的变量都是无链接变量.这意味着这些变
    量属于它们的块, 函数或原型私有. 

    具有文件作用域的变量可以是外部链接或内部链接.外部链接变量可以在多文件程序中
    使用, 内部链接变量只能在一个翻译单元中使用
    
    *注意*: 正式和非正式术语

    C 标准用"内部链接的文件作用域"描述仅限于一个 *翻译单元(即一个源代码文件和它所
    包含的头文件)* 的作用域, 用 "外部链接的文件作用域" 描述可延伸至其他翻译单元
    的作用域. 

    简称: "内部链接文件的作用域" -> "文件作用域", "外部连接的文件作用域" -> "全
    局作用域" 或 "程序作用域"

    #+begin_src c
      int giants = 5; // 文件作用域, 外部链接
      static int dodgers = 3; // 文件作用域,内部链接

      int main()
      {
        // ...
        return 0;
      }

      // ...
    #+end_src

    该文件和同一程序的其他文件都可以使用变量 giants, 而变量 dodgers 属文件私有,
    该文件的任意函数都可以使用它

*** 存储期
    作用域和链接描述了标识符的可见性. 
    存储期描述了通过这些标识符访问的对象的生存期. C 对象有 4 种存储期: 静态存储期,
    线程存储期, 自动存储期, 动态分配存储期

    1. 静态存储期
       如果对象具有静态存储期, 那么它在程序的执行期间一直存在. 文件作用域变量具
       有静态存储期.

       *注意*: 对于文件作用域变量, 关键字 ~static~ 表明其连接属性, 而非存储期.
       以 ~static~ 声明的文件作用域变量具有内部链接. 但是无论是内部链接还是外部
       链接, 所有的文件作用域变量都具有静态存储期

    2. 线程存储期
       线程存储期用于并发程序设计, 程序执行可被分为多个线程. 具有线程存储期的对
       象, 从被声明时到线程结束一直存在. 以关键字 ~_Thread_local~ 声明一个对象时,
       每个线程都获得该变量的私有备份.

    3. 自动存储期
       块作用域的变量通常都具有自动存储期. 当程序进入定义这些变量的块时, 为这些
       变量分配内存; 当退出这个块时, 释放刚才为变量分配的内存.

       这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区.

       例如: 一个函数调用结束后, 其变量占用的内存可用于存储下一个被调用函数的变
       量.

       变长数组(VLA) 稍有不同, 它们的存储期从声明处到块的末尾, 而不是从块开始处
       到块的末尾.

       到目前为止使用的局部变量都是自动类别

       块作用域变量也能具有静态存储期.

       例:
       #+begin_src c
         void more(int number)
         {
           int index;
           static int ct = 0;
           // ...
           return 0;
         }
       #+end_src

       *注意*: 变量 ~ct~ 储存在静态内存中, 它 *从程序被载入到程序结束期间都存在*.
       但是, 它的作用域定义在 ~more()~ 函数块中. 只有在执行函数时, 程序才能使用
       ~ct~ 访问它所指定的对象(但是, 该函数可以给其他函数提供该存储区的地址以便
       简介访问该对象, 例如通过指针形参或返回值)

       
    | 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                     |
    |--------------+--------+--------+------+------------------------------|
    | 自动         | 自动   | 块     | 无   | 块内                         |
    | 寄存器       | 自动   | 块     | 无   | 块内, 使用关键字 register     |
    | 静态外部链接 | 静态   | 文件   | 外部 | 所有函数外                   |
    | 静态内部链接 | 静态   | 文件   | 内部 | 所有函数外, 使用关键字 static |
    | 静态无链接   | 静态   | 块     | 无   | 块内, 使用关键字 static       |
*** 自动变量
    属于自动存储类别的变量具有自动存储期, 块作用域且无链接. 

    默认情况下, 声明在块或函数头中的任何变量都属于自动存储类别.

    为了更清楚的表达意图(为了表明有意覆盖一个外部变量定义, 或者强调把该变量的类
    别改为其他存储类别), 可以使用显示关键字 ~auto~

    #+begin_src c
      int main(void)
      {
        auto int index;
        return 0;
      }
    #+end_src

    关键字 ~auto~ 是存储类别说明符(storage-class specifier).

    块作用域和无链接意味着 *只有在变量定义处所在的块中才能通过变量名访问该变量*
    (地址传递除外).
    另一个函数可以使用同名变量, 但是该变量是储存在不同内存位置上的另一个变量

    变量具有自动存储期意味着: 程序在进入该变量声明所在的块时变量存在, 程序在退出
    该块时变量消失. 原来该变量占用的内存位置现在可做他用.

    嵌套块示例:
    #+begin_src c
      int loop(int n)
      {
        int m; // m的作用域
        scanf("%d", &m);

        {
          int i; // m 和 i的作用域
          for (i = m; i < n; i++)
            puts("i is local to a sub-block\n");
        }

        return m; // m的作用域, i已经消失
      }
    #+end_src

    当内层块与外层同名: ~见 hiding.c~

    1. 没有花括号的块
       C99特性: 作为循环或if语句的一部分, 即使不使用花括号({}), 也是一个块.
       更完整的说, 整个循环是它所在块的子块(sub-block), 循环体是整个循环块的子块.
       与此类似, if语句是一个块, 与其相关联的子语句是if语句的子块.这些规则会影响
       到声明的变量和这些变量的作用域

       *易证: 每次块作用域内的变量内存地址相同*

    2. 自动变量的初始化
       自动变量 *不会初始化*, 必须显式初始化
       #+begin_src c
         int main()
         {
           // 未初始化, 值不是0
           int ruth;
           int tens = 5;

           return 0;
         }
       #+end_src

       可以用非常量表达式(non-constant expression)初始化自动变量:
       #+begin_src c
         int main()
         {
           int ruth = 1;
           int rance = 5 * ruth;

           return 0;
         }
       #+end_src
       
       
