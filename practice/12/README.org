

* 第 12 章 存储类别, 链接和内存管理
  本章内容:
  如何确定变量的作用域(可见范围)和生命期(可存在时间)

** 存储类别(storage class)
   从硬件方面来看, 被储存的每个值都占用一定的物理内存, C 语言把这样的一块内存称为
   对象(object). 对象可以储存一个或多个值. 一个对象可能并为储存实际的值, 但是它
   在储存适当的值时一定具有相应的大小


   1. 变量名指定对象
      #+begin_example c
        int entity = 3;
      #+end_example

      该声明创建了一个名为 ~entity~ 的标识符(idenitifier). 标识符是一个名称, 在
      这种情况下, 标识符可以用来指定(designate)特定对象的内容. 标识符遵循变量的
      命名规则. 在该例中, 标识符 ~entity~ 即是软件(即 C 程序) *指定硬件内存中的对象的方式*. 该声明还提供了储存在对象中的值.

   2. 储存地址
      #+begin_example c
        int* pt = &entity;
        int ranks[10];
      #+end_example

      第一行中, ~pt~ 是一个标识符, 它指定了一个储存地址的对象. 但是, 表达式
      ~*pt~ 不是标识符, 因为它不是一个名称. 然而它确实指定了一个对象, 这种情况下,
      它与 ~entity~ 指定的对象相同. 

      一般而言, 那些指定对象的表达式被称为左值. 所以:
      1) ~entity~ 既是标识符也是左值
      2) ~*pt~ 既是表达式也是左值
      3) ~ranks + 2 * entity~ 既不是标识符(不是名称), 也不是左值(它不指定内存位
         置上的内容)
      4) ~*(ranks + 2 * entity)~ 是一个左值, 因为它的确指定了特定内存位置的值

         
   Tip: ranks 的声明创建了一个可容纳 10 个 ~int~ 类型元素的对象, 该数组的每个元素也
   是一个对象

   如果可以使用左值改变对象中的值, 该左值就是一个可修改的左值(modifiable value)


   #+begin_example c
     const char* pc = "Behold a string literal!";
   #+end_example

   程序根据该声明把相应的字符串字面量储存在内容中, *内含这些字符值的数组* 就是一个
   对象. 由于数组中的每个字符都能被单独访问, 所以 *每个字符* 也是一个对象. 该声
   明还创建了一个标识符为 ~pc~ 的对象, 储存着字符串的地址.

   由于 *可以设置 ~pc~ 重新指向其他字符串*, 所以标识符 ~pc~ 是一个可修改的左值
   (const 只保证刚被 ~pc~ 重新执行的字符串内容不被修改)

   由于 ~*pc~ 指定了储存 ~'B'~ 字符的数据对象, 所以 ~*pc~ 是一个左值, 但不是一个
   可修改的左值. 因为字符串字面量本身指定了储存字符串的对象, 所以它也是一个左值,
   但不是可修改的左值


   可以用 *存储期(storage duration)* 描述对象, 指的是对象在内存中保留了多长时间.
   标识符用于访问对象, 可以用 *作用域(scope)* 和 *链接(linkage)* 描述标识符, 标识符的作
   用域和链接表明了程序的哪些部分可以使用它. 不同的存储类别具有不同的存储期, 作
   用域和链接, 标识符 *可以在源代码中的多文件中共享*, *可用于特定文件的任意函数中*,
   *可仅限于特定函数中使用*, 甚至 *只在函数中的某部分使用*. 对象可存在于程序的执行期
   , 也可以仅存在于它所在函数的执行期. 
   
   对于并发编程, *对象可以在特定线程的执行期存在*. *可以通过函数调用的方式显示分配和释放内存* 
*** 作用域
    作用域描述程序中 *可访问标识符的区域* . 一个变量的作用域可以是 *块作用域*,
    *函数作用域*, *函数原型作用域* 或 *文件作用域*.

    1. 块作用域
       块是用一对花括号括起来的代码区域. 例如: 整个函数体是一个块, 函数中的任意
       符合语句也是一个块. 定义在块中的变量具有块作用域(block scope). 

       块作用域变量的可见范围是 *从定义处到包含该定义的块的结尾*

       虽然函数的形式参数声明在函数的左花括号之前, 但是它们也具有块作用域, 属于
       函数体这个块. 所以目前为止, 我们使用的局部变量(包括函数的形式参数)都具有
       块作用域.

       以下代码都具有块作用域
       #+begin_src c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           // ...

           return patrick;
         }
       #+end_src

       #+begin_example c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           int i;

           for (i = 0; i < 10; ++i) {
             double q = cleo * i; // q的作用域开始
             // ...
             patrick *= q; // q的作用域结束
           }

           return patrick;
         }
       #+end_example

       自 C99 标准起, 允许在块中的任意位置声明变量

       为了适应这个特性, C99 把块的概念扩展到包括 for 循环, while 循环, do while
       循环和 if 语句所控制的代码, 即使这些代码没有用花括号括起来, 也算是块的一
       部分

    2. 函数作用域
       函数作用域(function scope) 仅用于 *goto* 语句的标签. 

       这意味着即使一个标签首次出现在函数的内层块中, 它的所用于也延伸至整个函数.
       如果在 2 个块中使用相同的标签会很混乱, 标签的函数作用域防止了这样的事情发生
       
    3. 函数原型作用域
       函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名)

       函数原型作用域的范围是从形参定义处到原型结束. 这意味着, 编译器在处理函数
       原型中的形参时只关心它的类型, 而参数名通常无关紧要. 而且, 即使有参数名,
       也不必与函数定义中的形参名相匹配.

       只有在变长数组中, 形参名才有用:
       #+begin_src c
         void use_a_VLA(int n, int m, int ar[n][m]);
       #+end_src

       方括号中必须使用在函数原型中已声明的名称

    4. 文件作用域
       变量的定义在函数的外面, 具有文件作用域(file scope). 具有文件作用域的变量,
       从它的定义处到该定义所在文件的末尾均可见
       
       文件作用域也称为全局变量(global variable)

       
    注意: 翻译单元和文件
    多个文件在编译器中可能以一个文件出现. 通常才源代码(.c 扩展名)中包含一个或多个
    头文件(.h 扩展名). 头文件会依次包含其他头文件, 所以会包含多个单独的物理文件.

    但是, C 预处理器实际上是用包含的头文件内容替换 ~#include~ 指令. 所以,编译器源
    代码文件和所有的头文件都看成是一个包含信息的单独文件. 这个文件被称为翻译单元
    (translation unit). 描述一个具有文件作用域的变量时, 它的实际可见范围是整个翻
    译单元.如果程序由多个源代码文件组成, 那么该程序也将由多个翻译单元组成. 每个
    翻译单元均对应一个源代码文件和它所包含的文件

*** 链接
    C 变量有 3 种链接属性: 外部链接, 内部链接, 无链接.

    具有块作用域, 函数作用域或函数原型作用域的变量都是无链接变量.这意味着这些变
    量属于它们的块, 函数或原型私有. 

    具有文件作用域的变量可以是外部链接或内部链接.外部链接变量可以在多文件程序中
    使用, 内部链接变量只能在一个翻译单元中使用
    
    *注意*: 正式和非正式术语

    C 标准用"内部链接的文件作用域"描述仅限于一个 *翻译单元(即一个源代码文件和它所
    包含的头文件)* 的作用域, 用 "外部链接的文件作用域" 描述可延伸至其他翻译单元
    的作用域. 

    简称: "内部链接文件的作用域" -> "文件作用域", "外部连接的文件作用域" -> "全
    局作用域" 或 "程序作用域"

    #+begin_src c
      int giants = 5; // 文件作用域, 外部链接
      static int dodgers = 3; // 文件作用域,内部链接

      int main()
      {
        // ...
        return 0;
      }

      // ...
    #+end_src

    该文件和同一程序的其他文件都可以使用变量 giants, 而变量 dodgers 属文件私有,
    该文件的任意函数都可以使用它

*** 存储期
    作用域和链接描述了标识符的可见性. 
    存储期描述了通过这些标识符访问的对象的生存期. C 对象有 4 种存储期: 静态存储期,
    线程存储期, 自动存储期, 动态分配存储期

    1. 静态存储期
       如果对象具有静态存储期, 那么它在程序的执行期间一直存在. 文件作用域变量具
       有静态存储期.

       *注意*: 对于文件作用域变量, 关键字 ~static~ 表明其连接属性, 而非存储期.
       以 ~static~ 声明的文件作用域变量具有内部链接. 但是无论是内部链接还是外部
       链接, 所有的文件作用域变量都具有静态存储期

    2. 线程存储期
       线程存储期用于并发程序设计, 程序执行可被分为多个线程. 具有线程存储期的对
       象, 从被声明时到线程结束一直存在. 以关键字 ~_Thread_local~ 声明一个对象时,
       每个线程都获得该变量的私有备份.

    3. 自动存储期
       块作用域的变量通常都具有自动存储期. 当程序进入定义这些变量的块时, 为这些
       变量分配内存; 当退出这个块时, 释放刚才为变量分配的内存.

       这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区.

       例如: 一个函数调用结束后, 其变量占用的内存可用于存储下一个被调用函数的变
       量.

       变长数组(VLA) 稍有不同, 它们的存储期从声明处到块的末尾, 而不是从块开始处
       到块的末尾.

       到目前为止使用的局部变量都是自动类别

       块作用域变量也能具有静态存储期.

       例:
       #+begin_src c
         void more(int number)
         {
           int index;
           static int ct = 0;
           // ...
           return 0;
         }
       #+end_src

       *注意*: 变量 ~ct~ 储存在静态内存中, 它 *从程序被载入到程序结束期间都存在*.
       但是, 它的作用域定义在 ~more()~ 函数块中. 只有在执行函数时, 程序才能使用
       ~ct~ 访问它所指定的对象(但是, 该函数可以给其他函数提供该存储区的地址以便
       简介访问该对象, 例如通过指针形参或返回值)

       
    | 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                     |
    |--------------+--------+--------+------+------------------------------|
    | 自动         | 自动   | 块     | 无   | 块内                         |
    | 寄存器       | 自动   | 块     | 无   | 块内, 使用关键字 register     |
    | 静态外部链接 | 静态   | 文件   | 外部 | 所有函数外                   |
    | 静态内部链接 | 静态   | 文件   | 内部 | 所有函数外, 使用关键字 static |
    | 静态无链接   | 静态   | 块     | 无   | 块内, 使用关键字 static       |
*** 自动变量
    属于自动存储类别的变量具有自动存储期, 块作用域且无链接. 

    默认情况下, 声明在块或函数头中的任何变量都属于自动存储类别.

    为了更清楚的表达意图(为了表明有意覆盖一个外部变量定义, 或者强调把该变量的类
    别改为其他存储类别), 可以使用显示关键字 ~auto~

    #+begin_src c
      int main(void)
      {
        auto int index;
        return 0;
      }
    #+end_src

    关键字 ~auto~ 是存储类别说明符(storage-class specifier).

    块作用域和无链接意味着 *只有在变量定义处所在的块中才能通过变量名访问该变量*
    (地址传递除外).
    另一个函数可以使用同名变量, 但是该变量是储存在不同内存位置上的另一个变量

    变量具有自动存储期意味着: 程序在进入该变量声明所在的块时变量存在, 程序在退出
    该块时变量消失. 原来该变量占用的内存位置现在可做他用.

    嵌套块示例:
    #+begin_src c
      int loop(int n)
      {
        int m; // m的作用域
        scanf("%d", &m);

        {
          int i; // m 和 i的作用域
          for (i = m; i < n; i++)
            puts("i is local to a sub-block\n");
        }

        return m; // m的作用域, i已经消失
      }
    #+end_src

    当内层块与外层同名: ~见 hiding.c~

    1. 没有花括号的块
       C99 特性: 作为循环或 if 语句的一部分, 即使不使用花括号({}), 也是一个块.
       更完整的说, 整个循环是它所在块的子块(sub-block), 循环体是整个循环块的子块.
       与此类似, if 语句是一个块, 与其相关联的子语句是 if 语句的子块.这些规则会影响
       到声明的变量和这些变量的作用域

       *易证: 每次块作用域内的变量内存地址相同*

    2. 自动变量的初始化
       自动变量 *不会初始化*, 必须显式初始化
       #+begin_src c
         int main()
         {
           // 未初始化, 值不是0
           int ruth;
           int tens = 5;

           return 0;
         }
       #+end_src

       可以用非常量表达式(non-constant expression)初始化自动变量:
       #+begin_src c
         int main()
         {
           int ruth = 1;
           int rance = 5 * ruth;

           return 0;
         }
       #+end_src
       
       
*** 寄存器变量
    变量通常存储在计算机内存中. *如果幸运的话*, 寄存器变量存储在 CPU 的寄存器中,
    或者概括地说, 储存在 *最快* 的可用内存中.
    
    与普通变量相比, 访问和处理这些变量的速度更快. 由于寄存器变量储存在寄存器而非
    内存中, 所以 *无法获取寄存器变量的地址*. 绝大多数方面, 寄存器变量和自动变量
    都一样.都是 *块作用域*, *无链接* 和 *自动存储期*.

    使用存储类别说明符 ~register~ 便可声明寄存器变量:
    
    #+begin_src c
      int main()
      {
        register int quick;
  
        return 0;
      }
    #+end_src

    寄存器变量申请可能失败, 失败则回退至普通变量, 尽管如此, *依旧不能对该变量使
    用地址运算符*

    在函数头中使用:
    #+begin_src c
      void macho(register int n);
    #+end_src

    可声明为 ~register~ 的数据类型有限.
    例如, 处理器中的寄存器可能没有足够大的空间来存储 ~double~ 类型的值

*** 块作用域的静态变量
    静态变量(static variable)听起来自相矛盾, 像是一个不可变的变量.
    实际上, 静态的意思是该变量在内存中原地不动, 并不是说它的值不变.
    其有文件作用域的变量自动具有(也必须是)静态存储期. 前面提到过, 可以创建具有静
    态存储期, 块作用域的局部变量. 

    这些变量和自动变量一样, 具有相同的作用域, 但是程序离开它们所在的函数后, 这些
    变量不会消失. 也就是说, 这种变量具有块级作用域, 无链接, 但是具有静态存储期.
    
    *计算机在多次函数调用之间会记录它们的值*. 在块中(提供块作用域和无链接)以存储类
    别说明符 ~static~ (提供静态存储期)声明这种变量

    *注解*: 编译时初始化, 若未初始化会初始化一个合法值

    *注意*: 不能在函数的形参中使用 static
    #+begin_src c
      int wontwork(static int flu); // 不允许
    #+end_src

    "局部静态变量" 是描述具有块作用域的静态变量的另一个术语. 这种存储类别别称为
    内部静态存储类别(internal static storage class). 
    这里的内部指的是 *函数内部*, 而非内部链接


*** 外部链接的静态变量
    外部链接的静态变量具有文件作用域, 外部链接和静态存储期.
    该类别有时称为 *外部存储类别(external storage class)*, 属于该类别的变量称为
    *外部变量(external variable)*. 把变量的定义性声明(defining declaration) 放在
    所有函数的外面便创建了外部变量. 当然, 为了指出该函数使用了外部变量, 可以在函
    数中用关键字 ~extern~ 再次声明. 如果一个源代码文件使用的外部变量定义在另一个
    源代码文件中, 则必须用 ~extern~ 在该文件中声明该变量
    #+begin_src c
      int Errupt; // 外部定义的变量

      double Up[100]; // 外部定义的数组
      extern char Coal; // 如果Coal被定义在另一个文件

      void next();

      int main()
      {
        extern int Errupt; // 可选声明
        extern double Up[]; // 可选声明, 此处不用声明大小, 因为第一次声明提供了
      }

      void next()
      {
        // ...
      }
    #+end_src

    
    main 中两条声明完全可以省略, 因为 *外部变量具有文件作用域*, 所以 ~Errupt~ 和
    ~Up~ 从声明处到文件结尾都可见. 它们出现在那里, 仅为了说明 ~main*()~ 函数要使
    用这 2 个变量

    如果省略掉函数中的 ~extern~ 关键字, 相当于创建了一个自动变量.
    例:
    #+begin_src c
      extern int Errupt;
    #+end_src
    #+begin_src c
      int Errupt;
    #+end_src

    这使得编译器在 ~main()~ 中创建了一个名为 ~Errupt~ 的自动变量. 它是一个独立的
    局部变量, 与原来的外部变量 ~Errupt~ 不同. 该局部变量仅 ~main()~ 中可见, 但是
    外部变量对该文件的其他函数也可见.
    
    简而言之, 在执行块中的语句时, 块作用域中的变量将 "隐藏" 文件作用域中的同名变
    量.

    如果不得已要使用与外部变量同名的局部变量, 可以在局部变量的声明中使用 ~auto~
    存储类别说明符明确表达这种意图

    外部变量具有静态存储期, 因此, 无论程序执行到任何函数, 其值都 *一直存在*

    示例:
    1. 外部变量 ~Hocus~, 对 ~main()~ 和 ~magic()~ 均可见
       #+begin_src c
         int Hocus;
         int magic();
         int main()
         {
           extern int Hocus; // Hocus之前已声明为外部变量
         }

         int magic()
         {
           extern int Hocus; // 与上面的Hocus是同一变量
         }
       #+end_src

    2. 外部变量 ~Hocus~, 对 2 个函数均可见, 在默认情况下对 ~magic()~ 可见
       #+begin_src c
         int Hocus;
         int magic();
         int main()
         {
           extern int Hocus; // Hocus之前已声明为外部变量
         }

         int magic()
         {
           // 并未在该函数中声明Hocus, 但是仍可使用该变量
         }
       #+end_src

    3. 创建了 4 个独立变量, ~main()~ 中的 ~Hocus~ 变量默认是自动变量, 属于
       ~main()~ 私有. ~magic()~ 中的 ~Hocus~ 变量被显式声明为自动, 只有
       ~magic()~ 可用. 外部变量对 ~main()~ 和 ~magic()~ 均不可见, 但是对该文件中
       未创建局部 ~Hocus~ 变量的其他函数可见. 最后, ~Pocus~ 是外部变量,
       ~magic()~ 可见, 但是 ~main()~ 不可见, 因为 ~Pocus~ 被声明在 ~main()~ 后面

       #+begin_src c
         int Hocus;
         int magic();

         int main()
         {
           int Hocus; // 默认自动变量
         }

         int Pocus;

         int magic()
         {
           auto int Hocus; // 把局部变量 Hocus 显式声明为自动变量
         }
       #+end_src

       外部变量的作用域: *从声明处到文件结尾*
       外部变量的声明周期: *在程序中一直存在*


**** 初始化外部变量
     外部变量和自动变量类似, 也可以被显式初始化. 与自动变量不同的是, 如果未初始
     化外部变量, 它们会自动初始化为 0. 这一原则也适用于外部定义的数组元素.
     与自动变量的情况不同, 只能使用常量表达式初始化文件作用域变量
     #+begin_src c
       int x = 10; // OK
       int y = 3 + 20; // OK
       size_t z = sizeof(int); // OK
       int x2 = 2 * x; // Error
     #+end_src

     *注意*: 只要不是变长数组(VLA), ~sizeof~ 表达式可视为常量表达式

**** 使用外部变量
     使用外部变量的示例. ~见 global.c~

**** 外部名称
     C99 和 C11 标准都要求编译器识别局部标识符的前 63 个字符和外部标识符的前 31 个字符.
     这修订了以前的标准, 即编译器识别局部标识符前 31 个字符和外部标识符前 6 个字符.
     

     外部变量名比局部变量名的规则严格, 是因为外部变量名还要遵循局部环境规则, 所
     受限制的更多

**** 定义和声明

     例:
     #+begin_src c
       int tern = 1; // tern被定义

       main()
       {
         extern int tern; // 使用在别处定义的tern
       }
     #+end_src
     
     ~tern~ 被声明了 2 次, 第一次声明为变量预留了存储空间, 该声明构成了变量的定义.
     第二次声明只告诉编译器使用之前已创建的 ~tern~ 变量, 所以这不是定义.

     第一次声明被称为定义式声明(defining declaration)

     第二次声明被称为引用式声明(referencing declaration)

     关键字 ~extern~ 表明该声明不是定义, 因为它指示编译器去别处查询其定义

     外部变量 *只能初始化一次*, 且 *必须在定义该变量时进行*
*** 内部链接的静态变量
    该存储类别的变量具有静态存储期, 文件作用域和内部链接. 在所有函数外部(这点与
    外部变量相同), 用存储类别说明符 ~static~ 定义的变量具有 这种存储类别:
    
    #+begin_src c
      static int svil = 1; // 静态变量, 内部链接

      int main()
      {

        return 0;
      }
    #+end_src

    
    这种变量过去称为 *外部静态变量(external static variable)*, 但是这个术语有点
    自相矛盾(这些变量具有内部链接). 但是没有和是的新简称
    所以只能用 *内部链接的静态变量(static variable with internal linkage)*.

    普通的外部变量可用于同一程序中任意文件中的函数, 但是内部链接的静态变量 *只能
    用于同一个文件中的函数*. 可以使用存储类别说明符 ~extern~, 在函数中重复声明任
    何具有文件作用域的变量. 这样的声明并不会改变其链接属性:

    #+begin_src c
      int traveler = 1; // 外部链接
      static int stayhome = 1; // 内部链接

      int main()
      {
        extern int traveler;// 使用定义在别处的traveler
        extern int stayhome; // 使用定义在别处的 stayhome
        // ...

        return 0;
      }
    #+end_src
    
    对于该程序所在的翻译单元, ~traveler~ 和 ~stayhome~ 都具有文件作用域, 但是只
    有 ~traveler~ 可用于其他翻译单元(因为它具有外部链接)

    ~extern~ 关键字并未改变 ~stayhome~ 内部链接属性

*** 多文件
    只有当程序由多个翻译单元组成时, 才体现区别内部链接和外部链接的重要性.
    
    *注意*: 如果外部变量定义在一个文件中, 那么其他文件在使用该变量之前 *必须先声
     明(extern 关键字)它*. 否则不能直接使用

     
*** 存储类别说明符    
    关键字 ~static~ 和 ~extern~ 的含义取决于上下文.
    
    C 语言有 6 个关键字作为存储类别说明符: ~auto~, ~register~, ~static~, ~extern~,
    ~_Thread_local~ 和 ~typedef~. 
    ~typedef~ 关键字与任何内存存储无关, 把它归于此类有一些语法上的原因.

    在绝大多数情况下, 不能再声明中使用多个存储类别说明符, 所以这 *意味着不能使用
    多个存储类别说明符作为 ~typedef~ 的一部分*
    唯一例外的是 ~_Thread_local~, 它可以和 ~static~ 或 ~extern~ 一起使用

    1. auto
       ~auto~ 说明符表示变量是自动存储期, 只能用于块作用域的变量声明中.
       由于在块中声明的变量本身就具有自动存储期, 所以使用 ~auto~ 主要是为了明确
       表达要使用与外部变量同名的局部变量的意图

    2. register
       ~register~ 说明符也只用于块作用域的变量, 它把变量归为寄存器存储类别, 请求
       最快速度访问该变量. 同时, 还保护了该变量的 *地址不被读取*

       用 ~static~ 说明符创建的对象具有静态存储期, 载入程序时创建对象, 当程序结
       束时对象消失. 如果 ~static~ 用于文件作用域声明, 作用域受限于该文件.
       如果 ~static~ 用于块作用域声明, 作用域则受限于该块.

       因此, 只要程序在运行对象就存在并保留其值, 但是只有在执行块内的代码时, 菜
       鸟通过标识符访问.

       块作用域的静态变量无连接. 文件作用域的静态变量具有内部链接

       ~extern~ 说明符表明声明的变量定义在别处. 如果包含 ~extern~ 的声明具有文件
       作用域, 则引用的变量必须具有外部链接. 如果包含 ~extern~ 的声明具有块作用
       域, 则引用的变量可能具有外部链接或内部链接, 这取决于该变量的定义式声明

       小结: 存储类别

       *自动变量*: 具有块作用域, 无链接, 自动存储期. 属于所在块私有(通常指函数).寄存
       器变量的属性和自动变量相同

       *静态存储期*: 变量可以具有外部链接, 内部链接或无链接. 在同一个文件所有函
       数的外部声明的变量是外部变量, 具有文件作用域, 外部链接和静态存储期. 如果
       在这种声明前面加上关键字 ~static~, 那么其声明的变量具有文件作用域, 内部链
       接和静态存储期. 如果函数中用 ~static~, 则该变量具有块作用域, 无链接, 静态
       存储期

       程序在编译时会为具有静态存储期的变量分配内存, 并始终保留, 默认初始化为 0

       具有内部链接的文件作用域变量, 只能用于其声明所在的文件内

       多存储类别示例: ~见parta.c, partb.c~
*** 存储类别和函数
    函数也有存储类别, 可以是外部函数(默认)或静态函数. C99 新增了第三种类别 - 内
    联函数, 将在第 16 章介绍.
    
    外部函数可以被其他文件的函数访问, 但是静态函数只能用于其定义所在的文件.

    #+begin_src c
      double gamma(dobule); // 该函数默认为外部函数
      static double beta(int, int);
      extern double delta(double, int);
    #+end_src

    在同一个程序中, 其他文件中的函数可以调用 ~gamma()~ 和 ~delta()~, 但是不能调
    用 ~beta()~, 因为 ~static~ 存储类别说明符创建的函数属于特定模块私有. 这样做
    避免了名称冲突的问题, 由于 ~beta()~ 受限于它所在的文件, 所以在其他文件中可以
    使用与之同名的函数.

    通常的做法是: 用 ~extern~ 关键字声明定义在其他文件中的函数. 这样做是为了表明
    当前文件中使用的函数被定义在别处. 除非使用 ~static~ 关键字, 否则一般函数声明
    都默认为 ~extern~

*** 存储类别的选择
    对于 "使用哪种存储类别" 的回答绝大多数是 "自动存储类别", 默认类别就是自动存
    储类别

    当使用 ~const~ 数据的时候, 不用担心被意外篡改

    保护性程序设计的黄金法则是: "按需知道"原则. 尽量在函数内部解决该函数的任务,
    只共享那些需要共享的变量. 除自动存储类别外, 其他存储类别也很有有用. 不过, 在
    使用某类别之前先要考虑以下是否有必要这样做

** 随机数函数和静态变量

*** 手动重置
    ANSI C 库提供了 ~rand()~ 函数生成随机数. 生成随机数有多种算法, ANSI C 允许 C 实现
    针对特定机器使用最佳算法. 然而, ANSI C 标准还提供了一个可移植的标准算法, 在不
    同系统中生成相同的随机数. 

    实际上, ~rand()~ 是 "伪随机数生成器", 意思是可预测生成数字的实际序列. 但是数
    字在取值职范围内均匀分布

    为了看清楚程序内部的情况, 我们使用可移植的 ANSI 版本, 而不是编译器内置的
    ~rand()~ 函数.

    可移植版本的方案开始于一个 "种子"数字. 该函数使用该种子生成新的数, 这个新数又
    成为新的种子. 然后, 新种子可用于生成更新的种子, 以此类推.

    该方案要行之有效, 随机数函数必须记录它上一次被调用时所使用的种子. 这里需要一
    个静态变量 (见 ~rand0.c~)

    ~rand0.c~  中, 静态变量 ~next~ 的初始值是 1, 其值在每次调用 ~rand0()~ 函数时
    都会被修改 (通过魔术公式). 该函数是用于返回一个 0 ~ 32767 之间的值.
    注意: next 是具有内部链接的静态变量(并非无链接). 这是为了方便稍后扩展本例, 供
    同一个文件中的其他函数共享

   
    ~r_drive0.c~ 中, 每次主程序运行, 都开始于相同的种子 1. 可以引入另一个函数
    ~srand1()~ 重置种子来解决这个问题, 关键是要让 ~next~ 成为只供 ~rand1()~ 和
    ~srand1()~ 访问的内部静态变量 (~srand1()~ 相当于 C 库中的 ~srand()~ 函数). 
    把 ~srand1()~ 加入 ~rand1()~ 所在的文件中(~见 s_and_r.c~)

*** 自动重置
    如果 C 实现允许访问一些可变的量(如, 时钟系统), 可以用这些值(可能会被截断)初始
    化种子值. 例如, ANSI C 有一个 ~time()~ 函数返回系统时间.
    虽然时间单元因系统而异, 但是重点是该返回值是一个可进行运算的类型, 而且其值随
    着时间变化而变化. ~time()~ 返回值的类型名是 ~time_t~, 具体类型与系统有关. 这
    没关系, 我们可以使用强制类型转换:

    #+begin_src c
      #include <time.h>

      srand1((unsigned int)time(0)); // 初始化种子
    #+end_src

    一般而言, time()接受的参数是一个 ~time_t~ 类型对象的地址, 而时间值就存储在传
    入的地址上. 当然, 也可以传入空指针(0) 作为参数, 这种情况下, 只能通过返回值机
    制来提供值

    可以把这个技巧应用于标准 ANSI C 函数 ~srand()~ 和 ~rand()~ 中. 如果使用这些函
    数, 要在文件中包含 ~stdlib.c~ 头文件. 实际上, 既然已经明白了 ~srand1()~ 和
    ~rand1()~ 如何使用内部链接的静态变量, 也可以使用编译器提供的版本
** 掷骰子
   计算机计算不用考虑几何的限制, 所以可以设计任意面数的电子骰子. 先从 6 面开始
   
   想获得 1~6 的随机数. 然而, ~rand()~ 生成的随机数在 0~RAND_MAX 之间. RAND_MAX
   被定义在 ~stdlib.h~ 中, 其值通常是 ~INT_MAX~. 因此需要进行一些调整:
   
   1. 把随机数求模 6, 获得的整数在 0 ~ 5 之间
   2. 结果 + 1, 新值在 1 ~ 6 之间
   3. 为了方便以后扩展, 把第一步中的数字 6 替换成骰子面数
      #+begin_src c
        #include <stdlib.h>

        int rollem(int slides)
        {
          int roll;
          roll = rand() % sides + 1;
          return roll;
        }
      #+end_src
      

   程序见 ~diceroll.c~, 调用见 ~manydice.c~

   因为程序使用 ~srand()~ 随机生成随机数种子, 所以大多数情况下, 即使输入相同也很
   难得到相同的输出

   可以通过多种方式使用 ~roll_n_dice()~. ~sides == 2~ 时, 程序魔方掷硬币, 可以定
   义: "正面朝上" 为 2, "反面朝上" 为 1. 很容易修改该程序单独显示点数的结果, 或
   者构建一个骰子模拟器.

   ~rand1()~ 或 ~rand()~ 还可以来构建一个猜数字程序, 让计算机选定一个数字
