
* 第 12 章 存储类别, 链接和内存管理
  本章内容:
  如何确定变量的作用域(可见范围)和生命期(可存在时间)

** 存储类别(storage class)
   从硬件方面来看, 被储存的每个值都占用一定的物理内存, C 语言把这样的一块内存称为
   对象(object). 对象可以储存一个或多个值. 一个对象可能并为储存实际的值, 但是它
   在储存适当的值时一定具有相应的大小


   1. 变量名指定对象
      #+begin_example c
        int entity = 3;
      #+end_example

      该声明创建了一个名为 ~entity~ 的标识符(idenitifier). 标识符是一个名称, 在
      这种情况下, 标识符可以用来指定(designate)特定对象的内容. 标识符遵循变量的
      命名规则. 在该例中, 标识符 ~entity~ 即是软件(即 C 程序) *指定硬件内存中的对象的方式*. 该声明还提供了储存在对象中的值.

   2. 储存地址
      #+begin_example c
        int* pt = &entity;
        int ranks[10];
      #+end_example

      第一行中, ~pt~ 是一个标识符, 它指定了一个储存地址的对象. 但是, 表达式
      ~*pt~ 不是标识符, 因为它不是一个名称. 然而它确实指定了一个对象, 这种情况下,
      它与 ~entity~ 指定的对象相同. 

      一般而言, 那些指定对象的表达式被称为左值. 所以:
      1) ~entity~ 既是标识符也是左值
      2) ~*pt~ 既是表达式也是左值
      3) ~ranks + 2 * entity~ 既不是标识符(不是名称), 也不是左值(它不指定内存位
         置上的内容)
      4) ~*(ranks + 2 * entity)~ 是一个左值, 因为它的确指定了特定内存位置的值

         
   Tip: ranks 的声明创建了一个可容纳 10 个 ~int~ 类型元素的对象, 该数组的每个元素也
   是一个对象

   如果可以使用左值改变对象中的值, 该左值就是一个可修改的左值(modifiable value)


   #+begin_example c
     const char* pc = "Behold a string literal!";
   #+end_example

   程序根据该声明把相应的字符串字面量储存在内容中, *内含这些字符值的数组* 就是一个
   对象. 由于数组中的每个字符都能被单独访问, 所以 *每个字符* 也是一个对象. 该声
   明还创建了一个标识符为 ~pc~ 的对象, 储存着字符串的地址.

   由于 *可以设置 ~pc~ 重新指向其他字符串*, 所以标识符 ~pc~ 是一个可修改的左值
   (const 只保证刚被 ~pc~ 重新执行的字符串内容不被修改)

   由于 ~*pc~ 指定了储存 ~'B'~ 字符的数据对象, 所以 ~*pc~ 是一个左值, 但不是一个
   可修改的左值. 因为字符串字面量本身指定了储存字符串的对象, 所以它也是一个左值,
   但不是可修改的左值


   可以用 *存储期(storage duration)* 描述对象, 指的是对象在内存中保留了多长时间.
   标识符用于访问对象, 可以用 *作用域(scope)* 和 *链接(linkage)* 描述标识符, 标识符的作
   用域和链接表明了程序的哪些部分可以使用它. 不同的存储类别具有不同的存储期, 作
   用域和链接, 标识符 *可以在源代码中的多文件中共享*, *可用于特定文件的任意函数中*,
   *可仅限于特定函数中使用*, 甚至 *只在函数中的某部分使用*. 对象可存在于程序的执行期
   , 也可以仅存在于它所在函数的执行期. 
   
   对于并发编程, *对象可以在特定线程的执行期存在*. *可以通过函数调用的方式显示分配和释放内存* 
*** 作用域
    作用域描述程序中 *可访问标识符的区域* . 一个变量的作用域可以是 *块作用域*,
    *函数作用域*, *函数原型作用域* 或 *文件作用域*.

    1. 块作用域
       块是用一对花括号括起来的代码区域. 例如: 整个函数体是一个块, 函数中的任意
       符合语句也是一个块. 定义在块中的变量具有块作用域(block scope). 

       块作用域变量的可见范围是 *从定义处到包含该定义的块的结尾*

       虽然函数的形式参数声明在函数的左花括号之前, 但是它们也具有块作用域, 属于
       函数体这个块. 所以目前为止, 我们使用的局部变量(包括函数的形式参数)都具有
       块作用域.

       以下代码都具有块作用域
       #+begin_src c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           // ...

           return patrick;
         }
       #+end_src

       #+begin_example c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           int i;

           for (i = 0; i < 10; ++i) {
             double q = cleo * i; // q的作用域开始
             // ...
             patrick *= q; // q的作用域结束
           }

           return patrick;
         }
       #+end_example

       自 C99 标准起, 允许在块中的任意位置声明变量

       为了适应这个特性, C99 把块的概念扩展到包括 for 循环, while 循环, do while
       循环和 if 语句所控制的代码, 即使这些代码没有用花括号括起来, 也算是块的一
       部分

    2. 函数作用域
       函数作用域(function scope) 仅用于 *goto* 语句的标签. 

       这意味着即使一个标签首次出现在函数的内层块中, 它的所用于也延伸至整个函数.
       如果在 2 个块中使用相同的标签会很混乱, 标签的函数作用域防止了这样的事情发生
       
    3. 函数原型作用域
       函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名)

       函数原型作用域的范围是从形参定义处到原型结束. 这意味着, 编译器在处理函数
       原型中的形参时只关心它的类型, 而参数名通常无关紧要. 而且, 即使有参数名,
       也不必与函数定义中的形参名相匹配.

       只有在变长数组中, 形参名才有用:
       #+begin_src c
         void use_a_VLA(int n, int m, int ar[n][m]);
       #+end_src

       方括号中必须使用在函数原型中已声明的名称

    4. 文件作用域
       变量的定义在函数的外面, 具有文件作用域(file scope). 具有文件作用域的变量,
       从它的定义处到该定义所在文件的末尾均可见
       
       文件作用域也称为全局变量(global variable)

       
    注意: 翻译单元和文件
    多个文件在编译器中可能以一个文件出现. 通常才源代码(.c 扩展名)中包含一个或多个
    头文件(.h 扩展名). 头文件会依次包含其他头文件, 所以会包含多个单独的物理文件.

    但是, C 预处理器实际上是用包含的头文件内容替换 ~#include~ 指令. 所以,编译器源
    代码文件和所有的头文件都看成是一个包含信息的单独文件. 这个文件被称为翻译单元
    (translation unit). 描述一个具有文件作用域的变量时, 它的实际可见范围是整个翻
    译单元.如果程序由多个源代码文件组成, 那么该程序也将由多个翻译单元组成. 每个
    翻译单元均对应一个源代码文件和它所包含的文件

*** 链接
    C 变量有 3 种链接属性: 外部链接, 内部链接, 无链接.

    具有块作用域, 函数作用域或函数原型作用域的变量都是无链接变量.这意味着这些变
    量属于它们的块, 函数或原型私有. 

    具有文件作用域的变量可以是外部链接或内部链接.外部链接变量可以在多文件程序中
    使用, 内部链接变量只能在一个翻译单元中使用
    
    *注意*: 正式和非正式术语

    C 标准用"内部链接的文件作用域"描述仅限于一个 *翻译单元(即一个源代码文件和它所
    包含的头文件)* 的作用域, 用 "外部链接的文件作用域" 描述可延伸至其他翻译单元
    的作用域. 

    简称: "内部链接文件的作用域" -> "文件作用域", "外部连接的文件作用域" -> "全
    局作用域" 或 "程序作用域"

    #+begin_src c
      int giants = 5; // 文件作用域, 外部链接
      static int dodgers = 3; // 文件作用域,内部链接

      int main()
      {
        // ...
        return 0;
      }

      // ...
    #+end_src

    该文件和同一程序的其他文件都可以使用变量 giants, 而变量 dodgers 属文件私有,
    该文件的任意函数都可以使用它

*** 存储期
    作用域和链接描述了标识符的可见性. 
    存储期描述了通过这些标识符访问的对象的生存期. C 对象有 4 种存储期: 静态存储期,
    线程存储期, 自动存储期, 动态分配存储期

    1. 静态存储期
       如果对象具有静态存储期, 那么它在程序的执行期间一直存在. 文件作用域变量具
       有静态存储期.

       *注意*: 对于文件作用域变量, 关键字 ~static~ 表明其连接属性, 而非存储期.
       以 ~static~ 声明的文件作用域变量具有内部链接. 但是无论是内部链接还是外部
       链接, 所有的文件作用域变量都具有静态存储期

    2. 线程存储期
       线程存储期用于并发程序设计, 程序执行可被分为多个线程. 具有线程存储期的对
       象, 从被声明时到线程结束一直存在. 以关键字 ~_Thread_local~ 声明一个对象时,
       每个线程都获得该变量的私有备份.

    3. 自动存储期
       块作用域的变量通常都具有自动存储期. 当程序进入定义这些变量的块时, 为这些
       变量分配内存; 当退出这个块时, 释放刚才为变量分配的内存.

       这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区.

       例如: 一个函数调用结束后, 其变量占用的内存可用于存储下一个被调用函数的变
       量.

       变长数组(VLA) 稍有不同, 它们的存储期从声明处到块的末尾, 而不是从块开始处
       到块的末尾.

       到目前为止使用的局部变量都是自动类别

       块作用域变量也能具有静态存储期.

       例:
       #+begin_src c
         void more(int number)
         {
           int index;
           static int ct = 0;
           // ...
           return 0;
         }
       #+end_src

       *注意*: 变量 ~ct~ 储存在静态内存中, 它 *从程序被载入到程序结束期间都存在*.
       但是, 它的作用域定义在 ~more()~ 函数块中. 只有在执行函数时, 程序才能使用
       ~ct~ 访问它所指定的对象(但是, 该函数可以给其他函数提供该存储区的地址以便
       简介访问该对象, 例如通过指针形参或返回值)

       
    | 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                     |
    |--------------+--------+--------+------+------------------------------|
    | 自动         | 自动   | 块     | 无   | 块内                         |
    | 寄存器       | 自动   | 块     | 无   | 块内, 使用关键字 register     |
    | 静态外部链接 | 静态   | 文件   | 外部 | 所有函数外                   |
    | 静态内部链接 | 静态   | 文件   | 内部 | 所有函数外, 使用关键字 static |
    | 静态无链接   | 静态   | 块     | 无   | 块内, 使用关键字 static       |
*** 自动变量
    属于自动存储类别的变量具有自动存储期, 块作用域且无链接. 

    默认情况下, 声明在块或函数头中的任何变量都属于自动存储类别.

    为了更清楚的表达意图(为了表明有意覆盖一个外部变量定义, 或者强调把该变量的类
    别改为其他存储类别), 可以使用显示关键字 ~auto~

    #+begin_src c
      int main(void)
      {
        auto int index;
        return 0;
      }
    #+end_src

    关键字 ~auto~ 是存储类别说明符(storage-class specifier).

    块作用域和无链接意味着 *只有在变量定义处所在的块中才能通过变量名访问该变量*
    (地址传递除外).
    另一个函数可以使用同名变量, 但是该变量是储存在不同内存位置上的另一个变量

    变量具有自动存储期意味着: 程序在进入该变量声明所在的块时变量存在, 程序在退出
    该块时变量消失. 原来该变量占用的内存位置现在可做他用.

    嵌套块示例:
    #+begin_src c
      int loop(int n)
      {
        int m; // m的作用域
        scanf("%d", &m);

        {
          int i; // m 和 i的作用域
          for (i = m; i < n; i++)
            puts("i is local to a sub-block\n");
        }

        return m; // m的作用域, i已经消失
      }
    #+end_src

    当内层块与外层同名: ~见 hiding.c~

    1. 没有花括号的块
       C99特性: 作为循环或if语句的一部分, 即使不使用花括号({}), 也是一个块.
       更完整的说, 整个循环是它所在块的子块(sub-block), 循环体是整个循环块的子块.
       与此类似, if语句是一个块, 与其相关联的子语句是if语句的子块.这些规则会影响
       到声明的变量和这些变量的作用域

       *易证: 每次块作用域内的变量内存地址相同*

    2. 自动变量的初始化
       自动变量 *不会初始化*, 必须显式初始化
       #+begin_src c
         int main()
         {
           // 未初始化, 值不是0
           int ruth;
           int tens = 5;

           return 0;
         }
       #+end_src

       可以用非常量表达式(non-constant expression)初始化自动变量:
       #+begin_src c
         int main()
         {
           int ruth = 1;
           int rance = 5 * ruth;

           return 0;
         }
       #+end_src
       
       
*** 寄存器变量
    变量通常存储在计算机内存中. *如果幸运的话*, 寄存器变量存储在CPU的寄存器中,
    或者概括地说, 储存在 *最快* 的可用内存中.
    
    与普通变量相比, 访问和处理这些变量的速度更快. 由于寄存器变量储存在寄存器而非
    内存中, 所以 *无法获取寄存器变量的地址*. 绝大多数方面, 寄存器变量和自动变量
    都一样.都是 *块作用域*, *无链接* 和 *自动存储期*.

    使用存储类别说明符 ~register~ 便可声明寄存器变量:
    
    #+begin_src c
      int main()
      {
        register int quick;
  
        return 0;
      }
    #+end_src

    寄存器变量申请可能失败, 失败则回退至普通变量, 尽管如此, *依旧不能对该变量使
    用地址运算符*

    在函数头中使用:
    #+begin_src c
      void macho(register int n);
    #+end_src

    可声明为 ~register~ 的数据类型有限.
    例如, 处理器中的寄存器可能没有足够大的空间来存储 ~double~ 类型的值
*** 块作用域的静态变量
    静态变量(static variable)听起来自相矛盾, 像是一个不可变的变量.
    实际上, 静态的意思是该变量在内存中原地不动, 并不是说它的值不变.
    其有文件作用域的变量自动具有(也必须是)静态存储期. 前面提到过, 可以创建具有静
    态存储期, 块作用域的局部变量. 

    这些变量和自动变量一样, 具有相同的作用域, 但是程序离开它们所在的函数后, 这些
    变量不会消失. 也就是说, 这种变量具有块级作用域, 无链接, 但是具有静态存储期.
    
    *计算机在多次函数调用之间会记录它们的值*. 在块中(提供块作用域和无链接)以存储类
    别说明符 ~static~ (提供静态存储期)声明这种变量

    *注解*: 编译时初始化, 若未初始化会初始化一个合法值

    *注意*: 不能在函数的形参中使用static
    #+begin_src c
      int wontwork(static int flu); // 不允许
    #+end_src

    "局部静态变量" 是描述具有块作用域的静态变量的另一个术语. 这种存储类别别称为
    内部静态存储类别(internal static storage class). 
    这里的内部指的是 *函数内部*, 而非内部链接


*** 外部链接的静态变量
    外部链接的静态变量具有文件作用域, 外部链接和静态存储期.
    该类别有时称为 *外部存储类别(external storage class)*, 属于该类别的变量称为
    *外部变量(external variable)*. 把变量的定义性声明(defining declaration) 放在
    所有函数的外面便创建了外部变量. 当然, 为了指出该函数使用了外部变量, 可以在函
    数中用关键字 ~extern~ 再次声明. 如果一个源代码文件使用的外部变量定义在另一个
    源代码文件中, 则必须用 ~extern~ 在该文件中声明该变量
    #+begin_src c
      int Errupt; // 外部定义的变量

      double Up[100]; // 外部定义的数组
      extern char Coal; // 如果Coal被定义在另一个文件

      void next();

      int main()
      {
        extern int Errupt; // 可选声明
        extern double Up[]; // 可选声明, 此处不用声明大小, 因为第一次声明提供了
      }

      void next()
      {
        // ...
      }
    #+end_src

    
    main中两条声明完全可以省略, 因为 *外部变量具有文件作用域*, 所以 ~Errupt~ 和
    ~Up~ 从声明处到文件结尾都可见. 它们出现在那里, 仅为了说明 ~main*()~ 函数要使
    用这2个变量

    如果省略掉函数中的 ~extern~ 关键字, 相当于创建了一个自动变量.
    例:
    #+begin_src c
      extern int Errupt;
    #+end_src
    #+begin_src c
      int Errupt;
    #+end_src

    这使得编译器在 ~main()~ 中创建了一个名为 ~Errupt~ 的自动变量. 它是一个独立的
    局部变量, 与原来的外部变量 ~Errupt~ 不同. 该局部变量仅 ~main()~ 中可见, 但是
    外部变量对该文件的其他函数也可见.
    
    简而言之, 在执行块中的语句时, 块作用域中的变量将 "隐藏" 文件作用域中的同名变
    量.

    如果不得已要使用与外部变量同名的局部变量, 可以在局部变量的声明中使用 ~auto~
    存储类别说明符明确表达这种意图

    外部变量具有静态存储期, 因此, 无论程序执行到任何函数, 其值都 *一直存在*

    示例:
    1. 外部变量 ~Hocus~, 对 ~main()~ 和 ~magic()~ 均可见
       #+begin_src c
         int Hocus;
         int magic();
         int main()
         {
           extern int Hocus; // Hocus之前已声明为外部变量
         }

         int magic()
         {
           extern int Hocus; // 与上面的Hocus是同一变量
         }
       #+end_src

    2. 外部变量 ~Hocus~, 对2个函数均可见, 在默认情况下对 ~magic()~ 可见
       #+begin_src c
         int Hocus;
         int magic();
         int main()
         {
           extern int Hocus; // Hocus之前已声明为外部变量
         }

         int magic()
         {
           // 并未在该函数中声明Hocus, 但是仍可使用该变量
         }
       #+end_src

    3. 创建了4个独立变量, ~main()~ 中的 ~Hocus~ 变量默认是自动变量, 属于
       ~main()~ 私有. ~magic()~ 中的 ~Hocus~ 变量被显式声明为自动, 只有
       ~magic()~ 可用. 外部变量对 ~main()~ 和 ~magic()~ 均不可见, 但是对该文件中
       未创建局部 ~Hocus~ 变量的其他函数可见. 最后, ~Pocus~ 是外部变量,
       ~magic()~ 可见, 但是 ~main()~ 不可见, 因为 ~Pocus~ 被声明在 ~main()~ 后面

       #+begin_src c
         int Hocus;
         int magic();

         int main()
         {
           int Hocus; // 默认自动变量
         }

         int Pocus;

         int magic()
         {
           auto int Hocus; // 把局部变量 Hocus 显式声明为自动变量
         }
       #+end_src

       外部变量的作用域: *从声明处到文件结尾*
       外部变量的声明周期: *在程序中一直存在*


**** 初始化外部变量
     外部变量和自动变量类似, 也可以被显式初始化. 与自动变量不同的是, 如果未初始
     化外部变量, 它们会自动初始化为0. 这一原则也适用于外部定义的数组元素.
     与自动变量的情况不同, 只能使用常量表达式初始化文件作用域变量
     #+begin_src c
       int x = 10; // OK
       int y = 3 + 20; // OK
       size_t z = sizeof(int); // OK
       int x2 = 2 * x; // Error
     #+end_src

     *注意*: 只要不是变长数组(VLA), ~sizeof~ 表达式可视为常量表达式

**** 使用外部变量
     使用外部变量的示例. ~见 global.c~

**** 外部名称
     C99和C11 标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符.
     这修订了以前的标准, 即编译器识别局部标识符前31个字符和外部标识符前6个字符.
     

     外部变量名比局部变量名的规则严格, 是因为外部变量名还要遵循局部环境规则, 所
     受限制的更多

**** 定义和声明

     例:
     #+begin_src c
       int tern = 1; // tern被定义

       main()
       {
         extern int tern; // 使用在别处定义的tern
       }
     #+end_src
     
     ~tern~ 被声明了2次, 第一次声明为变量预留了存储空间, 该声明构成了变量的定义.
     第二次声明只告诉编译器使用之前已创建的 ~tern~ 变量, 所以这不是定义.

     第一次声明被称为定义式声明(defining declaration)

     第二次声明被称为引用式声明(referencing declaration)

     关键字 ~extern~ 表明该声明不是定义, 因为它指示编译器去别处查询其定义

     外部变量 *只能初始化一次*, 且 *必须在定义该变量时进行*
