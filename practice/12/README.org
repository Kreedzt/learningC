
* 第 12 章 存储类别, 链接和内存管理
  本章内容:
  如何确定变量的作用域(可见范围)和生命期(可存在时间)

** 存储类别(storage class)
   从硬件方面来看, 被储存的每个值都占用一定的物理内存, C 语言把这样的一块内存称为
   对象(object). 对象可以储存一个或多个值. 一个对象可能并为储存实际的值, 但是它
   在储存适当的值时一定具有相应的大小


   1. 变量名指定对象
      #+begin_example c
        int entity = 3;
      #+end_example

      该声明创建了一个名为 ~entity~ 的标识符(idenitifier). 标识符是一个名称, 在
      这种情况下, 标识符可以用来指定(designate)特定对象的内容. 标识符遵循变量的
      命名规则. 在该例中, 标识符 ~entity~ 即是软件(即 C 程序) *指定硬件内存中的对象的方式*. 该声明还提供了储存在对象中的值.

   2. 储存地址
      #+begin_example c
        int* pt = &entity;
        int ranks[10];
      #+end_example

      第一行中, ~pt~ 是一个标识符, 它指定了一个储存地址的对象. 但是, 表达式
      ~*pt~ 不是标识符, 因为它不是一个名称. 然而它确实指定了一个对象, 这种情况下,
      它与 ~entity~ 指定的对象相同. 

      一般而言, 那些指定对象的表达式被称为左值. 所以:
      1) ~entity~ 既是标识符也是左值
      2) ~*pt~ 既是表达式也是左值
      3) ~ranks + 2 * entity~ 既不是标识符(不是名称), 也不是左值(它不指定内存位
         置上的内容)
      4) ~*(ranks + 2 * entity)~ 是一个左值, 因为它的确指定了特定内存位置的值

         
   Tip: ranks 的声明创建了一个可容纳 10 个 ~int~ 类型元素的对象, 该数组的每个元素也
   是一个对象

   如果可以使用左值改变对象中的值, 该左值就是一个可修改的左值(modifiable value)


   #+begin_example c
     const char* pc = "Behold a string literal!";
   #+end_example

   程序根据该声明把相应的字符串字面量储存在内容中, *内含这些字符值的数组* 就是一个
   对象. 由于数组中的每个字符都能被单独访问, 所以 *每个字符* 也是一个对象. 该声
   明还创建了一个标识符为 ~pc~ 的对象, 储存着字符串的地址.

   由于 *可以设置 ~pc~ 重新指向其他字符串*, 所以标识符 ~pc~ 是一个可修改的左值
   (const 只保证刚被 ~pc~ 重新执行的字符串内容不被修改)

   由于 ~*pc~ 指定了储存 ~'B'~ 字符的数据对象, 所以 ~*pc~ 是一个左值, 但不是一个
   可修改的左值. 因为字符串字面量本身指定了储存字符串的对象, 所以它也是一个左值,
   但不是可修改的左值


   可以用 *存储期(storage duration)* 描述对象, 指的是对象在内存中保留了多长时间.
   标识符用于访问对象, 可以用 *作用域(scope)* 和 *链接(linkage)* 描述标识符, 标识符的作
   用域和链接表明了程序的哪些部分可以使用它. 不同的存储类别具有不同的存储期, 作
   用域和链接, 标识符 *可以在源代码中的多文件中共享*, *可用于特定文件的任意函数中*,
   *可仅限于特定函数中使用*, 甚至 *只在函数中的某部分使用*. 对象可存在于程序的执行期
   , 也可以仅存在于它所在函数的执行期. 
   
   对于并发编程, *对象可以在特定线程的执行期存在*. *可以通过函数调用的方式显示分配和释放内存* 
*** 作用域
    作用域描述程序中 *可访问标识符的区域* . 一个变量的作用域可以是 *块作用域*,
    *函数作用域*, *函数原型作用域* 或 *文件作用域*.

    1. 块作用域
       块是用一对花括号括起来的代码区域. 例如: 整个函数体是一个块, 函数中的任意
       符合语句也是一个块. 定义在块中的变量具有块作用域(block scope). 

       块作用域变量的可见范围是 *从定义处到包含该定义的块的结尾*

       虽然函数的形式参数声明在函数的左花括号之前, 但是它们也具有块作用域, 属于
       函数体这个块. 所以目前为止, 我们使用的局部变量(包括函数的形式参数)都具有
       块作用域.

       以下代码都具有块作用域
       #+begin_src c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           // ...

           return patrick;
         }
       #+end_src

       #+begin_example c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           int i;

           for (i = 0; i < 10; ++i) {
             double q = cleo * i; // q的作用域开始
             // ...
             patrick *= q; // q的作用域结束
           }

           return patrick;
         }
       #+end_example

       自 C99 标准起, 允许在块中的任意位置声明变量

       为了适应这个特性, C99 把块的概念扩展到包括 for 循环, while 循环, do while
       循环和 if 语句所控制的代码, 即使这些代码没有用花括号括起来, 也算是块的一
       部分

    2. 函数作用域
       函数作用域(function scope) 仅用于 *goto* 语句的标签. 

       这意味着即使一个标签首次出现在函数的内层块中, 它的所用于也延伸至整个函数.
       如果在 2 个块中使用相同的标签会很混乱, 标签的函数作用域防止了这样的事情发生

    3. 函数原型作用域
       函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名)

       函数原型作用域的范围是从形参定义处到原型结束. 这意味着, 编译器在处理函数
       原型中的形参时只关心它的类型, 而参数名通常无关紧要. 而且, 即使有参数名,
       也不必与函数定义中的形参名相匹配.

       只有在变长数组中, 形参名才有用:
       #+begin_src c
         void use_a_VLA(int n, int m, int ar[n][m]);
       #+end_src

       方括号中必须使用在函数原型中已声明的名称

    4. 文件作用域
       变量的定义在函数的外面, 具有文件作用域(file scope). 具有文件作用域的变量,
       从它的定义处到该定义所在文件的末尾均可见
       
       文件作用域也称为全局变量(global variable)

       
    注意: 翻译单元和文件
    多个文件在编译器中可能以一个文件出现. 通常才源代码(.c 扩展名)中包含一个或多个
    头文件(.h 扩展名). 头文件会依次包含其他头文件, 所以会包含多个单独的物理文件.

    但是, C 预处理器实际上是用包含的头文件内容替换 ~#include~ 指令. 所以,编译器源
    代码文件和所有的头文件都看成是一个包含信息的单独文件. 这个文件被称为翻译单元
    (translation unit). 描述一个具有文件作用域的变量时, 它的实际可见范围是整个翻
    译单元.如果程序由多个源代码文件组成, 那么该程序也将由多个翻译单元组成. 每个
    翻译单元均对应一个源代码文件和它所包含的文件

