
* 第 12 章 存储类别, 链接和内存管理
  本章内容:
  如何确定变量的作用域(可见范围)和生命期(可存在时间)

** 存储类别(storage class)
   从硬件方面来看, 被储存的每个值都占用一定的物理内存, C 语言把这样的一块内存称为
   对象(object). 对象可以储存一个或多个值. 一个对象可能并为储存实际的值, 但是它
   在储存适当的值时一定具有相应的大小


   1. 变量名指定对象
      #+begin_example c
        int entity = 3;
      #+end_example

      该声明创建了一个名为 ~entity~ 的标识符(idenitifier). 标识符是一个名称, 在
      这种情况下, 标识符可以用来指定(designate)特定对象的内容. 标识符遵循变量的
      命名规则. 在该例中, 标识符 ~entity~ 即是软件(即 C 程序) *指定硬件内存中的对象的方式*. 该声明还提供了储存在对象中的值.

   2. 储存地址
      #+begin_example c
        int* pt = &entity;
        int ranks[10];
      #+end_example

      第一行中, ~pt~ 是一个标识符, 它指定了一个储存地址的对象. 但是, 表达式
      ~*pt~ 不是标识符, 因为它不是一个名称. 然而它确实指定了一个对象, 这种情况下,
      它与 ~entity~ 指定的对象相同. 

      一般而言, 那些指定对象的表达式被称为左值. 所以:
      1) ~entity~ 既是标识符也是左值
      2) ~*pt~ 既是表达式也是左值
      3) ~ranks + 2 * entity~ 既不是标识符(不是名称), 也不是左值(它不指定内存位
         置上的内容)
      4) ~*(ranks + 2 * entity)~ 是一个左值, 因为它的确指定了特定内存位置的值

         
   Tip: ranks 的声明创建了一个可容纳 10 个 ~int~ 类型元素的对象, 该数组的每个元素也
   是一个对象

   如果可以使用左值改变对象中的值, 该左值就是一个可修改的左值(modifiable value)


   #+begin_example c
     const char* pc = "Behold a string literal!";
   #+end_example

   程序根据该声明把相应的字符串字面量储存在内容中, *内含这些字符值的数组* 就是一个
   对象. 由于数组中的每个字符都能被单独访问, 所以 *每个字符* 也是一个对象. 该声
   明还创建了一个标识符为 ~pc~ 的对象, 储存着字符串的地址.

   由于 *可以设置 ~pc~ 重新指向其他字符串*, 所以标识符 ~pc~ 是一个可修改的左值
   (const 只保证刚被 ~pc~ 重新执行的字符串内容不被修改)

   由于 ~*pc~ 指定了储存 ~'B'~ 字符的数据对象, 所以 ~*pc~ 是一个左值, 但不是一个
   可修改的左值. 因为字符串字面量本身指定了储存字符串的对象, 所以它也是一个左值,
   但不是可修改的左值


   可以用 *存储期(storage duration)* 描述对象, 指的是对象在内存中保留了多长时间.
   标识符用于访问对象, 可以用 *作用域(scope)* 和 *链接(linkage)* 描述标识符, 标识符的作
   用域和链接表明了程序的哪些部分可以使用它. 不同的存储类别具有不同的存储期, 作
   用域和链接, 标识符 *可以在源代码中的多文件中共享*, *可用于特定文件的任意函数中*,
   *可仅限于特定函数中使用*, 甚至 *只在函数中的某部分使用*. 对象可存在于程序的执行期
   , 也可以仅存在于它所在函数的执行期. 
   
   对于并发编程, *对象可以在特定线程的执行期存在*. *可以通过函数调用的方式显示分配和释放内存* 
*** 作用域
    作用域描述程序中 *可访问标识符的区域* . 一个变量的作用域可以是 *块作用域*,
    *函数作用域*, *函数原型作用域* 或 *文件作用域*.

    1. 块作用域
       块是用一对花括号括起来的代码区域. 例如: 整个函数体是一个块, 函数中的任意
       符合语句也是一个块. 定义在块中的变量具有块作用域(block scope). 

       块作用域变量的可见范围是 *从定义处到包含该定义的块的结尾*

       虽然函数的形式参数声明在函数的左花括号之前, 但是它们也具有块作用域, 属于
       函数体这个块. 所以目前为止, 我们使用的局部变量(包括函数的形式参数)都具有
       块作用域.

       以下代码都具有块作用域
       #+begin_src c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           // ...

           return patrick;
         }
       #+end_src

       #+begin_example c
         double blocky(double cleo)
         {
           double patrick = 0.0;
           int i;

           for (i = 0; i < 10; ++i) {
             double q = cleo * i; // q的作用域开始
             // ...
             patrick *= q; // q的作用域结束
           }

           return patrick;
         }
       #+end_example

       自 C99 标准起, 允许在块中的任意位置声明变量

       为了适应这个特性, C99 把块的概念扩展到包括 for 循环, while 循环, do while
       循环和 if 语句所控制的代码, 即使这些代码没有用花括号括起来, 也算是块的一
       部分

    2. 函数作用域
       函数作用域(function scope) 仅用于 *goto* 语句的标签. 

       这意味着即使一个标签首次出现在函数的内层块中, 它的所用于也延伸至整个函数.
       如果在 2 个块中使用相同的标签会很混乱, 标签的函数作用域防止了这样的事情发生
       
    3. 函数原型作用域
       函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名)

       函数原型作用域的范围是从形参定义处到原型结束. 这意味着, 编译器在处理函数
       原型中的形参时只关心它的类型, 而参数名通常无关紧要. 而且, 即使有参数名,
       也不必与函数定义中的形参名相匹配.

       只有在变长数组中, 形参名才有用:
       #+begin_src c
         void use_a_VLA(int n, int m, int ar[n][m]);
       #+end_src

       方括号中必须使用在函数原型中已声明的名称

    4. 文件作用域
       变量的定义在函数的外面, 具有文件作用域(file scope). 具有文件作用域的变量,
       从它的定义处到该定义所在文件的末尾均可见
       
       文件作用域也称为全局变量(global variable)

       
    注意: 翻译单元和文件
    多个文件在编译器中可能以一个文件出现. 通常才源代码(.c 扩展名)中包含一个或多个
    头文件(.h 扩展名). 头文件会依次包含其他头文件, 所以会包含多个单独的物理文件.

    但是, C 预处理器实际上是用包含的头文件内容替换 ~#include~ 指令. 所以,编译器源
    代码文件和所有的头文件都看成是一个包含信息的单独文件. 这个文件被称为翻译单元
    (translation unit). 描述一个具有文件作用域的变量时, 它的实际可见范围是整个翻
    译单元.如果程序由多个源代码文件组成, 那么该程序也将由多个翻译单元组成. 每个
    翻译单元均对应一个源代码文件和它所包含的文件

*** 链接
    C 变量有 3 种链接属性: 外部链接, 内部链接, 无链接.

    具有块作用域, 函数作用域或函数原型作用域的变量都是无链接变量.这意味着这些变
    量属于它们的块, 函数或原型私有. 

    具有文件作用域的变量可以是外部链接或内部链接.外部链接变量可以在多文件程序中
    使用, 内部链接变量只能在一个翻译单元中使用
    
    *注意*: 正式和非正式术语

    C 标准用"内部链接的文件作用域"描述仅限于一个 *翻译单元(即一个源代码文件和它所
    包含的头文件)* 的作用域, 用 "外部链接的文件作用域" 描述可延伸至其他翻译单元
    的作用域. 

    简称: "内部链接文件的作用域" -> "文件作用域", "外部连接的文件作用域" -> "全
    局作用域" 或 "程序作用域"

    #+begin_src c
      int giants = 5; // 文件作用域, 外部链接
      static int dodgers = 3; // 文件作用域,内部链接

      int main()
      {
        // ...
        return 0;
      }

      // ...
    #+end_src

    该文件和同一程序的其他文件都可以使用变量 giants, 而变量 dodgers 属文件私有,
    该文件的任意函数都可以使用它

*** 存储期
    作用域和链接描述了标识符的可见性. 
    存储期描述了通过这些标识符访问的对象的生存期. C 对象有 4 种存储期: 静态存储期,
    线程存储期, 自动存储期, 动态分配存储期

    1. 静态存储期
       如果对象具有静态存储期, 那么它在程序的执行期间一直存在. 文件作用域变量具
       有静态存储期.

       *注意*: 对于文件作用域变量, 关键字 ~static~ 表明其连接属性, 而非存储期.
       以 ~static~ 声明的文件作用域变量具有内部链接. 但是无论是内部链接还是外部
       链接, 所有的文件作用域变量都具有静态存储期

    2. 线程存储期
       线程存储期用于并发程序设计, 程序执行可被分为多个线程. 具有线程存储期的对
       象, 从被声明时到线程结束一直存在. 以关键字 ~_Thread_local~ 声明一个对象时,
       每个线程都获得该变量的私有备份.

    3. 自动存储期
       块作用域的变量通常都具有自动存储期. 当程序进入定义这些变量的块时, 为这些
       变量分配内存; 当退出这个块时, 释放刚才为变量分配的内存.

       这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区.

       例如: 一个函数调用结束后, 其变量占用的内存可用于存储下一个被调用函数的变
       量.

       变长数组(VLA) 稍有不同, 它们的存储期从声明处到块的末尾, 而不是从块开始处
       到块的末尾.

       到目前为止使用的局部变量都是自动类别

       块作用域变量也能具有静态存储期.

       例:
       #+begin_src c
         void more(int number)
         {
           int index;
           static int ct = 0;
           // ...
           return 0;
         }
       #+end_src

       *注意*: 变量 ~ct~ 储存在静态内存中, 它 *从程序被载入到程序结束期间都存在*.
       但是, 它的作用域定义在 ~more()~ 函数块中. 只有在执行函数时, 程序才能使用
       ~ct~ 访问它所指定的对象(但是, 该函数可以给其他函数提供该存储区的地址以便
       简介访问该对象, 例如通过指针形参或返回值)

       
    | 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                     |
    |--------------+--------+--------+------+------------------------------|
    | 自动         | 自动   | 块     | 无   | 块内                         |
    | 寄存器       | 自动   | 块     | 无   | 块内, 使用关键字 register     |
    | 静态外部链接 | 静态   | 文件   | 外部 | 所有函数外                   |
    | 静态内部链接 | 静态   | 文件   | 内部 | 所有函数外, 使用关键字 static |
    | 静态无链接   | 静态   | 块     | 无   | 块内, 使用关键字 static       |
*** 自动变量
    属于自动存储类别的变量具有自动存储期, 块作用域且无链接. 

    默认情况下, 声明在块或函数头中的任何变量都属于自动存储类别.

    为了更清楚的表达意图(为了表明有意覆盖一个外部变量定义, 或者强调把该变量的类
    别改为其他存储类别), 可以使用显示关键字 ~auto~

    #+begin_src c
      int main(void)
      {
        auto int index;
        return 0;
      }
    #+end_src

    关键字 ~auto~ 是存储类别说明符(storage-class specifier).

    块作用域和无链接意味着 *只有在变量定义处所在的块中才能通过变量名访问该变量*
    (地址传递除外).
    另一个函数可以使用同名变量, 但是该变量是储存在不同内存位置上的另一个变量

    变量具有自动存储期意味着: 程序在进入该变量声明所在的块时变量存在, 程序在退出
    该块时变量消失. 原来该变量占用的内存位置现在可做他用.

    嵌套块示例:
    #+begin_src c
      int loop(int n)
      {
        int m; // m的作用域
        scanf("%d", &m);

        {
          int i; // m 和 i的作用域
          for (i = m; i < n; i++)
            puts("i is local to a sub-block\n");
        }

        return m; // m的作用域, i已经消失
      }
    #+end_src

    当内层块与外层同名: ~见 hiding.c~

    1. 没有花括号的块
       C99 特性: 作为循环或 if 语句的一部分, 即使不使用花括号({}), 也是一个块.
       更完整的说, 整个循环是它所在块的子块(sub-block), 循环体是整个循环块的子块.
       与此类似, if 语句是一个块, 与其相关联的子语句是 if 语句的子块.这些规则会影响
       到声明的变量和这些变量的作用域

       *易证: 每次块作用域内的变量内存地址相同*

    2. 自动变量的初始化
       自动变量 *不会初始化*, 必须显式初始化
       #+begin_src c
         int main()
         {
           // 未初始化, 值不是0
           int ruth;
           int tens = 5;

           return 0;
         }
       #+end_src

       可以用非常量表达式(non-constant expression)初始化自动变量:
       #+begin_src c
         int main()
         {
           int ruth = 1;
           int rance = 5 * ruth;

           return 0;
         }
       #+end_src
       
       
*** 寄存器变量
    变量通常存储在计算机内存中. *如果幸运的话*, 寄存器变量存储在 CPU 的寄存器中,
    或者概括地说, 储存在 *最快* 的可用内存中.
    
    与普通变量相比, 访问和处理这些变量的速度更快. 由于寄存器变量储存在寄存器而非
    内存中, 所以 *无法获取寄存器变量的地址*. 绝大多数方面, 寄存器变量和自动变量
    都一样.都是 *块作用域*, *无链接* 和 *自动存储期*.

    使用存储类别说明符 ~register~ 便可声明寄存器变量:
    
    #+begin_src c
      int main()
      {
        register int quick;
  
        return 0;
      }
    #+end_src

    寄存器变量申请可能失败, 失败则回退至普通变量, 尽管如此, *依旧不能对该变量使
    用地址运算符*

    在函数头中使用:
    #+begin_src c
      void macho(register int n);
    #+end_src

    可声明为 ~register~ 的数据类型有限.
    例如, 处理器中的寄存器可能没有足够大的空间来存储 ~double~ 类型的值

*** 块作用域的静态变量
    静态变量(static variable)听起来自相矛盾, 像是一个不可变的变量.
    实际上, 静态的意思是该变量在内存中原地不动, 并不是说它的值不变.
    其有文件作用域的变量自动具有(也必须是)静态存储期. 前面提到过, 可以创建具有静
    态存储期, 块作用域的局部变量. 

    这些变量和自动变量一样, 具有相同的作用域, 但是程序离开它们所在的函数后, 这些
    变量不会消失. 也就是说, 这种变量具有块级作用域, 无链接, 但是具有静态存储期.
    
    *计算机在多次函数调用之间会记录它们的值*. 在块中(提供块作用域和无链接)以存储类
    别说明符 ~static~ (提供静态存储期)声明这种变量

    *注解*: 编译时初始化, 若未初始化会初始化一个合法值

    *注意*: 不能在函数的形参中使用 static
    #+begin_src c
      int wontwork(static int flu); // 不允许
    #+end_src

    "局部静态变量" 是描述具有块作用域的静态变量的另一个术语. 这种存储类别别称为
    内部静态存储类别(internal static storage class). 
    这里的内部指的是 *函数内部*, 而非内部链接


*** 外部链接的静态变量
    外部链接的静态变量具有文件作用域, 外部链接和静态存储期.
    该类别有时称为 *外部存储类别(external storage class)*, 属于该类别的变量称为
    *外部变量(external variable)*. 把变量的定义性声明(defining declaration) 放在
    所有函数的外面便创建了外部变量. 当然, 为了指出该函数使用了外部变量, 可以在函
    数中用关键字 ~extern~ 再次声明. 如果一个源代码文件使用的外部变量定义在另一个
    源代码文件中, 则必须用 ~extern~ 在该文件中声明该变量
    #+begin_src c
      int Errupt; // 外部定义的变量

      double Up[100]; // 外部定义的数组
      extern char Coal; // 如果Coal被定义在另一个文件

      void next();

      int main()
      {
        extern int Errupt; // 可选声明
        extern double Up[]; // 可选声明, 此处不用声明大小, 因为第一次声明提供了
      }

      void next()
      {
        // ...
      }
    #+end_src

    
    main 中两条声明完全可以省略, 因为 *外部变量具有文件作用域*, 所以 ~Errupt~ 和
    ~Up~ 从声明处到文件结尾都可见. 它们出现在那里, 仅为了说明 ~main*()~ 函数要使
    用这 2 个变量

    如果省略掉函数中的 ~extern~ 关键字, 相当于创建了一个自动变量.
    例:
    #+begin_src c
      extern int Errupt;
    #+end_src
    #+begin_src c
      int Errupt;
    #+end_src

    这使得编译器在 ~main()~ 中创建了一个名为 ~Errupt~ 的自动变量. 它是一个独立的
    局部变量, 与原来的外部变量 ~Errupt~ 不同. 该局部变量仅 ~main()~ 中可见, 但是
    外部变量对该文件的其他函数也可见.
    
    简而言之, 在执行块中的语句时, 块作用域中的变量将 "隐藏" 文件作用域中的同名变
    量.

    如果不得已要使用与外部变量同名的局部变量, 可以在局部变量的声明中使用 ~auto~
    存储类别说明符明确表达这种意图

    外部变量具有静态存储期, 因此, 无论程序执行到任何函数, 其值都 *一直存在*

    示例:
    1. 外部变量 ~Hocus~, 对 ~main()~ 和 ~magic()~ 均可见
       #+begin_src c
         int Hocus;
         int magic();
         int main()
         {
           extern int Hocus; // Hocus之前已声明为外部变量
         }

         int magic()
         {
           extern int Hocus; // 与上面的Hocus是同一变量
         }
       #+end_src

    2. 外部变量 ~Hocus~, 对 2 个函数均可见, 在默认情况下对 ~magic()~ 可见
       #+begin_src c
         int Hocus;
         int magic();
         int main()
         {
           extern int Hocus; // Hocus之前已声明为外部变量
         }

         int magic()
         {
           // 并未在该函数中声明Hocus, 但是仍可使用该变量
         }
       #+end_src

    3. 创建了 4 个独立变量, ~main()~ 中的 ~Hocus~ 变量默认是自动变量, 属于
       ~main()~ 私有. ~magic()~ 中的 ~Hocus~ 变量被显式声明为自动, 只有
       ~magic()~ 可用. 外部变量对 ~main()~ 和 ~magic()~ 均不可见, 但是对该文件中
       未创建局部 ~Hocus~ 变量的其他函数可见. 最后, ~Pocus~ 是外部变量,
       ~magic()~ 可见, 但是 ~main()~ 不可见, 因为 ~Pocus~ 被声明在 ~main()~ 后面

       #+begin_src c
         int Hocus;
         int magic();

         int main()
         {
           int Hocus; // 默认自动变量
         }

         int Pocus;

         int magic()
         {
           auto int Hocus; // 把局部变量 Hocus 显式声明为自动变量
         }
       #+end_src

       外部变量的作用域: *从声明处到文件结尾*
       外部变量的声明周期: *在程序中一直存在*


**** 初始化外部变量
     外部变量和自动变量类似, 也可以被显式初始化. 与自动变量不同的是, 如果未初始
     化外部变量, 它们会自动初始化为 0. 这一原则也适用于外部定义的数组元素.
     与自动变量的情况不同, 只能使用常量表达式初始化文件作用域变量
     #+begin_src c
       int x = 10; // OK
       int y = 3 + 20; // OK
       size_t z = sizeof(int); // OK
       int x2 = 2 * x; // Error
     #+end_src

     *注意*: 只要不是变长数组(VLA), ~sizeof~ 表达式可视为常量表达式

**** 使用外部变量
     使用外部变量的示例. ~见 global.c~

**** 外部名称
     C99 和 C11 标准都要求编译器识别局部标识符的前 63 个字符和外部标识符的前 31 个字符.
     这修订了以前的标准, 即编译器识别局部标识符前 31 个字符和外部标识符前 6 个字符.
     

     外部变量名比局部变量名的规则严格, 是因为外部变量名还要遵循局部环境规则, 所
     受限制的更多

**** 定义和声明

     例:
     #+begin_src c
       int tern = 1; // tern被定义

       main()
       {
         extern int tern; // 使用在别处定义的tern
       }
     #+end_src
     
     ~tern~ 被声明了 2 次, 第一次声明为变量预留了存储空间, 该声明构成了变量的定义.
     第二次声明只告诉编译器使用之前已创建的 ~tern~ 变量, 所以这不是定义.

     第一次声明被称为定义式声明(defining declaration)

     第二次声明被称为引用式声明(referencing declaration)

     关键字 ~extern~ 表明该声明不是定义, 因为它指示编译器去别处查询其定义

     外部变量 *只能初始化一次*, 且 *必须在定义该变量时进行*
*** 内部链接的静态变量
    该存储类别的变量具有静态存储期, 文件作用域和内部链接. 在所有函数外部(这点与
    外部变量相同), 用存储类别说明符 ~static~ 定义的变量具有 这种存储类别:
    
    #+begin_src c
      static int svil = 1; // 静态变量, 内部链接

      int main()
      {

        return 0;
      }
    #+end_src

    
    这种变量过去称为 *外部静态变量(external static variable)*, 但是这个术语有点
    自相矛盾(这些变量具有内部链接). 但是没有和是的新简称
    所以只能用 *内部链接的静态变量(static variable with internal linkage)*.

    普通的外部变量可用于同一程序中任意文件中的函数, 但是内部链接的静态变量 *只能
    用于同一个文件中的函数*. 可以使用存储类别说明符 ~extern~, 在函数中重复声明任
    何具有文件作用域的变量. 这样的声明并不会改变其链接属性:

    #+begin_src c
      int traveler = 1; // 外部链接
      static int stayhome = 1; // 内部链接

      int main()
      {
        extern int traveler;// 使用定义在别处的traveler
        extern int stayhome; // 使用定义在别处的 stayhome
        // ...

        return 0;
      }
    #+end_src
    
    对于该程序所在的翻译单元, ~traveler~ 和 ~stayhome~ 都具有文件作用域, 但是只
    有 ~traveler~ 可用于其他翻译单元(因为它具有外部链接)

    ~extern~ 关键字并未改变 ~stayhome~ 内部链接属性

*** 多文件
    只有当程序由多个翻译单元组成时, 才体现区别内部链接和外部链接的重要性.
    
    *注意*: 如果外部变量定义在一个文件中, 那么其他文件在使用该变量之前 *必须先声
     明(extern 关键字)它*. 否则不能直接使用

     
*** 存储类别说明符    
    关键字 ~static~ 和 ~extern~ 的含义取决于上下文.
    
    C 语言有 6 个关键字作为存储类别说明符: ~auto~, ~register~, ~static~, ~extern~,
    ~_Thread_local~ 和 ~typedef~. 
    ~typedef~ 关键字与任何内存存储无关, 把它归于此类有一些语法上的原因.

    在绝大多数情况下, 不能再声明中使用多个存储类别说明符, 所以这 *意味着不能使用
    多个存储类别说明符作为 ~typedef~ 的一部分*
    唯一例外的是 ~_Thread_local~, 它可以和 ~static~ 或 ~extern~ 一起使用

    1. auto
       ~auto~ 说明符表示变量是自动存储期, 只能用于块作用域的变量声明中.
       由于在块中声明的变量本身就具有自动存储期, 所以使用 ~auto~ 主要是为了明确
       表达要使用与外部变量同名的局部变量的意图

    2. register
       ~register~ 说明符也只用于块作用域的变量, 它把变量归为寄存器存储类别, 请求
       最快速度访问该变量. 同时, 还保护了该变量的 *地址不被读取*

       用 ~static~ 说明符创建的对象具有静态存储期, 载入程序时创建对象, 当程序结
       束时对象消失. 如果 ~static~ 用于文件作用域声明, 作用域受限于该文件.
       如果 ~static~ 用于块作用域声明, 作用域则受限于该块.

       因此, 只要程序在运行对象就存在并保留其值, 但是只有在执行块内的代码时, 菜
       鸟通过标识符访问.

       块作用域的静态变量无连接. 文件作用域的静态变量具有内部链接

       ~extern~ 说明符表明声明的变量定义在别处. 如果包含 ~extern~ 的声明具有文件
       作用域, 则引用的变量必须具有外部链接. 如果包含 ~extern~ 的声明具有块作用
       域, 则引用的变量可能具有外部链接或内部链接, 这取决于该变量的定义式声明

       小结: 存储类别

       *自动变量*: 具有块作用域, 无链接, 自动存储期. 属于所在块私有(通常指函数).寄存
       器变量的属性和自动变量相同

       *静态存储期*: 变量可以具有外部链接, 内部链接或无链接. 在同一个文件所有函
       数的外部声明的变量是外部变量, 具有文件作用域, 外部链接和静态存储期. 如果
       在这种声明前面加上关键字 ~static~, 那么其声明的变量具有文件作用域, 内部链
       接和静态存储期. 如果函数中用 ~static~, 则该变量具有块作用域, 无链接, 静态
       存储期

       程序在编译时会为具有静态存储期的变量分配内存, 并始终保留, 默认初始化为 0

       具有内部链接的文件作用域变量, 只能用于其声明所在的文件内

       多存储类别示例: ~见parta.c, partb.c~
*** 存储类别和函数
    函数也有存储类别, 可以是外部函数(默认)或静态函数. C99 新增了第三种类别 - 内
    联函数, 将在第 16 章介绍.
    
    外部函数可以被其他文件的函数访问, 但是静态函数只能用于其定义所在的文件.

    #+begin_src c
      double gamma(dobule); // 该函数默认为外部函数
      static double beta(int, int);
      extern double delta(double, int);
    #+end_src

    在同一个程序中, 其他文件中的函数可以调用 ~gamma()~ 和 ~delta()~, 但是不能调
    用 ~beta()~, 因为 ~static~ 存储类别说明符创建的函数属于特定模块私有. 这样做
    避免了名称冲突的问题, 由于 ~beta()~ 受限于它所在的文件, 所以在其他文件中可以
    使用与之同名的函数.

    通常的做法是: 用 ~extern~ 关键字声明定义在其他文件中的函数. 这样做是为了表明
    当前文件中使用的函数被定义在别处. 除非使用 ~static~ 关键字, 否则一般函数声明
    都默认为 ~extern~

*** 存储类别的选择
    对于 "使用哪种存储类别" 的回答绝大多数是 "自动存储类别", 默认类别就是自动存
    储类别

    当使用 ~const~ 数据的时候, 不用担心被意外篡改

    保护性程序设计的黄金法则是: "按需知道"原则. 尽量在函数内部解决该函数的任务,
    只共享那些需要共享的变量. 除自动存储类别外, 其他存储类别也很有有用. 不过, 在
    使用某类别之前先要考虑以下是否有必要这样做

** 随机数函数和静态变量

*** 手动重置
    ANSI C 库提供了 ~rand()~ 函数生成随机数. 生成随机数有多种算法, ANSI C 允许 C 实现
    针对特定机器使用最佳算法. 然而, ANSI C 标准还提供了一个可移植的标准算法, 在不
    同系统中生成相同的随机数. 

    实际上, ~rand()~ 是 "伪随机数生成器", 意思是可预测生成数字的实际序列. 但是数
    字在取值职范围内均匀分布

    为了看清楚程序内部的情况, 我们使用可移植的 ANSI 版本, 而不是编译器内置的
    ~rand()~ 函数.

    可移植版本的方案开始于一个 "种子"数字. 该函数使用该种子生成新的数, 这个新数又
    成为新的种子. 然后, 新种子可用于生成更新的种子, 以此类推.

    该方案要行之有效, 随机数函数必须记录它上一次被调用时所使用的种子. 这里需要一
    个静态变量 (见 ~rand0.c~)

    ~rand0.c~  中, 静态变量 ~next~ 的初始值是 1, 其值在每次调用 ~rand0()~ 函数时
    都会被修改 (通过魔术公式). 该函数是用于返回一个 0 ~ 32767 之间的值.
    注意: next 是具有内部链接的静态变量(并非无链接). 这是为了方便稍后扩展本例, 供
    同一个文件中的其他函数共享

   
    ~r_drive0.c~ 中, 每次主程序运行, 都开始于相同的种子 1. 可以引入另一个函数
    ~srand1()~ 重置种子来解决这个问题, 关键是要让 ~next~ 成为只供 ~rand1()~ 和
    ~srand1()~ 访问的内部静态变量 (~srand1()~ 相当于 C 库中的 ~srand()~ 函数). 
    把 ~srand1()~ 加入 ~rand1()~ 所在的文件中(~见 s_and_r.c~)

*** 自动重置
    如果 C 实现允许访问一些可变的量(如, 时钟系统), 可以用这些值(可能会被截断)初始
    化种子值. 例如, ANSI C 有一个 ~time()~ 函数返回系统时间.
    虽然时间单元因系统而异, 但是重点是该返回值是一个可进行运算的类型, 而且其值随
    着时间变化而变化. ~time()~ 返回值的类型名是 ~time_t~, 具体类型与系统有关. 这
    没关系, 我们可以使用强制类型转换:

    #+begin_src c
      #include <time.h>

      srand1((unsigned int)time(0)); // 初始化种子
    #+end_src

    一般而言, time()接受的参数是一个 ~time_t~ 类型对象的地址, 而时间值就存储在传
    入的地址上. 当然, 也可以传入空指针(0) 作为参数, 这种情况下, 只能通过返回值机
    制来提供值

    可以把这个技巧应用于标准 ANSI C 函数 ~srand()~ 和 ~rand()~ 中. 如果使用这些函
    数, 要在文件中包含 ~stdlib.c~ 头文件. 实际上, 既然已经明白了 ~srand1()~ 和
    ~rand1()~ 如何使用内部链接的静态变量, 也可以使用编译器提供的版本
** 掷骰子
   计算机计算不用考虑几何的限制, 所以可以设计任意面数的电子骰子. 先从 6 面开始
   
   想获得 1~6 的随机数. 然而, ~rand()~ 生成的随机数在 0~RAND_MAX 之间. RAND_MAX
   被定义在 ~stdlib.h~ 中, 其值通常是 ~INT_MAX~. 因此需要进行一些调整:
   
   1. 把随机数求模 6, 获得的整数在 0 ~ 5 之间
   2. 结果 + 1, 新值在 1 ~ 6 之间
   3. 为了方便以后扩展, 把第一步中的数字 6 替换成骰子面数
      #+begin_src c
        #include <stdlib.h>

        int rollem(int slides)
        {
          int roll;
          roll = rand() % sides + 1;
          return roll;
        }
      #+end_src
      

   程序见 ~diceroll.c~, 调用见 ~manydice.c~

   因为程序使用 ~srand()~ 随机生成随机数种子, 所以大多数情况下, 即使输入相同也很
   难得到相同的输出

   可以通过多种方式使用 ~roll_n_dice()~. ~sides == 2~ 时, 程序魔方掷硬币, 可以定
   义: "正面朝上" 为 2, "反面朝上" 为 1. 很容易修改该程序单独显示点数的结果, 或
   者构建一个骰子模拟器.

   ~rand1()~ 或 ~rand()~ 还可以来构建一个猜数字程序, 让计算机选定一个数字
** 分配内存: ~malloc()~ 和 ~free()~
   之前讨论的存储类别有一个共同之处: 在确定用哪种存储类别后, 根据已制定好的内存
   管理规则, 将自动选择其作用域和存储期. 然而, 还可以更灵活的选择, 即用库函数分
   配和管理内存

   所有程序都必须预留足够的内存来储存程序使用的数据. 这些内存内存多半是自动分配
   的.

   C 可以在程序运行时分配更多的内存. 主要的工具是 ~malloc()~ 函数, 该函数接受一个
   参数: 所需的内存字节数. 

   ~malloc()~ 函数会找到合适的空闲内存块, 这样的内存是匿名的. 也就是说,
   ~malloc()~ 分配内存, 但是不会为其赋名. 然而, 它确实返回动态分配内存块的首地址. 
   因此可以把该地址赋值一个指针变量, 并使用指针访问这块内存.
   
   因为 ~char~ 表示 1 字节, ~malloc()~ 的返回类型通常被定义为指向 ~char~ 的指针.
   然而, 从 ANSI C 标准开始, C 使用一个新的类型: 指向 void 的指针. 该类型相当于一
   个 *"通用指针"*, ~malloc()~ 函数可用于返回指向数组的指针, 指向结构的指针等,
   所以通常该函数的返回值会被强制转换为匹配的类型. 在 ANSI C 中, *应该坚持使用强
   制类型转换*, 提高代码的可读性.

   然而, 把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题. 如果
   ~malloc()~ 分配内存失败, 将返回空指针.

*** 使用 ~malloc()
    试着用 ~malloc()~ 创建一个数组, 除了用 ~malloc()~ 在程序运行时请求一块内存,
    还需要一个指针记录这块内存的位置.

    #+begin_src c
      double *ptd;

      ptd = (double *)malloc(30 * sizeof(double));
    #+end_src
    
    以上代码为 30 个 ~double~ 类型的值请求内存空间, 并设置 ~ptd~ 指向该位置. 注意,
    指针 ~ptd~ 被声明为指向一个 ~double~ 类型, 而不是指向内含 30 个 ~double~ 类型
    值的块. 

    因为数组名是数组首元素的地址, 如果让 ~ptd~ 指向这个块的首元素, 便可像使用数
    组名一样使用它. 也就是说, 可以使用表达式 ~ptd[0]~ 访问该块的首元素, ~ptd[1]~
    访问第二个元素, 以此类推. 可以使用数组名来表示指针, 也可以使用指针来表示数组

    现在我们有 3 种创建数组的方法:

    1. 用常量表达式表示数组的维度, 用数组名访问数组的元素. 可以用静态内存或自动
       内存创建这种数组

    2. 声明变长数组时, 用变量表达式表示数组的维度, 用数组名访问数组的元素. 具有
       这种特性的数组只能在自动内存中创建

    3. 声明一个指针, 调用 ~malloc()~, 将其返回值赋给指针, 使用指针访问数组的元素.
       该指针可以是静态的或自动的.

       
    使用第 2 种或第 3 种方法可以创建动态数组(dynamic array). 这种数组和普通数组不同,
    可以在程序运行时选择数组的大小和分配内存

    C99 之前不能这样做:
    #+begin_src c
      double item[n];
    #+end_src

    可以这样做:
    #+begin_src c
      ptd = (double*)malloc(n * sizeof(double)); // 可以
    #+end_src

    这比 VLA 要灵活
    
*** ~free()~ 的使用
    通常, ~malloc()~ 要与 ~free()~ 配套使用. ~free()~ 函数的参数是之前
    ~malloc()~ 返回的资质, 该函数释放之前 ~malloc()~ 分配的内存. 因此, 动态分配
    内存的存储期从调用 ~malloc()~ 分配内存到调用 ~free()~ 释放内存为止. 设想
    ~malloc()~ 和 ~free()~ 管理着一个内存池. 每次调用 ~malloc()~ 分配内存给程序
    使用, 每次调用 ~free()~ 把内存归还内存池中, 这样便可重复使用这些内存.
    ~free()~ 的参数应该是一个指针, 指向由 ~malloc()~ 分配的一块内存.

    *不能用 free() 释放通过其他方式(如: 声明一个数组)* 分配的内存. ~malloc()~ 和
    ~free()~ 的原型都在 ~stdlib.h~ 头文件中.

    使用 ~malloc()~ 可能内存分配失败, 可以调用 ~exit()~ 函数结束程序, 其原型在
    ~stdlib.h~ 中. ~EXIT_FAILURE~ 的值也被定义在 ~stdlib.h~ 中.

    标准的提供了 2 个返回值以保证在所有操作系统中都能正常工作: ~EXIT_SUCCESS~ (或
    者, 相当于 0)表示普通的程序结束, ~EXIT_FAILURE~ 表示程序异常终止. 一些操作系
    统 (包括 UNIX, Linux 和 Windows)还接收一些表示其他运行错误的整数值

    ~见dyn_arr.c~:

    在 C 中不一定要用强制类型转换, 然而 C++要用:
    #+begin_src c
      ptd = (double*)malloc(sizeof(double) * max);
    #+end_src
    
    注意: ~free()~ 函数位于程序的末尾, 它释放了 ~malloc()~ 函数分配的内存.
    ~free()~ 函数只释放其参数执行的内存块. 

    一些操作系统会在程序结束时自动释放动态分配的内存, *但是有些不会*. 为保险起见,
    请使用 ~free()~, 不要依赖操作系统来清理
*** ~free()~ 的重要性
    静态内存的数量在编译时是固定的, 在程序运行期间也不会改变. 自动变量使用的内存
    数量在程序执行期间自动增加或减少. 但是 *动态分配的内存数量只会增加*, 除非用
    ~free()~ 进行释放

    假设有如下代码:
    #+begin_src c
      int main()
      {
        double glad[2000];
        int i;

        for (i = 0; i < 1000; ++i) {
          gobble(glad, 2000);
        }

      }

      void gobble(double ar[], int n)
      {
        double *temp = (double*)malloc(n * sizeof(double));

        // free(temp);
      }
    #+end_src
    
    每次调用都会调用 malloc 分配 ~2000 * sizeof(double)~ 字节的内存.
    如果遗漏了 ~free()~, 函数结束时, 作为自动变量的指针 ~temp~ 也会消失. 但是它
    所指向的内存依然存在. 由于指针已被销毁, 所以无法访问这块内存, 但也不能被重复
    使用, 因为代码中没有调用 ~free()~ 释放这块内存

    循环要调用 1000 次, 内存池中有 ~1000 * 2000 * sizeof(double)~ 字节的内存被占用.
    实际上, 也许在循环结束之前就已耗尽所有的内存. 这类问题被称为内存泄漏. 在函数
    末尾处调用 ~free()~ 函数可避免这类问题的发生

*** ~calloc()~ 函数
    分配内存还可以用 ~calloc()~:
    
    #+begin_src c
      long* newmem;

      newmem = (long*)calloc(100, sizeof(long));
    #+end_src

    和 ~malloc()~ 类似, 在 ANSI C 之前, ~calloc()~ 也返回指向 ~char~ 的指针; 在
    ANSI 之后, 返回指向 ~void~ 的指针. 如果要储存不同的类型, 应使用强制类型转换
    运算符. ~calloc()~ 函数接受 2 个无符号整数作为参数 (ANSI 规定是 ~size_t~ 类型).
    第一个参数是所需的存储单元数量, 第二个参数是存储单元的大小(以字节为单位)

    ~calloc*()~ 函数还有一个特性: 它把块中的所有位都设置为 0(在某些硬件系统中, 不
    是把所有位都设置为 0 来表示浮点值是 0)

    ~free()~ 函数也可以用于释放 ~calloc()~ 分配的内存
*** 动态分配内存和 VLA(变长数组)
    VLA 和调用 ~malloc()~ 在功能上有些重合. 例如, 两者都可用于创建在运行时确定大
    小的数组:
    #+begin_src c
      int vlamal()
      {
        int n;
        int* pi;

        scanf("%d", &n);
        pi = (int*)malloc(sizeof(int) * n);
        int ar[n]; // VLA
        pi[2] = ar[2] = -5;

      }
    #+end_src
    
    不同的是, VLA 是自动存储类型. 因此, 程序在离开 VLA 定义所在的块时(即 ~vlamal()~
    函数结束时), VLA 占用的内存空间会被自动释放, 不必使用 ~free()~. 另一方面, 使
    用 ~malloc()~ 创建的数组不必局限在一个函数内访问.

    例如: 可以这样做: 被调用函数创建一个数组并返回指针, 供主调函数访问, 然后主调
    函数在末尾调用 ~free()~ 释放之前被调函数分配的内存. 另外, ~free()~ 所用的指
    针变量可以与 ~malloc()~ 的指针变量不同, 但是两个指针必须储存相同的地址. 但是,
    *不能释放同一块内存 2 次*

    对多位数组而言, 使用 VLA 更方便. 当然, 也可以 *用 ~malloc()~ 创建二维数组*, 但是
    语法比较繁琐. 如果编译器不支持 VLA, 就只能固定二维数组的维度

    #+begin_src c
      int n = 5;
      int m = 6;
      int ar2[n][m]; // n * m 的VLA
      int (*p2)[6]; // C99之前写法

      int (*p3)[m]; // 要求支持VLA
      p2 = (int(*)[6])malloc(sizeof(int) * 6 * n); // n * 6 数组
      p3 = (int(*)[m])malloc(sizeof(int) * n * m); // 要求支持VLA
      ar2[1][2] = p2[1][2] = 12;

    #+end_src

    由于 ~malloc()~ 函数返回一个指针, 所以 ~p2~ 必须是一个指向合适类型的指针.

    #+begin_src c
      int(*p2)[6]; // C99之前的写法
    #+end_src
    
    表明 ~p2~ 指向一个内含 6 个 ~int~ 类型值的数组. 因此, ~p2[i]~ 代表一个由 6 个整
    数构成的元素, ~p2[i][j]~ 代表一个整数

    第二个指针声明用一个变量指定 ~p3~ 所指向数组的大小. 因此, ~p3~ 代表一个指向
    VLA 的指针, 这行代码不能在 C90 标准中运行
*** 存储类别和动态内存分配
    可以认为程序把它可用的内存分为 3 部分: 
    1. 供具有外部链接, 内存链接和无链接的静态变量使用
    2. 供自动变量使用
    3. 供动态内存分配

       
    静态存储类别所用的内存数量在编译时确定, 只要程序还在运行, 就可访问存在该部分
    的数据. 该类别的变量在程序开始执行时被创建, 在程序结束时被销毁

    自动存储来别的变量在程序进入变量定义所在块时存在, 在程序离开块时消失.
    因此, 随着程序调用函数和函数结束, 自动变量所用的内存数量也相应地增加和减少.
    这部分的内存通常作为栈来处理, 这意味着新创建的变量按顺序加入内存, 然后以相反
    的顺序销毁

    动态分配的内存在调用 ~malloc()~ 或相关函数时存在, 在调用 ~free()~ 后释放. 这
    部分的内存由程序员管理, 而不是一套规则. 所以内存块可以在一个函数中创建, 在另
    一个函数中销毁. 正式因为这样, 这部分的内存用于动态内存分配会支离破碎. 也就是
    说, *未使用的内存块分散在已使用的内存块之间*. *使用动态内存通常比使用栈内存
    慢*

    程序把静态对象, 自动对象和动态分配的对象储存在不同的区域

    *静态数据(包括字符串字面量)占用一个区域, 自动数据占用另一个区域, 动态分配的
     数据占用第三个区域(通常被称为内存堆或自由内存)*

** ANSI C 类型限定符
   C90 新增了 2 个属性: 恒常性(constancy)和易变性(volatility). 这 2 个属性可以分别用
   关键字 ~const~ 和 ~volatile~ 来声明, 以这 2 个关键字创建的类型是限定类型
   (qualified type). C99 标准新增了第 3 个限定符: ~restrict~, 用于提高编译器优化.
   C11 标准新增了第 4 个限定符: ~_Atomic~. C11 提供一个可炫酷, 由 ~stdatomic.h~ 管理,
   以支持并发程序设计, 而且 ~_Atomic~ 是可选支持项

   C99 为类型限定符增加了一个新属性: 他们现在是幂等的(idempotent)! 这个属性指的
   是可以在一条声明中多次使用同一个限定符, 多余的限定符将被忽略:

   #+begin_src c
     const const const int n = 6; // 与 const int n = 6; 相同
   #+end_src

   可以使用该特性编写如下代码:
   #+begin_src c
     typedef const int zip;
     const zip q = 8;
   #+end_src

*** ~const~ 类型限定符
    以 ~const~ 关键字声明的对象, 其值不能通过赋值或递增, 递减来修改. 
    在 ANSI 兼容的编译器中, 以下代码:

    #+begin_src c
      const int nochange; // 限定nochange的值不能被修改
      nochange = 12; // 不允许
   #+end_src
    
   编译器会报错.

   可以用 ~const~ 关键字创建不允许修改的数组:
   #+begin_src c
     const int days1[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
   #+end_src

**** 在指针和形参声明中使用 ~const~
      声明普通变量和数组时使用 ~const~ 关键字很简单. 指针复杂一些, 因为要区分是
      限定指针本身 ~const~ 还是限定指针指向的值为 ~const~
      
      1) 方式 1
      #+begin_src c
        const float* pf; // pf指向一个float类型的const值
      #+end_src
      
      创建了 ~pf~ *指向的值不能被改变*, 而本身的值可以改变, 例如, 可以设置改指
      针指向其他 ~cosnt~ 值

      2) 方式 2
      #+begin_src c
        float* const pt; // pt是一个const指针
      #+end_src

      创建的指针 pt *本身的值不能更改*. pt 必须指向同一个地址, 但是他指向的值可以
      改变

      3) 方式 3
      #+begin_src c
        const float* const ptr;
      #+end_src

      表明 ptr *既不能指向别处, 它指向的值也不能改变*

      4) 方式 4
      #+begin_src c
        float const* pfc; // 与 const float* pf相同
      #+end_src

      说明该指针不能用于改变它所指向的值.

      *简而言之*: ~const~ 放在 ~*~ 左侧任意位置, 限定指针指向的数据不能改变, 放
      在 ~*~ 右侧, 限定了指针本身不能改变

***** 常见用法
      声明为函数形参的指针. 例如, 假设有 1 个函数要调用 ~display()~ 显示一个数组的
      内容. 要把数组名作为实际参数传递给该函数, 但是数组名是一个地址. 该函数可能
      会更改主调函数中的数据, 但是下面的原型保证了数据不会被更改:
      #+begin_src c
        void display(const int array[], int limit);
      #+end_src

      在函数原型和函数头, 形参声明 ~const int array[]~ 与 ~const int* array~ 相
      同, 所以该声明表明不能更改 ~array~ 指向的数据

      ANSI C 库遵循这种做法. 如果一个指针仅用于给函数访问值, 应将其声明为一个指向
      ~const~ 限定类型的指针. 如果要指针更改主调函数中的数据, 就不使用.

      ANSI C 中的 ~strcat()~ 原型如下:
      #+begin_src c
        char *strcat(char* restrict s1, const char* restrict s2);
      #+end_src
      
      这更改了第一个字符串, 但是并未更改第二个字符串

**** 对全局数据使用 const
     使用全局变量是一种冒险的方法, 因为这样做暴露了数据, 程序的任何部分都能更改
     数据. 如果把数据设为 ~const~, 就可避免这样的危险

     可以创建 ~const~ 变量, ~const~ 数组和 ~const~ 结构

     然而, 在文件间共享 ~const~ 数据要小心. 可以采用 2 个策略:
     1. 遵循外部变量的常用规则, 即在一个文件中使用定义式声明, 在其他文件中使用引
        用式声明 (用 ~extern~)

        ~file1.c~: 定义一些外部 ~const~ 变量
        #+begin_src c
          const double PI = 3.14159;
          const char* MONTHS[12] = { "Janary", "February", "March", "April", "May", "June", "July",
                                     "Augest", "September", "October", "November", "December"};
        #+end_src

        ~file2.c~: 使用定义在别处的外部 ~const~ 变量
        #+begin_src c
          extern const double PI;
          extern const* MONTHS[];
        #+end_src

        
     2. 把 ~const~ 变量放在一个头文件中, 然后在其他文件中包含该头文件:

        ~constant.h~: 定义了一些外部 ~const~ 变量
        #+begin_src c
          static const double PI = 3.14159;
          static const char* MONTHS[12] = { "Janary", "February", "March", "April", "May", "June", "July",
                                            "Augest", "September", "October", "November", "December"};
        #+end_src
        
        ~file1.c~: 使用定义在别处的外部 ~const~ 变量
        #+begin_src c
          #include "constant.h"
        #+end_src

        ~file2.c~: 使用定义在别处的外部 ~const~ 变量
        #+begin_src c
          #include "constant.h"
        #+end_src

        这种方案 *必须在头文件定义中用关键字 ~static~ 声明全局 ~const~ 变量*. 如
        果去掉 ~static~, 那么在 ~file1.c~ 和 ~file2.c~ 中包含 ~constant.h~ 将导
        致每个文件中都有一个相同标识符的定义式声明, C 标准不允许这样做.

        这种方案现相当于给每个文件提供了一个单独的数据副本. 由于每个副本 *只对该
        文件可见*, 所以无法用这些数据和其他文件通信. 不过因为都是完全相同的
        ~const~ 数据, 这不是问题.

        头文件的好处是方便偷懒, 不用惦记着一个文件中使用定义式, 其他文件中使用引
        用式. 所以的文件都只需更包含同一个头文件即可. 但它的缺点是: 数据是重复的.
        对于前面的例子而言, 这不算什么问题, 但是如果 ~const~ 数据包含庞大的数组,
        就不能视而不见了

        
*** ~volatile~ 类型限定符 
    ~volatile~ 限定符告知计算机, 代理(而不是变量所在的程序) 可以改变该变量的值.
    通常, *它被用于硬件地址以及在其他程序或同时运行的线程中共享数据*. 例如, 一个
    地址上可能存储着当前的时钟时间, 无论程序做什么, 地址上的值都能随时间的变化而
    改变. 或者一个地址用于接收另一台计算机传入的信息

    ~volatile~ 的语法和 ~const~ 一样
    #+begin_src c
      volatile int loc1; // loc1 是一个易变的位置
      volatile int* ploc; // ploc是一个指向易变的位置的指针
    #+end_src

    该限定符涉及编译器的优化:
    #+begin_src c
      vall = x;
      val2 = x;
    #+end_src

    编译器会注意到以上代码使用了 2 次 ~x~, 但并未改变它的值. 于是编译器把 ~x~ 的值
    *临时储存在寄存器中*, 然后在 ~val2~ 需要使用 ~x~ 时, 才从寄存器中(而不是原始内
    存位置上) 读取 ~x~ 的值. 以节约时间. 这个过程被称为高速缓存(cache).

    通常, 高速缓存是个不错的优化方案, 但是如果一些其他代理在以上 2 条语句 *之间改
    变了* ~x~ 的值, 就不能这样优化. 如果没有 ~volatile~ 关键字, 编译器就不知道这
    种事情是否会发生. 因此, 为安全编译器不会进行高速缓存. 这是在 ANSI C 之前的情
    况. 现在, 如果声明中没有 ~volatile~ 关键字, 编译器会假定变量的值在使用过程中
    不变, 然后再尝试优化代码

    可以同时用 ~const~ 和 ~volatile~ 限定一个值. 例如, 通常用 ~const~ 把硬件时钟
    设置为程序不能更改的变量, 但是可以通过代理改变, 这时用 ~volatile~. 只要能在声
    明中同时使用这 2 个限定符, 它们的 *顺序不重要*:
    #+begin_src c
      volatile const int loc;
      const volatile int* ploc;
    #+end_src
*** ~restrict~ 类型限定符
    ~restrict~ 关键字 *允许编译器优化某部分代码以更好地支持计算*. 它 *只能用于指
    针*, 表明该指针是访问数据对象的唯一且初始的方式.

**** 指针用法
     #+begin_src c
       int ar[10];
       int* restrict restar = (int*)malloc(sizeof(int) * 10);
       int* par = ar;
     #+end_src

     这里: 指针 ~restar~ 是访问由 ~malloc()~ 所分配内存的唯一且初始的方式. 因此,
     可以用 ~restrict~ 关键字限定它. 而指针 ~par~ 既不是访问 ~ar~ 数组中数据的初
     始方式, 也不是唯一方式. 所以不用把它设置为 ~restrict~

     考虑下面的代码:
     #+begin_src c
       for (n = 0; n < 10; ++n) {
         par[n] += 5;
         restar[n] += 5;
         ar[n] *= 2;
         par[n] += 3;
         restar[n] += 3;
       }
     #+end_src
    
     编译器会对其优化:
     #+begin_src c
       restar[n] += 8;
     #+end_src

     但是 ~par~ 就不能优化, ~par~ 两次访问相同数据之前, 用 ~ar~ 改变了该数据的值

     若未使用 ~restrict~ 关键字, 编译器就不会进行可能出现问题的优化

**** 函数形参用法
     ~restrict~ 还可用于函数形参中的指针. 这意味着编译器可以假定在函数体内其他标
     识符不会修改该指针指向的数据, 编译器会对其优化, 使其不做别的用途.

     例如:
     #+begin_src c
       void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
       void* memmove(void* s1, const void* s2, size_t n);
     #+end_src
     
     这 2 个函数都是从位置 s1 把 n 字节拷贝到 s1. ~memcpy()~ 函数要求 2 个位置 *不重叠*
     , 但是 ~memmove()~ 没有这样的要求. 声明为 ~restrict~ 说明这 2 个指针都是访问
     相应数据的 *唯一方式*, 所以它们 *不能访问相同块的数据*. 满足了无重叠的要求,
     ~memmove()~ 函数允许重叠, 使用时可能被覆盖

     ~restrict~ 使用时, 编译器 *不会检查用户是否遵循* 这一限制, 后果自负
*** ~_Atomic~ 类型限定符(C11)
    用于并发程序设计(把程序执行分成可以同时执行的多个线程)
    C11 提供了 *可选* 的头文件: ~stdatomic.h~ 和 ~threads.h~. 
    *注意*: 要通过各种宏函数来访问 *原子类型*.
    当一个线程对一个原子类型的对象执行原子操作时, 其他线程 *不能访问该对象*

    #+begin_src c
      int hogs; // 普通声明
      hogs = 12; // 普通赋值
    #+end_src

    #+begin_src c
      _Atomic int hogs; // hogs是一个原子类型的变量
      atomic_store(&hogs, 12); // stdatomic.h中的宏
    #+end_src

    这里在 ~hogs~ 中储存 12 是一个原子过程, 其他线程不能访问 hogs

    注意: 该特性为 *可选特性*, 使用前 *确认编译器要支持这一特性*
** 旧关键字的新位置
   C99 允许把类型限定符和存储类别说明符 ~static~ 放在函数原型和函数头的形式参数
   的初始方括号中. 

   对于类型限定符而言, 这种为现有功能提供了一个替代的语法:
   旧式声明:
   #+begin_src c
     void ofmouth(int* const a1, in* restrict a2, int n); // 旧式
   #+end_src

   该声明表明 ~a1~ 是一个指向 ~int~ 的 ~const~ 指针, 这意味着不能更改指针本身,
   可以更改指针指向的数据. 除此之外, 还表明 ~a2~ 是一个 ~restrict~ 指针, 

   等价语法:
   #+begin_src c
     void ofmouth(int a1[const], int a2[restrict], int n); // C99
   #+end_src

   新标准为 ~static~ 引入了一种与以前用法不相关的新语法.
   ~static~ 除了表明静态存储类别变量的作用域或链接外, 新的用法告知编译器如何使用
   形式参数:

   #+begin_src c
     double stick(double ar[static 20]);
   #+end_src

   以上用法表明: 函数调用中的实际参数应该是一个指向数组首元素的指针, 且该数组至
   少有 20 个元素. 这种用法的目的是让编译器使用这些信息优化函数的编码.
