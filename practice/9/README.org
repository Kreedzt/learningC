* 第9章

** 复习函数
   函数: 完成特定任务的独立代码单元.语法规则定义了函数的结构和使用方式

*** 分析程序(lethead1.c)
    程序在3处使用了 ~starbar~ 标识符:
    - 函数原型(function prototype): 告诉编译器函数 ~starbar()~ 的类型
    - 函数调用(function call): 表明在此处执行函数
    - 函数定义(function definition): 明确地指定了函数要做什么

      
    一般而言, 函数原型指明了函数的 *返回值类型* 和函数接受的 *参数类型*. 这些信
    息称为该函数的 *签名* (signature). 对于 ~starbar()~ 函数而言, 其签名是该函数
    没有返回值, 没有参数

    当计算机执行到 ~starbar()~ 语句时, 会找到该函数的定义并执行其中的内容. 执行
    完 ~starbar()~ 中的代码后, 计算机返回主调函数(calling function) 继续执行到下
    一行

*** 定义带形式参数的函数
    函数定义从下面的ANSI C风格的函数头开始:
    #+begin_src c
      void show_n_char(char ch, int num)
    #+end_src
    该行告知编译器show_n_char)_使用2个参数ch和num, ch是char类型, num是int类型.
    这2个变量被称为形式参数(formal argument, 但是最近的标准推荐使用formal
    parameter), 简称形参. 和定义在函数变量中医院, 形式参数也是局部变量, 属该函数
    私有这意味着在其他函数中使用同名变量 *不会引起名称冲突*. 每次调用函数, 就会
    给这些变量赋值

    *注意*: ANSI C要求每个变量前都声明其类型, 不能像普通变量声明那样使用同一类型的
    变量列表
    #+begin_src c
      void dubs(int x, int y, int z);

      // 以下已废弃(ANSI C之前的形式)
      void show_n_char(ch, num)
      char ch;
      int num;

      // 无效
      void dibs(int x, y, z);
      // 有效
      void dibs(x, y, z)
      int x, y, z;
    #+end_src
    
*** 声明带形式参数函数的原型
    在使用函数之前, 要用ANSI C形式声明函数原型:
    #+begin_src c
      void show_n_char(char ch, int num);
    #+end_src
    当函数接受参数时, 函数原型用逗号分隔的列表指明参数的数量和类型. 根据个人喜好,
    你也可以省略变量名:
    #+begin_src c
      void show_n_char(char, int);
    #+end_src
    在原型中使用变量名并 *没有实际创建变量*, char仅代表了一个char类型的变量, 以
    此类推. 
    ANSI C也接受过去的声明函数形式, 即圆括号内没有参数列表:
    #+begin_src c
      void show_n_char(); // 即将被废弃
    #+end_src
    
*** 调用带实际参数的函数
    在函数调用中, 实际参数(actual argument, 简称实参)提供了ch和num的值.
    
    形式参数是被调函数(called function)中的变量, 实际参数是主调函数(calling
    function)赋给被调函数的具体值.
    
    实际参数可以常量, 变量, 或甚至是更复杂的表达式. 无论实际参数是何种形式都要被
    求值, 然后该值背靠背给被调参数相应的形式参数

    *注意*: 实际参数是出现在函数调用圆括号中的表达式. 形式参数是函数定义的函数头
     中声明的变量. 调用函数时, 创建了声明为形式参数的变量并初始化为实际参数的求
     值结果

*** 使用return从函数中返回值
    被设计用于测试函数的程序有时被称为驱动程序(driver), 该驱动程序调用一个函数.
    如果函数成功通过了测试, 就可以安装在一个更重要的程序中使用

    返回值不仅可以赋给变量, 也可以被用作表达式的一部分.

    返回值不一定是变量的值, 也可以是任意表达式的值

    当返回值类型与函数声明类型不匹配时, 实际得到的返回值相当于把函数中指定的返回
    值赋给与函数类型相同的变量所得到的值(相当于类型转换为函数 *声明的类型*);

*** 函数类型
    声明函数时必须声明函数的类型. 带返回值的函数类型应该与返回值类型相同, 而没有
    返回值的函数应声明为void类型.
    如果没有声明函数的类型, 旧版本的C编译器会假的函数的类型是int.(C99标准不支持)

    函数类型指的是 *返回值的类型*, 不是函数参数的类型.

    函数的前置声明仅需要声明在 *第一次调用函数之前*, 所以 *不限制位置*
    #+begin_src c
      #include <stdio.h>

      int main()
      {
          // 声明有效
          int imin(int, int); //声明imin()函数的原型
      }
    #+end_src
    
** ANSI C函数原型
   旧式的函数声明会导致的问题:
   #+begin_src c
     int imin();
   #+end_src
   以上函数声明并未给出imin()函数的参数个数和类型. 因此, 如果调用imin()时使用的
   参数个数不对或类型不匹配, 编译器根本不会察觉出来

*** 问题所在(misuse.c)
    不同系统的内部机制不同, 所以出现问题的具体情况也不同
    主调函数把它的参数储存在被称为栈(stack)的临时存储区, 被调参数从栈中读取这些
    参数.
    对于该例, 这2个过程并未相互协调. 主调函数根据函数调用中的时机参数, 所以读取
    的第二个值是当时恰好在栈中的其他值

    第二次使用 ~imax()~ 函数时, 它传递的是float类型的值. 这次把2个 ~double~ 类型
    的值放在栈中. 当 ~imax()~ 从栈中读取2个int类型的值时, 它从栈中读取前64位(在int
    类型为32位系统中). 这些数据对应2个整数, 选取较大的数据

*** ANSI的解决方案
    针对参数不匹配的问题, ANSI C标准要求在函数声明时还要声明变量的类型, 即使用函
    数原型(function prototype)来声明函数的返回类型, 参数的数量和每个参数的类型
    #+begin_src c
      int imax(int, int);
      int imax(int a, int b);
    #+end_src
    *注意*: 这里的变量名假名, 不必与函数定义的形式参数名一致

    有了这些信息, 编译器可以检查函数的调用是否与函数原型匹配.

    当参数类型不匹配时, 会强制转换, 例如: double转int会丢失精度(3.9 转为 3)

*** 无参数和未指定参数
    假设有下面的函数原型:
    #+begin_src c
      void print_name();
    #+end_src
    一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数, 他将不会检查参数.
    为了表明函数确实没有参数, 应该在圆括号中使用 ~void~ 关键字
    #+begin_src c
      void print_name(void);
    #+end_src
    支持ANSI C的编译器解释为 ~print_name()~ 不接受任何参数. 然后在调用该函数时,
    编译器会检查以确保没有使用参数

    一些函数接受许多参数(如: ~printf()~ 和 ~scanf()~). 例如: ~printf()~ 的第一个
    参数是字符串, 但是参数其余的类型和数量都不固定, 对于这种情况, ANSI C允许使用
    部分原型:
    ~printf()~ 原型:
    #+begin_src c
      int print(const char*,...);
    #+end_src
    这种原型表明, 第一个参数是一个字符串, 可能还有其他未指定的参数

    C库通过 ~stdarg.h~ 头文件提供了一个定义这类(形参数量不固定的)函数的标准方法

*** 函数原型的优点
    函数原型是C语言的一个强有力的工具, 它让编译器捕获在使用函数时可能出现的许多
    错误或疏漏, 函数原型是 *可选* 项

    之所以使用函数原型, 是为了让编译器在 *第一次执行到该函数之前* 就知道如何使用
    它.因此, 把整个函数定义放在第一次调用该函数之前, 也有相同的效果

** 递归
   C允许函数调用它自己, 这种调用过程称为递归(recursion)

   可以使用循环的地方都可以使用递归. 递归方案更简洁, 但效率却没有循环高

*** 递归的基本原理(示例代码: ~recur.c~)
    要点:
    1. 每级函数都有自己的变量
       第1级的n和第二级的n不同, 所以程序创建了4个单独的变量, 每个变量名都是n, 但
       是它们的值各不同.
       当程序最终返回 ~up_and_down()~ 的第一级调用时, 最初的n仍是它的初值
    2. 每次函数调用都会返回一次.当函数执行完毕后, 控制权将被传回上一级递归. 程序
       必须按顺序逐级返回递归
    3. 递归函数中位于递归调用之前的语句, 均按被调用的顺序执行
    4. 递归函数中位于递归调用之后的语句, 均按被调函数想法的顺序执行
    5. 虽然每级递归都有自己的变量, 但是并没有靠背函数的代码. 程序按顺序执行函数
       中的代码, 而递归调用就相当于又从头开始执行函数的代码.
       除了为每次递归调用创建变量外, 递归调用非常类似于一个循环语句.
       实际上, 递归有时可用循环来代替, 循环有时也能用递归来代替
    6. 递归函数 *必须* 包含能让递归调用停止的语句.

*** 尾递归
    最简单的递归形式是把递归调用置于函数的末尾, 即正好在 ~return~ 语句之前. 这种
    形式的递归被称为尾递归(tail recursion), 因为递归调用在函数的末尾. 尾递归是最
    简单的递归形式, 因为它相当于循环
    
    尾递归仅要求是该函数执行的 *最后一条语句*.(不一定非要是最后一行或者return)

    *优先使用循环*, 每次递归都会创建一组变量, 所以递归使用的内存更多, 而且每次递
     归调用都会把和藏剑的一组新变量放在栈中. 递归调用的数量受限于内存空间. 其次,
     由此每次函数调用要花费一定的事件, 所以递归的执行速度较慢

*** 递归和倒序计算
    递归在处理倒序时非常方便(在解决这类问题中, 递归比循环简单)

*** 递归的优缺点
    优点: 为某些编程问题提供了最简单的解决方案
    缺点: 一些递归算法会快速消耗计算机的内存资源, 且递归不方便阅读和维护

    所有的C函数皆平等
    程序中的每个C函数与其他函数都是平等的. 每个函数都可以调用其他函数, 或被其他
    函数调用
    main()也可以被自己或其他函数递归调用

** 编译多源代码文件的程序
   
*** UNIX/Linux
    下面命令将编译2个文件并生成一个名为 ~a.out~ 的可执行文件:
    #+begin_src sh
      gcc file.c file2.c
    #+end_src
    另外, 还生成2个名为 ~file1.o~ 和 ~file2.o~ 的目标文件. 如果后来改动了
    ~file1.c~, 而 ~file2.c~ 不变, 可以使用以下命令编译第一个文件, 并与第二个文件
    的目标代码合并:
    #+begin_src sh
      gcc file1.c file2.o
    #+end_src
    UNIX系统的 ~make~ 命令可自动管理多文件程序

*** DOS
    对象文件的扩展名是 ~.obj~ ,而不是 ~.o~. 

*** 使用头文件
     把函数原型放在头文件中, 就不用在每次使用函数文件时都写出函数的原型. C标准库
     就是这样做的

     程序中经常用C预处理器定义符号常量. 这种定义了只储存了那些包含 ~#define~ 指
     令的文件. 如果把程序的一个函数放进一个独立的文件中, 也可以使用 ~#define~ 指
     令访问每个文件

     最好的做法是, 把 ~#define~ 指定放进头文件, 然后在每个源文件中使用
     ~#include~ 指令包含该文件即可

     把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯

** 查找地址: ~&~ 运算符
   指针(pointer)是C语言最重要的(有时也是最复杂的)概念之一, 用于储存变量的地址

   一元 ~&~ 运算符给出的变量的存储地址.可以把地址看错是变量在内存中的位置

   见 ~loccheck.c~:
   2个pooh 的地址不同, 2个bah的地址也不同, 计算机把它们看错4个独立的变量. 函数调
   用仅传递了值, 设计的2个变量并未改变
    
** 指针简介
   指针(pointer)是一个值为内存地址的变量(或数据对象). 指针变量的值是地址.

   假设一个指针变量名是ptr, 可以编写如下语句:
   #+begin_src c
     ptr = &pooh;
   #+end_src

   对于这条语句, 我们说ptr"*指向*"pooh. ptr和&pooh的区别是ptr是变量, 而&pooh是常
   量.还可以把ptr指向别处:
   #+begin_src c
     ptr = &bah;
   #+end_src

   要创建指针变量, 先要声明指针变量的类型

*** 间接运算符: *
    假设已知ptr指向bah, 如下所示:
    #+begin_src c
      ptr = &bah;
    #+end_src
    
    然后使用间接运算符*(indirection operator)找出储存在bah中的值, 该运算符有时也
    称为解引用运算符(dereferencing operator). 不要把间接运算符和二元乘法运算符
    (*)混淆, 虽然符号相同, 但语法功能不同
    #+begin_src c
      val = *ptr; // 找出ptr指向的值
    #+end_src
    
    语句 ~ptr = &bah;~ 和 ~val = *ptr;~ 放在一起相当于下面的语句:
    #+begin_src c
      val = bah;
    #+end_src

    由此可见, 使用地址和间接运算符可以间接完成上面这条语句的功能, 这也是"*间接运
    算符*"名称的由来

    小结: 与指针相关的运算符
    地址运算符: ~&~
    一般注解:
    后跟一个变量名时, ~&~ 给出该变量的地址
    示例:
    ~&nurse~ 表示变量 ~nurse~ 的地址
    
    地址运算符: ~*~
    一般注解:
    后跟一个指针名或地址时, ~*~ 给出储存在指针指向地址上的值
    示例:
    #+begin_src c
      nurse = 22;
      ptr = &nurse; // 指向nurse的指针
      val = *ptr; // 把ptr指向的地址上的值赋给val
    #+end_src

*** 声明指针
    示例:
    #+begin_src c
      int *pi;
      char *pc;
      float *pf, *pg;
    #+end_src
    类型说明符表明了指针所指向对象的类型, 星号(*)表明声明的变量是一个指针
    
    *和指针名之间的 *空格可有可无*. 通常, 在声明时使用空格, 在解引用变量时省略空
     格

     指针实际上是一个新类型

*** 使用指针在函数间通信(swap3.c)
    函数调用
    #+begin_src c
      interchange(&x, &y);
    #+end_src

    该函数传递的不是x和y的值, 而是它们的地址. 这意味着出现在 ~interchange()~ 原
    型和定义中的形式参数u和v将地址作为它们的值. 因此, 应把它们声明为指针.由于x和
    y的整数, 所以u和v是指向整数的指针, 其声明如下:

    #+begin_src c
      void interchange(int *u, int *v)
    #+end_src
    
    C没有引用变量

    简而言之, 普通变量把值作为基本量, 把地址作为通过 ~&~ 运算符获得的派生量, 而
    指针变量把地址作为基本量, 把值作为通过 ~*~ 运算符获得的派生量

** 关键概念

   函数形参和其他局部变量都属于函数私有, 因此, 声明在不同函数中的同名变量是完全
   不同的变量. 而且, 函数U无法直接访问其他函数中的变量. 这种限制访问保护了数据完
   整性.

   当缺少需要在函数中访问另一个函数的数据时, 可以把指针作为函数的参数

** 本章小结
   ANSI C提供了函数原型, 允许编译器验证函数调用中使用参数个数和类型是否正确

   C函数可以调用本身, 这种调用方式被称为递归. 一些编程问题要用递归来解决, 但是递
   归不仅消耗内存多, 效率不高, 而且费时
