* 第9章

** 复习函数
   函数: 完成特定任务的独立代码单元.语法规则定义了函数的结构和使用方式

*** 分析程序(lethead1.c)
    程序在3处使用了 ~starbar~ 标识符:
    - 函数原型(function prototype): 告诉编译器函数 ~starbar()~ 的类型
    - 函数调用(function call): 表明在此处执行函数
    - 函数定义(function definition): 明确地指定了函数要做什么

      
    一般而言, 函数原型指明了函数的 *返回值类型* 和函数接受的 *参数类型*. 这些信
    息称为该函数的 *签名* (signature). 对于 ~starbar()~ 函数而言, 其签名是该函数
    没有返回值, 没有参数

    当计算机执行到 ~starbar()~ 语句时, 会找到该函数的定义并执行其中的内容. 执行
    完 ~starbar()~ 中的代码后, 计算机返回主调函数(calling function) 继续执行到下
    一行

*** 定义带形式参数的函数
    函数定义从下面的ANSI C风格的函数头开始:
    #+begin_src c
      void show_n_char(char ch, int num)
    #+end_src
    该行告知编译器show_n_char)_使用2个参数ch和num, ch是char类型, num是int类型.
    这2个变量被称为形式参数(formal argument, 但是最近的标准推荐使用formal
    parameter), 简称形参. 和定义在函数变量中医院, 形式参数也是局部变量, 属该函数
    私有这意味着在其他函数中使用同名变量 *不会引起名称冲突*. 每次调用函数, 就会
    给这些变量赋值

    *注意*: ANSI C要求每个变量前都声明其类型, 不能像普通变量声明那样使用同一类型的
    变量列表
    #+begin_src c
      void dubs(int x, int y, int z);

      // 以下已废弃(ANSI C之前的形式)
      void show_n_char(ch, num)
      char ch;
      int num;

      // 无效
      void dibs(int x, y, z);
      // 有效
      void dibs(x, y, z)
      int x, y, z;
    #+end_src
    
*** 声明带形式参数函数的原型
    在使用函数之前, 要用ANSI C形式声明函数原型:
    #+begin_src c
      void show_n_char(char ch, int num);
    #+end_src
    当函数接受参数时, 函数原型用逗号分隔的列表指明参数的数量和类型. 根据个人喜好,
    你也可以省略变量名:
    #+begin_src c
      void show_n_char(char, int);
    #+end_src
    在原型中使用变量名并 *没有实际创建变量*, char仅代表了一个char类型的变量, 以
    此类推. 
    ANSI C也接受过去的声明函数形式, 即圆括号内没有参数列表:
    #+begin_src c
      void show_n_char(); // 即将被废弃
    #+end_src
    
*** 调用带实际参数的函数
    在函数调用中, 实际参数(actual argument, 简称实参)提供了ch和num的值.
    
    形式参数是被调函数(called function)中的变量, 实际参数是主调函数(calling
    function)赋给被调函数的具体值.
    
    实际参数可以常量, 变量, 或甚至是更复杂的表达式. 无论实际参数是何种形式都要被
    求值, 然后该值背靠背给被调参数相应的形式参数

    *注意*: 实际参数是出现在函数调用圆括号中的表达式. 形式参数是函数定义的函数头
     中声明的变量. 调用函数时, 创建了声明为形式参数的变量并初始化为实际参数的求
     值结果

*** 使用return从函数中返回值
    被设计用于测试函数的程序有时被称为驱动程序(driver), 该驱动程序调用一个函数.
    如果函数成功通过了测试, 就可以安装在一个更重要的程序中使用

    返回值不仅可以赋给变量, 也可以被用作表达式的一部分.

    返回值不一定是变量的值, 也可以是任意表达式的值

    当返回值类型与函数声明类型不匹配时, 实际得到的返回值相当于把函数中指定的返回
    值赋给与函数类型相同的变量所得到的值(相当于类型转换为函数 *声明的类型*);

*** 函数类型
    声明函数时必须声明函数的类型. 带返回值的函数类型应该与返回值类型相同, 而没有
    返回值的函数应声明为void类型.
    如果没有声明函数的类型, 旧版本的C编译器会假的函数的类型是int.(C99标准不支持)

    函数类型指的是 *返回值的类型*, 不是函数参数的类型.

    函数的前置声明仅需要声明在 *第一次调用函数之前*, 所以 *不限制位置*
    #+begin_src c
      #include <stdio.h>

      int main()
      {
          // 声明有效
          int imin(int, int); //声明imin()函数的原型
      }
    #+end_src
    
** ANSI C函数原型
   旧式的函数声明会导致的问题:
   #+begin_src c
     int imin();
   #+end_src
   以上函数声明并未给出imin()函数的参数个数和类型. 因此, 如果调用imin()时使用的
   参数个数不对或类型不匹配, 编译器根本不会察觉出来

*** 问题所在(misuse.c)
    不同系统的内部机制不同, 所以出现问题的具体情况也不同
    主调函数把它的参数储存在被称为栈(stack)的临时存储区, 被调参数从栈中读取这些
    参数.
    对于该例, 这2个过程并未相互协调. 主调函数根据函数调用中的时机参数, 所以读取
    的第二个值是当时恰好在栈中的其他值

    第二次使用 ~imax()~ 函数时, 它传递的是float类型的值. 这次把2个 ~double~ 类型
    的值放在栈中. 当 ~imax()~ 从栈中读取2个int类型的值时, 它从栈中读取前64位(在int
    类型为32位系统中). 这些数据对应2个整数, 选取较大的数据

*** ANSI的解决方案
    针对参数不匹配的问题, ANSI C标准要求在函数声明时还要声明变量的类型, 即使用函
    数原型(function prototype)来声明函数的返回类型, 参数的数量和每个参数的类型
    #+begin_src c
      int imax(int, int);
      int imax(int a, int b);
    #+end_src
    *注意*: 这里的变量名假名, 不必与函数定义的形式参数名一致

    有了这些信息, 编译器可以检查函数的调用是否与函数原型匹配.

    当参数类型不匹配时, 会强制转换, 例如: double转int会丢失精度(3.9 转为 3)
