* 第5章

** 基本运算符
   - 使用pow()等数学函数记得#include <math.h>

*** 赋值运算符: =
    - 格式:
    i = i + 1;
    左值(不能是常量) 赋值运算符 右值

    - 数据对象(data object): 用于储存值得数据存储区域(统称)
      + C *仅有* 在提到这个概念时才会用到对象这个术语
      + 使用对象名是标识对象的一种方法
        * 其他方式: 指定数组元素, 结构成员
    - 左值: 用于标识特定数据对象的名称或表达式
    - 右值: 能赋值给可修改左值的量
      表达式内都是临时值, 计算完成后便会被丢弃


    旧版提到左值的操作:
    1. 指定一个对象, 引用内存中的地址
    2. 可用在赋值运算符的左侧, 左值(lvalue)中的l源自left

    新版增加了const限定符, 提到左值的操作步骤2为: 可修改的左值

*** 减法运算符: -
    +和-运算符都被称为二元运算符(binary operator), 需要2个运算对象才能完成操作

*** 符号运算符: -和+
    - ~36-12~: 2个运算对象(二元)
    - ~-16~: 一个运算对象(一元)
    - ~-(12-20)~: 一个运算对象+两个运算对象(一元二元皆有)

*** 除法运算符
    整数除法结果的小数部分被 *丢弃*, 这一过程被称为截断(truncation)

    趋零截断, -3.8截断为-3

*** 运算符优先级
    1. 执行()内部分
    2. 计算表达式中的 * 或 /
    3. 计算表达式中的 + 或 -

       
    优先级表:
    | 运算符     | 结合律   |
    |------------+----------|
    | ()         | 从左往右 |
    | + - (一元) | 从右往左 |
    | * /        | 从左往右 |
    | + - (二元) | 从左往右 |
    | =          | 从右往左 |

*** 优先级和求值顺序
    例: 
    #+begin_src c
      int y = 6 * 12 + 5 * 20;
    #+end_src
    先进行乘法运算, 后进行加法运算
    但优先级 *未规定* 先进行哪一个乘法, 交给语言的实现者执行

** 其他运算符

*** sizeof运算符和size_t类型
    为类型创建别名
    #+begin_src c
      typedef dobule real;
      real deal; // double类型
    #+end_src

    printf打印显示size_t类型的值: %zd(C99), %u或%lu

*** 求模运算符
    C99标准规定只要 ~a%b~ 中 a 和 b 都是整数值, 便可通过 ~a ~ (a/b) * b~ 来计算
    ~a%b~

*** 优先级
    递增递减运算符优先级仅次于圆括号()
    ~x*y~ 表达的是 ~(x)*(y++)~

*** 不要自作聪明
    ~y = n++ + n++;~
    仅保证语句执行后, n += 2, y的值不确定, 根据编译器不同结果不同

    运算守则:
    1. 如果一个变量出现在一个函数的多个参数中, 不要对该变量使用递增/递减运算符
    2. 如果一个变量出现在一个函数的多个表达式中, 不要对该变量使用递增/递减运算符

** 表达式和语句
   
*** 表达式
    表达式(expression): 由运算符和运算对象组成(运算对象是运算操作符的对象)

    C表达式重要特性: *每个表达式都有一个值*

    示例表达式对应值表
    | 表达式          | 值 |
    |-----------------+----|
    | -4 + 6          |  2 |
    | c = 3 + 8       | 11 |
    | 5 > 3           |  1 |
    | 6 + (c = 3 + 8) | 17 |

*** 语句
    语句(statement)是C程序的基本构建块, 一条语句相当于一条完成的计算机指令

    空语句: 
    #+begin_src c
      ; // 空语句
    #+end_src
   
    *注意*:
    1. 声明不是表达式语句, 也没有值
    2. 函数表达式语句会引起函数调用

       
    副作用和序列点

    1. 副作用(side effect): 对数据对象或文件的修改
       - 示例: ~states = 50;~
       - 调用printf()函数时, 显示的信息其实是副作用(printf()的返回值是待显示字符的个数)
    
    2. 序列点(sequence point): 是程序执行的点, 在该点上, 所有的副作用都在进入下
       一步之前发生
       语句中的分号标记了一个序列点:
       
       在一个语句中, 赋值运算符, 递增运算符和递减运算符对运算对象做的改变必须在
       程序执行下一条语句之前完成

    3. 完成表达式(full expression): 指这个表达式不是被另一个更大表达式的子表达式

       
    聚合示例:
    #+begin_src c
      // 先比较, 后递增
      while (guests++ < 10) // 完整表达式 -- 是while循环的测试条件, 该表达式结束就是一个序列点
          printf("%d \n", guests); // 执行printf之前已经递增
    #+end_src
       
*** 复合语句(块)
    由花括号括起来的一条或多条语句组成
   
** 类型转换
   类型转换规则:
   1. 当类型转换出现在表达式时, 无论是unsigned还是singed的char和short都会被自动
      转换成int. 有必要会被转换成 unsigned int(若short与int大小相同, unsigned
      short就比int大. 这种情况下, unsigned short会被转换成 unsigned int)
      早期(K&R时代)的C中, float会被自动转换成double
      由于都是从较小类型转换为较大类型, 所以这些转换被称为升级(promotion)
   
   2. 涉及2种类型的运算, 2个值会被分别转换成2种类型的更高级别

   3. 类型的级别从高到低一次是long double, double, float, unsigned long long,
      long long, unsigned long, long, unsigned int, int.
      当long和int的大小相同时, unsigned int比long的级别高
      short和char类型已经被升级到int或unsigned int

   4. 在赋值表达式语句中, 计算的最终结果会被转换成被赋值变量的类型, 该过程可能导
      致类型升级/降级(demotion)

   5. 当作为函数参数传递时, char喝short被转换成int, float被转换成 double.
      第9章中, 函数原型会覆盖自动升级

      
   当待转换的值与目标类型不匹配时的规则:
   1. 目标类型是无符号类型, 且待赋的值是整数时, 额外的位将被忽略
      例: 如果目标类型是8位 unsigned char, 待赋的值是原始值求模256
   
   2. 如果目标类型是一个有符号类型, 且待赋的值是整数时, 结果因实现而异

   3. 如果目标类型是一个整型, 且待赋的值是浮点数, 该行为未定义

*** 强制类型转换符
    (type)
    例:
    #+begin_src c
      mice = (int)1.6 + (int)1.7;
    #+end_src
    运算符图:
    | 赋值运算符 | 说明                                                                                 |
    |------------+--------------------------------------------------------------------------------------|
    | =          | 将其右侧的值赋给左侧的变量                                                           |
    |------------+--------------------------------------------------------------------------------------|
    | 算术运算符 | 说明                                                                                 |
    | +          | 将其左侧的值与右侧的值相加                                                           |
    | -          | 将其左侧的值减去右侧的值                                                             |
    | -          | 作为一元运算符, 改变其右侧值的符号                                                   |
    | *          | 将其左侧的值乘以右侧的值                                                             |
    | //         | 将其左侧的值除以右侧的值                                                             |
    | %          | 当其左侧的值除以右侧的值时, 取其余数(只能应用于整数)                                 |
    | ++         | 对其右侧的值加1(前缀模式), 或对齐左侧的值加1(后缀模式)                               |
    | --         | 对其右侧的值减1(前缀模式), 或对齐左侧的值减1(后缀模式)                               |
    |------------+--------------------------------------------------------------------------------------|
    | 其他运算符 | 说明                                                                                 |
    | sizeof     | 获得其右侧运算对象的大小(以字节为单位), 运算对象可以是一个被圆括号括起来的类型说明符 |
    |            | 如sizeof(float), 或者是一个具体的变量名, 数组名等, 如sizeof foo                      |
    | (类型名)   | 强制类型转换, (float) 9 = 9.00                                                              |

** 带参数的函数

** 示例程序

** 关键概念

** 本章小结

** 复习题

** 编程练习
