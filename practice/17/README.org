* 高级数据表示
  本章介绍以下内容

  - 函数: 进一步学习 ~malloc()~
  - 使用 C 表示不同类型的数据
  - 新的算法, 从概念上增强开发程序的成立
  - 抽象数据类型(ADT)
    
    本章重点介绍如何把项目看作一个整体.

    从程序设计的关键部分开始, 即数据表示方式. 程序开发最重要的部分是 *找到程序中
    表示数据的好方法*, 正确地表示数据可以更容易地编写程序其余部分. 到目前为止,
    应该熟悉的内置类型: 简单变量, 数组, 指针, 结构和联合

    找出正确的数据不仅仅是一种数据类型, 还要必须考虑进行哪些操作. 必须确定 *如何
    存储数据*, 并且为数据类型 *定义有效的操作*.
    
    eg: C 实现通常把 int 类型和指针类型都储存为整数, 但是这两种类型的有效操作不
    相同. 
    eg: 两个整数可以相乘, 但是 *指针不能相乘*; 可以用 ~*~ 运算符解引用指针, 但是
    对整数这样做毫无意义. C 语言为它的基本类型都定义了有效的操作. 但是, 当要涉及
    数据表示的方案时, 可能需要自己定义有效操作.

    C 语言中, 可以把所需的操作设计成 C 函数来表示. 
    简而言之, 设计一种数据类型包括设计如何储存该数据类型和设计一系列管理该数据的函数

    本章还会介绍一些算法, 即 *操控数据* 的方法. 应该掌握这些可以反复解决类似问题
    的处理方法.

    本章将进一步研究设计数据类型的过程, 这是一个把算法和数据表示相匹配的过程. 期
    间会用到一些常见的数据形式, 如队列, 列表和二叉树.

    本章还将介绍 *抽象数据类型(ADT)* 的概念. 抽象数据类型以面向问题而不是面向语
    言的方式, 把解决问题的方法和数据表示结合起来. 设计一个 ADT 后, 可以在不同的
    环境中复用. 理解 ADT 可以为将来学习面向对象程序设计(OOP) 以及 C++ 语言做好准
    备

** 研究数据表示
   假设要创建一个地址薄程序. 应该使用什么数据形式存储信息? 由于储存的每一项都包
   含多种信息, 用结构来表示每一项合适. 如何表示多个项? 是否用标准的结构数组? 还
   是动态数组? 还是一些其他形式? 各项是否按字母顺序排列? 是否要按照邮政编码(或 id
   去编码) 查找各项? 需要执行的行为将如何存储信息? 简而言之, 在开始编写代码之前,
   要在程序设计方面做很多决定

   如何表示储存在内存中的位图图像? 位图图像中的每个像素在屏幕上都单独设置. 在以
   前的黑白屏的年代, 可以使用一个计算机位(1 或 0)来表示一个像素点(开或关), 因此
   称之为位图. 对于彩色显示器而言, 如果 8 位表示一个像素, 可以得到 256 种颜色.
   现在行业标准已经发展到 65536 色(每像素 16 位), 16777216 色(每像素 24 位),
   2147483 色(每像素 32 位), 甚至更多. 如果有 32 位色, 且显示器有 2560 * 1440 的
   分辨率, 则需要将近 1.18 亿位(14 M) 来表示一个屏幕的位图图像. 是用这种方法表示,
   还是开发一种压缩信息的方法? 是有损压缩(丢失相对次要的数据) 还是无损压缩(没有
   丢失数据)? 开始编写代码之前, 需要做很多程序设计方面的决定

   来处理一个数据表示的示例. 假设要编写一个程序, 让用户输入一年内看过的所有电影
   (包括 DVD 和 蓝光光碟). 要储存每部影片的各种信息, eg: 片名, 发行年份, 导演,
   主演, 片长, 影片的种类(喜剧, 科幻, 爱情等), 评级等. 建议使用一个结构储存每部
   电影, 一个数组储存一年内看过的电影. 为简单起见, 我们规定结构中只有 2 个成员:
   片名和评级(0 ~ 10). ~films1.c~ 演示了一个基本的实现

   该程序创建了一个结构数组, 然后把用户输入的数据储存在数组中. 直到数组已满(用
   FMAX 判断)或者达到结尾(~NULL~ 判断), 或者用户首行按下 ENTER(用 ~'\0'~ 判断),
   输入才会终止

   这样设计程序有问题. 首先, 该程序可能会浪费许多 *空间*, 因为大部分的片名都不会
   超过 40 个字符. 但是, 有的片名的确很长. 其次, 许多人会觉得每年 5 部电影的限制
   太严格, 放宽多大才合适? 很可能浪费大量内存. 一些编译器对自动存储类别的变量
   (eg: movies)可用的内存数量设置了一个默认的限制, 大型的数组可能会超过默认设置
   的值. 可以把数组声明为 *静态* 或 *外部数组*, 或者设置编译器使用更大的栈来解决
   这个问题. 但是这样做 *并不能解决根本问题*.

   该程序真正的问题是, 数据表示 *不太灵活*. 程序在编译时确定所需内存量, 改成运行
   时会更好.

   #+begin_src c
     #define TSISE 45

     struct film {
       char title[TSIZE];
       int rating;
     };

     // ...

     int n, i;
     struct film* movies; // 指向结构的指针

     // ...

     printf("Enter the maximum number of movies you'll enter:\n");
     scanf("%d", &n);

     movies = (struct film*)malloc(n * sizeof(struct film));
   #+end_src

   使用 ~malloc()~, 可以推迟到程序运行时才确定数组中的元素数量. 所以, 如果只需要
   20 个元素, 就不必分配 500 个元素的空间. ong 付要为元素个数提供正确的值

** 从数组到链表
   理想的情况是, 用户可以不确定地添加数据(或者不断添加数据知道用完内存量), 而不
   是先指定要输入多少项, 也不用让程序分配多余的空间. 这可以通过在输入每一项后调
   用 ~malloc()~ 分配正好能储存该项的空间. 如果用户输入 3 部影片, 程序就调用
   ~malloc()~ 3 次; 如果用户输入 300 部 影片, 程序就调用 ~malloc()~ 300 次. 

   比较: 一种方法是调用 ~malloc()~ 一次, 为 300 个 ~film~ 结构请求分配足够的空
   间. 前者分配的是连续的内存块, 只需要一个单独的指向 ~struct~ 变量(film) 的指针,
   该指针指向已分配块中的第一个结构. 简单的数组表示法让指针访问块中的每个结构,
   如前面的代码所示. 第二种方法的问题是, 无法保证每次调用 ~malloc()~ 都能分配到
   连续的内存块. 这意味着结构不一定被连续储存. 因此, 与第一种方法储存一个指向
   300 个结构块的指针相比, 需要储存 300 个指针, 每个指针指向一个单独储存的结构

   两种方法: 
   1. 一种解决方法是创建一个大型的指针数组, 并在分配新结构时逐个给这些指针赋值:
      #+begin_src c
        #define TSIZE 45
        #define FMAX 500

        struct film {
          char title[TSIZE];
          int rating;
        };

        // ...

        struct film* movies[FMAX]; // 结构指针数组

        int i;

        // ...

        movies[i] = (struct film*)malloc(sizeof(struct fiml));

      #+end_src

      如果用不完 500 个指针, 这种方法节约了大量的内存, 因为内含 500 个指针的数组
      比内含 500 个结构的数组所占的内存少的多. 尽管如此, 如果用不到 500 个指针,
      还是浪费了不少空间. 而且, 这样还是有 500 个结构的限制.

   2. 更好的方法: 每次使用 ~malloc()~ 为新结构分配空间时, 也为新指针分配空间. 但
      是还得需要另一个指针来跟踪新分配的指针, 用于跟踪新指针的指针本身, 也需要一
      个指针来跟踪. 以次类推. 要重新定义结构材料解决这个潜在的问题, 即每个结构中
      包含指向 next 结构的指针. 然后, 当创建新结构时, 可以把该结构的地址储存在上
      一个结构中. 简而言之, 可以这样定义 ~film~ 结构:

      #+begin_src c
        #define TSIZE 45

        struct fiml {
          char title[TSIZE];
          int rating;
          struct film* next;
        }
      #+end_src

      虽然结构不能含有与自身类型相同的结构, 但是可以含有指向同类型结构的指针. 这
      种定义是 *链表(linked list)* 的基础,链表中的每一项都包含着在何处能找到下一
      项的信息.

      概念上理解链表: 假设用户输入片名 Modern Times, 等级为 10. 程序将为 film 类
      型结构分配空间, 把字符串 Modern Times 拷贝到结构中的 title 成员中, 然后设
      置 rating 成员为 10. 为了表明该结构后面没有其他结构, 程序要把 next 成员指
      针设置为 ~NULL(符号常量, 表示空指针)~. 当然, 还需要一个单独的指针储存第一
      个结构的地址, 该指针被称为 *头指针(head pointer)*. 头指针指向链表中的第一
      项. 

      #+begin_src c
        #define TSIZE 45

        struct film {
          char title[TSIZE];
          int rating;
          struct film* next;
        };

        struct film* head;
      #+end_src
      
      现在, 假设用户输入第二部电影及其评级, 如 Midnight in Paris 和 8. 程序为第
      二个 film 类型结构分配空间, 把新结构的地址储存在第一个结构的 next 成员中
      (擦写了之前储存在该成员中的 NULL), 这样链表中第一个结构中的 next 指针指向
      第二个结构. 然后程序把 Midnight in Parais 和 8 拷贝到新结构中, 并把第二个
      结构中的 next 成员设置为 NULL, 表明该结构是链表中的最后一个结构

      没加入一部新电影, 就以相同的方式来处理. 新结构的地址将储存在上一个结构中,
      新信息储存在新结构中, 而且新结构中的 next 成员设置为 NULL

      假设要显示这个链表, 每显示一项, 就可以根据该项中已储存的地址来定义下一个待
      显示的项. 然而, 这种方法能正常余晓玲, 还需要一个指针储存链表中第一项的地址,
      因为链表中没有其他项储存该项的地址. 此时, 头指针就派上了用场.

**** 使用链表
     实现: ~film2.c~

     该程序用链表执行 2 个任务: 第一个任务是: 构造一个链表, 把用户输入的数据储存
     在链表中. 第二个任务是: 显示链表. 显示链表的任务比较简单

     1. 显示链表
        显示链表从设置一个指向第一个结构的指针(名为 current) 开始. 由于头指针(名
        为 head)已经指向链表中的第一个结构, 所以可以用下面的代码来完成
        #+begin_src c
          current = head;
        #+end_src

        然后, 可以使用指针表示法访问结构的成员:
        #+begin_src c
          printf("Movie: %s Rating: %d\n", current->title, current->rating);
        #+end_src

        完成这些之后, 在重复整个过程, 但显示到链表中最后一个项时, ~current~ 将被
        设置为 ~NULL~, 因为这是链表最后一个结构中 next 成员的值
        #+begin_src c
          while (current != NULL)
          {
            printf("Movie: %s Rating: %d\n", current->title, current->rating);
            current = current->next;
          }
        #+end_src

        遍历链表时, 需要创建一个新的指针, 直接使用 head 会改变 head 的值, 导致程
        序还找不到链表的开始处

     2. 创建链表
        步骤:
        1) 使用 ~malloc()~ 为结构分配足够的空间
        2) 储存结构的地址
        3) 把当前信息拷贝到结构中

        如无必要不要红创建一个结构, 所以程序使用临时存储区(input 数组) 获取用户
        输入的电影名. 如果用户通过键盘模拟 ~EOF~ 或输入一行空行, 将退出下面的循
        环:
        #+begin_src c
          while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
        #+end_src

        如果用户进行输入, 程序就分配一个结构的空间, 并将其地址赋给指针变量
        current:
        #+begin_src c
          current = (struct film*)malloc(sizeof(struct film));
        #+end_src

        链表中第一个结构的地址应储存在指针变量 head 中. 随后每个结构的地址应储存
        在其前一个结构的 next 成员中. 因此, 程序要知道它处理的是否是第一个结构.
        最简单的方法是在程序开始时, 把 head 指针初始化为 NULL. 然后, 程序可以使
        用 head 的值进行判断:
        #+begin_src c
          if (head == NULL)
          {
            head = current;
          }
          else
          {
            prev->next = current;
          }
        #+end_src

        指针 prev 指向上一次分配的结构.
        
        接下来, 必须为结构成员设置合理的值. 尤其是: 把 next 成员设置为 NULL, 表
        明当前结构是链表的最后一个结构. 还要把 input 数组中的电影名拷贝到 title
        成员中, 而且要给 rating 成员赋值:
        #+begin_src c
          current->next = NULL;
          strcpy(current->title, input);
          puts("Enter your rating <0-10>:");
          scanf("%d", &current->rating);
        #+end_src

        由于 ~s_gets()~ 限制了只能输入 ~TSIZE-1~ 个字符, 所以用 ~strcpy()~ 函数
        把 input 数组中的字符串拷贝到 title 成员很安全

        最后, 要为下一次输入做好准备. 尤其要设置 prev 指向当前结构. 因为在用户输
        入下一步电影且成员为新结构分配空间后, 当前结构将成为新结构的上一个结构,
        所以程序在循环末尾这样设置指针:
        #+begin_src c
          prev = current;
        #+end_src
        
     3. 释放链表
        在许多环境中, 程序结束时都会自动释放 ~malloc()~ 分配的内存. 但是, 最好还
        是成对调用 ~malloc()~ 和 ~free()~. 因此, 程序在清理内存时为每个已分配的
        结构都调用了 ~free()~ 函数:
        #+begin_src c
          current = head;

          while (current != NULL) {
            current = head;
            head = current->next;
            free(current);
          }
        #+end_src

        
**** 反思
     ~film2.c~ 程序还有些不足. eg: 程序没有检查 ~malloc()~ 是否成功请求到内存,
     也无法删除链表中的项. 这些不足可以弥补. eg: 添加代码检查 ~malloc()~ 的返回
     值是否是 ~NULL~ (返回 NULL 说明未获得所需内存). 如果程序要删除链表 中的项,
     还要编写更多的代码.

     这种用 *特定方法解决特定问题*, 并且在需要时才添加相关功能的变成方式通常不是
     最好的解决方案. 另一方面, 通常都无法预料程序要完成的所有任务. 随着编程项目
     越来越大, 一个程序员或编程团队事先计划好一切模式, 越来越不现实. 很多成功的
     大型程序都是由成功的小型程序逐步发展而来.

     如果要修改程序, 首先应该强调最初的设计, 并简化其他细节. ~film2.c~ 中的程序
     示例没有遵循这个原则, 它把概念模型和代码细节混在一起. eg: 该程序的概念模型
     是在一个链表中添加项, 但是程序却把一些细节(eg: ~malloc()~ 和
     ~current->next~ 指针)放在 *最明显* 的位置, 没有 *突出接口*. 如果程序能以某
     种方式强调给链表添加项, 并隐藏具体的处理细节(如调用内存管理函数和设置指针)
     会更好. 把 *用户接口和代码细节分开的程序, 更容易理解和更新*.
** 抽象数据类型(ADT)
   在编程时, 应该根据编程问题匹配合适的数据类型. eg: 用 ~int~ 类型代表你有多少双
   鞋, 用 ~float~ 或 ~double~ 类型代表每双鞋的价格. 在前面的电影示例中, 数据构成
   了链表, 每个链表项由电影名 (C 字符串) 和评级 (一个 int 类型的值). C 中没有与
   之匹配的基本类型, 所以我们定义了一个结构代表单独的项, 然后设计了一些方法把一
   系列结构构成一个链表. 本质上, 我们使用 C 语言的功能设计了一种符合程序要求的新
   数据类型. 但是并 *不系统*. 现在, 我们用更系统的方法来定义数据类型

   *注意*: 整数属性

   C 的 ~int~ 类型背后是一个更抽象的整数概念. 数学家已经用正式的抽象方式定义了整
   数的属性. eg: N 和 M 是整数, 那么 ~N+M=M+N~; 假设 S, Q 也是整数, 如果
   ~N+M=S~, 而且 ~N+Q=S~, 那么 ~M=Q~. 可以认为数学家提供了整数的抽象概念, 而 C
   则实现了这一抽象概念. *注意*: 实现整数的算术运算是表示整数必不可少的部分. 如
   果只是储存值, 并未在算术表达式中使用, ~int~ 类型就没那么有用了. 还要注意的是,
   C 并未很好地实现整数. eg: 整数是无穷大的数, 但是 2 字节的 int 类型只能表示
   65536 个整数. 因此, *不要混淆抽象概念和具体的实现*

   假设要定义一个新的数据类型. 首先, 必须提供储存数据的方法, eg: 设计一个结构.
   其次, 必须提供操控数据的方法. eg: 考虑 ~films2.c~ 程序. 该程序用链接的结构来
   储存信息, 并且通过代码实现了如何添加和显示信息. 尽管如此, 该程序并未清楚地表
   明正在创建一个新类型. 做法:

   计算机科学领域已开发了一种定义新类型的好方法, 用 3 个步骤完成从抽象到具体的
   过程:

   1. 提供类型属性和相关操作的抽象描述. 这些描述既不能依赖特定的实现, 也不能依赖
      特定的编程语言. 这种正式的抽象描述被称为抽象数据类型(ADT)

   2. 开发一个实现 ADT 的编程接口. 也就是说, 指名如何储存数据和执行所需操作的函
      数. eg: 在 C 中, 可以提供结构定义和操控该结构的函数原型. 这些作用于用户定
      义类型的函数相当于作用与 C 基本类型的内置运算符. 需要使用该新类型的程序员
      可以使用这个接口进行编程

   3. 编写代码实现接口. 这一步至关重要, 但是使用该新类型的程序员无需了解具体的实
      现细节.
