* 高级数据表示
  本章介绍以下内容

  - 函数: 进一步学习 ~malloc()~
  - 使用 C 表示不同类型的数据
  - 新的算法, 从概念上增强开发程序的成立
  - 抽象数据类型(ADT)
    
    本章重点介绍如何把项目看作一个整体.

    从程序设计的关键部分开始, 即数据表示方式. 程序开发最重要的部分是 *找到程序中
    表示数据的好方法*, 正确地表示数据可以更容易地编写程序其余部分. 到目前为止,
    应该熟悉的内置类型: 简单变量, 数组, 指针, 结构和联合

    找出正确的数据不仅仅是一种数据类型, 还要必须考虑进行哪些操作. 必须确定 *如何
    存储数据*, 并且为数据类型 *定义有效的操作*.
    
    eg: C 实现通常把 int 类型和指针类型都储存为整数, 但是这两种类型的有效操作不
    相同. 
    eg: 两个整数可以相乘, 但是 *指针不能相乘*; 可以用 ~*~ 运算符解引用指针, 但是
    对整数这样做毫无意义. C 语言为它的基本类型都定义了有效的操作. 但是, 当要涉及
    数据表示的方案时, 可能需要自己定义有效操作.

    C 语言中, 可以把所需的操作设计成 C 函数来表示. 
    简而言之, 设计一种数据类型包括设计如何储存该数据类型和设计一系列管理该数据的函数

    本章还会介绍一些算法, 即 *操控数据* 的方法. 应该掌握这些可以反复解决类似问题
    的处理方法.

    本章将进一步研究设计数据类型的过程, 这是一个把算法和数据表示相匹配的过程. 期
    间会用到一些常见的数据形式, 如队列, 列表和二叉树.

    本章还将介绍 *抽象数据类型(ADT)* 的概念. 抽象数据类型以面向问题而不是面向语
    言的方式, 把解决问题的方法和数据表示结合起来. 设计一个 ADT 后, 可以在不同的
    环境中复用. 理解 ADT 可以为将来学习面向对象程序设计(OOP) 以及 C++ 语言做好准
    备

** 研究数据表示
   假设要创建一个地址薄程序. 应该使用什么数据形式存储信息? 由于储存的每一项都包
   含多种信息, 用结构来表示每一项合适. 如何表示多个项? 是否用标准的结构数组? 还
   是动态数组? 还是一些其他形式? 各项是否按字母顺序排列? 是否要按照邮政编码(或 id
   去编码) 查找各项? 需要执行的行为将如何存储信息? 简而言之, 在开始编写代码之前,
   要在程序设计方面做很多决定

   如何表示储存在内存中的位图图像? 位图图像中的每个像素在屏幕上都单独设置. 在以
   前的黑白屏的年代, 可以使用一个计算机位(1 或 0)来表示一个像素点(开或关), 因此
   称之为位图. 对于彩色显示器而言, 如果 8 位表示一个像素, 可以得到 256 种颜色.
   现在行业标准已经发展到 65536 色(每像素 16 位), 16777216 色(每像素 24 位),
   2147483 色(每像素 32 位), 甚至更多. 如果有 32 位色, 且显示器有 2560 * 1440 的
   分辨率, 则需要将近 1.18 亿位(14 M) 来表示一个屏幕的位图图像. 是用这种方法表示,
   还是开发一种压缩信息的方法? 是有损压缩(丢失相对次要的数据) 还是无损压缩(没有
   丢失数据)? 开始编写代码之前, 需要做很多程序设计方面的决定

   来处理一个数据表示的示例. 假设要编写一个程序, 让用户输入一年内看过的所有电影
   (包括 DVD 和 蓝光光碟). 要储存每部影片的各种信息, eg: 片名, 发行年份, 导演,
   主演, 片长, 影片的种类(喜剧, 科幻, 爱情等), 评级等. 建议使用一个结构储存每部
   电影, 一个数组储存一年内看过的电影. 为简单起见, 我们规定结构中只有 2 个成员:
   片名和评级(0 ~ 10). ~films1.c~ 演示了一个基本的实现

   该程序创建了一个结构数组, 然后把用户输入的数据储存在数组中. 直到数组已满(用
   FMAX 判断)或者达到结尾(~NULL~ 判断), 或者用户首行按下 ENTER(用 ~'\0'~ 判断),
   输入才会终止

   这样设计程序有问题. 首先, 该程序可能会浪费许多 *空间*, 因为大部分的片名都不会
   超过 40 个字符. 但是, 有的片名的确很长. 其次, 许多人会觉得每年 5 部电影的限制
   太严格, 放宽多大才合适? 很可能浪费大量内存. 一些编译器对自动存储类别的变量
   (eg: movies)可用的内存数量设置了一个默认的限制, 大型的数组可能会超过默认设置
   的值. 可以把数组声明为 *静态* 或 *外部数组*, 或者设置编译器使用更大的栈来解决
   这个问题. 但是这样做 *并不能解决根本问题*.

   该程序真正的问题是, 数据表示 *不太灵活*. 程序在编译时确定所需内存量, 改成运行
   时会更好.

   #+begin_src c
     #define TSISE 45

     struct film {
       char title[TSIZE];
       int rating;
     };

     // ...

     int n, i;
     struct film* movies; // 指向结构的指针

     // ...

     printf("Enter the maximum number of movies you'll enter:\n");
     scanf("%d", &n);

     movies = (struct film*)malloc(n * sizeof(struct film));
   #+end_src

   使用 ~malloc()~, 可以推迟到程序运行时才确定数组中的元素数量. 所以, 如果只需要
   20 个元素, 就不必分配 500 个元素的空间. ong 付要为元素个数提供正确的值

** 从数组到链表
   理想的情况是, 用户可以不确定地添加数据(或者不断添加数据知道用完内存量), 而不
   是先指定要输入多少项, 也不用让程序分配多余的空间. 这可以通过在输入每一项后调
   用 ~malloc()~ 分配正好能储存该项的空间. 如果用户输入 3 部影片, 程序就调用
   ~malloc()~ 3 次; 如果用户输入 300 部 影片, 程序就调用 ~malloc()~ 300 次. 

   比较: 一种方法是调用 ~malloc()~ 一次, 为 300 个 ~film~ 结构请求分配足够的空
   间. 前者分配的是连续的内存块, 只需要一个单独的指向 ~struct~ 变量(film) 的指针,
   该指针指向已分配块中的第一个结构. 简单的数组表示法让指针访问块中的每个结构,
   如前面的代码所示. 第二种方法的问题是, 无法保证每次调用 ~malloc()~ 都能分配到
   连续的内存块. 这意味着结构不一定被连续储存. 因此, 与第一种方法储存一个指向
   300 个结构块的指针相比, 需要储存 300 个指针, 每个指针指向一个单独储存的结构

   两种方法: 
   1. 一种解决方法是创建一个大型的指针数组, 并在分配新结构时逐个给这些指针赋值:
      #+begin_src c
        #define TSIZE 45
        #define FMAX 500

        struct film {
          char title[TSIZE];
          int rating;
        };

        // ...

        struct film* movies[FMAX]; // 结构指针数组

        int i;

        // ...

        movies[i] = (struct film*)malloc(sizeof(struct fiml));

      #+end_src

      如果用不完 500 个指针, 这种方法节约了大量的内存, 因为内含 500 个指针的数组
      比内含 500 个结构的数组所占的内存少的多. 尽管如此, 如果用不到 500 个指针,
      还是浪费了不少空间. 而且, 这样还是有 500 个结构的限制.

   2. 更好的方法: 每次使用 ~malloc()~ 为新结构分配空间时, 也为新指针分配空间. 但
      是还得需要另一个指针来跟踪新分配的指针, 用于跟踪新指针的指针本身, 也需要一
      个指针来跟踪. 以次类推. 要重新定义结构材料解决这个潜在的问题, 即每个结构中
      包含指向 next 结构的指针. 然后, 当创建新结构时, 可以把该结构的地址储存在上
      一个结构中. 简而言之, 可以这样定义 ~film~ 结构:

      #+begin_src c
        #define TSIZE 45

        struct fiml {
          char title[TSIZE];
          int rating;
          struct film* next;
        }
      #+end_src

      虽然结构不能含有与自身类型相同的结构, 但是可以含有指向同类型结构的指针. 这
      种定义是 *链表(linked list)* 的基础,链表中的每一项都包含着在何处能找到下一
      项的信息.

      概念上理解链表: 假设用户输入片名 Modern Times, 等级为 10. 程序将为 film 类
      型结构分配空间, 把字符串 Modern Times 拷贝到结构中的 title 成员中, 然后设
      置 rating 成员为 10. 为了表明该结构后面没有其他结构, 程序要把 next 成员指
      针设置为 ~NULL(符号常量, 表示空指针)~. 当然, 还需要一个单独的指针储存第一
      个结构的地址, 该指针被称为 *头指针(head pointer)*. 头指针指向链表中的第一
      项. 

      #+begin_src c
        #define TSIZE 45

        struct film {
          char title[TSIZE];
          int rating;
          struct film* next;
        };

        struct film* head;
      #+end_src
      
      现在, 假设用户输入第二部电影及其评级, 如 Midnight in Paris 和 8. 程序为第
      二个 film 类型结构分配空间, 把新结构的地址储存在第一个结构的 next 成员中
      (擦写了之前储存在该成员中的 NULL), 这样链表中第一个结构中的 next 指针指向
      第二个结构. 然后程序把 Midnight in Parais 和 8 拷贝到新结构中, 并把第二个
      结构中的 next 成员设置为 NULL, 表明该结构是链表中的最后一个结构

      没加入一部新电影, 就以相同的方式来处理. 新结构的地址将储存在上一个结构中,
      新信息储存在新结构中, 而且新结构中的 next 成员设置为 NULL

      假设要显示这个链表, 每显示一项, 就可以根据该项中已储存的地址来定义下一个待
      显示的项. 然而, 这种方法能正常余晓玲, 还需要一个指针储存链表中第一项的地址,
      因为链表中没有其他项储存该项的地址. 此时, 头指针就派上了用场.

**** 使用链表
     实现: ~film2.c~

     该程序用链表执行 2 个任务: 第一个任务是: 构造一个链表, 把用户输入的数据储存
     在链表中. 第二个任务是: 显示链表. 显示链表的任务比较简单

     1. 显示链表
        显示链表从设置一个指向第一个结构的指针(名为 current) 开始. 由于头指针(名
        为 head)已经指向链表中的第一个结构, 所以可以用下面的代码来完成
        #+begin_src c
          current = head;
        #+end_src

        然后, 可以使用指针表示法访问结构的成员:
        #+begin_src c
          printf("Movie: %s Rating: %d\n", current->title, current->rating);
        #+end_src

        完成这些之后, 在重复整个过程, 但显示到链表中最后一个项时, ~current~ 将被
        设置为 ~NULL~, 因为这是链表最后一个结构中 next 成员的值
        #+begin_src c
          while (current != NULL)
          {
            printf("Movie: %s Rating: %d\n", current->title, current->rating);
            current = current->next;
          }
        #+end_src

        遍历链表时, 需要创建一个新的指针, 直接使用 head 会改变 head 的值, 导致程
        序还找不到链表的开始处

     2. 创建链表
        步骤:
        1) 使用 ~malloc()~ 为结构分配足够的空间
        2) 储存结构的地址
        3) 把当前信息拷贝到结构中

        如无必要不要红创建一个结构, 所以程序使用临时存储区(input 数组) 获取用户
        输入的电影名. 如果用户通过键盘模拟 ~EOF~ 或输入一行空行, 将退出下面的循
        环:
        #+begin_src c
          while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
        #+end_src

        如果用户进行输入, 程序就分配一个结构的空间, 并将其地址赋给指针变量
        current:
        #+begin_src c
          current = (struct film*)malloc(sizeof(struct film));
        #+end_src

        链表中第一个结构的地址应储存在指针变量 head 中. 随后每个结构的地址应储存
        在其前一个结构的 next 成员中. 因此, 程序要知道它处理的是否是第一个结构.
        最简单的方法是在程序开始时, 把 head 指针初始化为 NULL. 然后, 程序可以使
        用 head 的值进行判断:
        #+begin_src c
          if (head == NULL)
          {
            head = current;
          }
          else
          {
            prev->next = current;
          }
        #+end_src

        指针 prev 指向上一次分配的结构.
        
        接下来, 必须为结构成员设置合理的值. 尤其是: 把 next 成员设置为 NULL, 表
        明当前结构是链表的最后一个结构. 还要把 input 数组中的电影名拷贝到 title
        成员中, 而且要给 rating 成员赋值:
        #+begin_src c
          current->next = NULL;
          strcpy(current->title, input);
          puts("Enter your rating <0-10>:");
          scanf("%d", &current->rating);
        #+end_src

        由于 ~s_gets()~ 限制了只能输入 ~TSIZE-1~ 个字符, 所以用 ~strcpy()~ 函数
        把 input 数组中的字符串拷贝到 title 成员很安全

        最后, 要为下一次输入做好准备. 尤其要设置 prev 指向当前结构. 因为在用户输
        入下一步电影且成员为新结构分配空间后, 当前结构将成为新结构的上一个结构,
        所以程序在循环末尾这样设置指针:
        #+begin_src c
          prev = current;
        #+end_src
        
     3. 释放链表
        在许多环境中, 程序结束时都会自动释放 ~malloc()~ 分配的内存. 但是, 最好还
        是成对调用 ~malloc()~ 和 ~free()~. 因此, 程序在清理内存时为每个已分配的
        结构都调用了 ~free()~ 函数:
        #+begin_src c
          current = head;

          while (current != NULL) {
            current = head;
            head = current->next;
            free(current);
          }
        #+end_src

        
**** 反思
     ~film2.c~ 程序还有些不足. eg: 程序没有检查 ~malloc()~ 是否成功请求到内存,
     也无法删除链表中的项. 这些不足可以弥补. eg: 添加代码检查 ~malloc()~ 的返回
     值是否是 ~NULL~ (返回 NULL 说明未获得所需内存). 如果程序要删除链表 中的项,
     还要编写更多的代码.

     这种用 *特定方法解决特定问题*, 并且在需要时才添加相关功能的变成方式通常不是
     最好的解决方案. 另一方面, 通常都无法预料程序要完成的所有任务. 随着编程项目
     越来越大, 一个程序员或编程团队事先计划好一切模式, 越来越不现实. 很多成功的
     大型程序都是由成功的小型程序逐步发展而来.

     如果要修改程序, 首先应该强调最初的设计, 并简化其他细节. ~film2.c~ 中的程序
     示例没有遵循这个原则, 它把概念模型和代码细节混在一起. eg: 该程序的概念模型
     是在一个链表中添加项, 但是程序却把一些细节(eg: ~malloc()~ 和
     ~current->next~ 指针)放在 *最明显* 的位置, 没有 *突出接口*. 如果程序能以某
     种方式强调给链表添加项, 并隐藏具体的处理细节(如调用内存管理函数和设置指针)
     会更好. 把 *用户接口和代码细节分开的程序, 更容易理解和更新*.
** 抽象数据类型(ADT)
   在编程时, 应该根据编程问题匹配合适的数据类型. eg: 用 ~int~ 类型代表你有多少双
   鞋, 用 ~float~ 或 ~double~ 类型代表每双鞋的价格. 在前面的电影示例中, 数据构成
   了链表, 每个链表项由电影名 (C 字符串) 和评级 (一个 int 类型的值). C 中没有与
   之匹配的基本类型, 所以我们定义了一个结构代表单独的项, 然后设计了一些方法把一
   系列结构构成一个链表. 本质上, 我们使用 C 语言的功能设计了一种符合程序要求的新
   数据类型. 但是并 *不系统*. 现在, 我们用更系统的方法来定义数据类型

   *注意*: 整数属性

   C 的 ~int~ 类型背后是一个更抽象的整数概念. 数学家已经用正式的抽象方式定义了整
   数的属性. eg: N 和 M 是整数, 那么 ~N+M=M+N~; 假设 S, Q 也是整数, 如果
   ~N+M=S~, 而且 ~N+Q=S~, 那么 ~M=Q~. 可以认为数学家提供了整数的抽象概念, 而 C
   则实现了这一抽象概念. *注意*: 实现整数的算术运算是表示整数必不可少的部分. 如
   果只是储存值, 并未在算术表达式中使用, ~int~ 类型就没那么有用了. 还要注意的是,
   C 并未很好地实现整数. eg: 整数是无穷大的数, 但是 2 字节的 int 类型只能表示
   65536 个整数. 因此, *不要混淆抽象概念和具体的实现*

   假设要定义一个新的数据类型. 首先, 必须提供储存数据的方法, eg: 设计一个结构.
   其次, 必须提供操控数据的方法. eg: 考虑 ~films2.c~ 程序. 该程序用链接的结构来
   储存信息, 并且通过代码实现了如何添加和显示信息. 尽管如此, 该程序并未清楚地表
   明正在创建一个新类型. 做法:

   计算机科学领域已开发了一种定义新类型的好方法, 用 3 个步骤完成从抽象到具体的
   过程:

   1. 提供类型属性和相关操作的抽象描述. 这些描述既不能依赖特定的实现, 也不能依赖
      特定的编程语言. 这种正式的抽象描述被称为抽象数据类型(ADT)

   2. 开发一个实现 ADT 的编程接口. 也就是说, 指名如何储存数据和执行所需操作的函
      数. eg: 在 C 中, 可以提供结构定义和操控该结构的函数原型. 这些作用于用户定
      义类型的函数相当于作用与 C 基本类型的内置运算符. 需要使用该新类型的程序员
      可以使用这个接口进行编程

   3. 编写代码实现接口. 这一步至关重要, 但是使用该新类型的程序员无需了解具体的实
      现细节.

*** 建立抽象
    从根本上看, 电影项目所需的是一个项链表. 每一项包含电影名和评级. 所需的操作是
    把新项添加到链表的末尾和显示链表中的内容. 我们把需要处理这些需求的抽象类型叫
    做链表. 链表具有哪些属性? 首先, 链表应该能储存一系列的项. 也就是说, 链表能储
    存多个项, 而且这些项以某种方式排列, 这样才能描述链表的第 1 项, 第 2 项或最后
    一项. 其次, 链表类型应该提供一些操作, 如在链表中添加新项. 链表的一些有用的操
    作:
    #+begin_example
      初始化一个空链表;
      在链表末尾添加一个新项;
      确定链表是否为空;
      确定链表是否已满;
      确定链表中的项数;
      访问链表中的每一项执行某些操作, 如显示该项;
      移除链表中的一个项;
      在链表中检索一个项(不改变链表);
      用另一个项替换链表中的一个项;
      在链表中搜索一个项;
    #+end_example

    非正式但抽象的链表定义是: 链表是一个能储存一系列项且可以对其进行所需操作的数
    据对象. 该定义既未说明链表中可以储存什么项, 也未指定是用数组, 结构还是其他数
    据形式来储存项, 而且并未规定用什么方法来实现操作(eg: 查找链表中元素的个数).
    这些细节都留给实现完成.

    为了让示例尽量简单, 我们采用一种简化的链表作为抽象数据类型. 它质保函电影项目
    中的所需属性. 该类型总结如下:
    #+begin_example
      类型名: 简单链表
      类型属性: 可以储存一系列项
      类型操作: 初始化链表为空
      确定链表为空
      确定链表已满
      确定链表中的项数
      在链表末尾添加项
      遍历链表, 处理链表中的项
      清空链表
    #+end_example

    下一步是为开发简单链表 ADT 开发一个 C 接口

*** 建立接口
    这个简单链表的接口有 2 个部分. 第一部分是描述如何表示数据, 第二部分是描述实
    现 ADT 操作的函数. eg: 要设计在链表中添加项的函数和报告链表中项数的函数. 接
    口设计应尽量与 ADT 的描述保持一致. 因此, 应该用 某种通用的 Item 类型而不是一
    些特殊类型, eg: ~int~ 或 ~struct film~. 可以用 C 的 ~typedef~ 功能来定义所需
    的 Item 类型:
    #+begin_src c
      #define TSIZE 45
      struct film
      {
        char title[TSIZE];
        int rating;
      };

      typedef struct film Item;
    #+end_src

    然后, 就可以在定义的其余部分使用 Item 类型. 如果以后需要其他数据形式的链表,
    可以重新定义 Item 类型, 不必更改其余的接口定义.

    定义了 Item 之后, 现在必须确定如何储存这种类型的项. 实际上这一步属于实现步骤,
    但是现在决定好可以让示例更简单些. 在 ~films2.c~ 程序中用链接的接口处理得很好,
    所以, 我们在这里也采用相同的方法:
    #+begin_src c
      typedef struct node
      {
        Item item;
        struct node* next;
      } Node;
      typedef Node* List;
    #+end_src

    在链表的实现中, 每一个链节叫做节点(node). 每个节点包含形式链表内容的信息和指
    向下一个节点的指针. 为了强调这个术语, 我们把 node 作为节点结构的标记名, 并使
    用 ~typedef~ 把 ~Node~ 作为 ~struct node~ 结构的类型名. 最后, 为了管理链表,
    还需要一个指向链表开始处的指针, 我们使用 ~typedef~ 把 ~List~ 作为该类型的指
    针名. 因此, 下面的声明:
    #+begin_src c
      List movies;
    #+end_src
    创建了该链表所需类型的指针 ~movies~
    这不是定义 ~List~ 类型的唯一方法, eg: 额外添加一个变量记录项数:
    #+begin_src c
      typedef struct list
      {
        Node* head; // 指向链表头的指针
        int size; // 链表中的项数
      } List; // List 的另一种定义
    #+end_src

    可以像稍后的程序示例中那样, 添加第二个指针储存链表的末尾. 现在, 我们还是使用
    ~List~ 类型的第一种定义. 这里要着重理解下面的声明创建了一个链表, 而不是指向
    节点的指针或一个结构:
    #+begin_src c
      List movies;
    #+end_src
    
    ~movies~ 代表的确切数据应该是接口层次不可见的实现细节.

    eg: 程序 *启动后应该把头指针初始化为 ~NULL~.*. 但是, 不要使用下面这样的代码:
    #+begin_src c
      movies = NULL;
    #+end_src

    ~List~ 类型的结构实现更好, 应该这样初始化:
    #+begin_src c
      movies.next = NULL;
      movies.size = 0;
    #+end_src

    使用 ~List~ 的人都不用担心这些细节, 只要能使用下面的代码就行:
    #+begin_src c
      InitializeList(movies);
    #+end_src
    
    使用该类型的程序员只需知道用 ~InitializeList()~ 函数来初始化链表, 不必了解
    ~List~ 类型变量的实现细节. 这是数据隐藏的一个示例, 数据隐藏是以中国从编程的
    更高层次隐藏数据表示细节的艺术.

    为了指导用户使用, 可以在函数原型前面提供以下注释:
    #+begin_src c
      /* 操作: 初始化一个链表 */
      /* 前提条件: plist 指向一个链表 */
      /* 后置条件: 该链表初始化为空 */
      void InitializeList(List* plist);
    #+end_src

    这里需要注意 3 点:
    1. 注释中的 "前提条件"(precondition) 是调用该函数前应具备的条件.
       eg: 需要一个待初始化的链表.
    2. 注释中的 "后置条件"(postcondition) 是执行完该函数后的情况
    3. 该函数的参数是一个指向链表的指针, 而不是一个链表. 所以应该这样调用该函数:
       #+begin_src c
         InitializeList(&movies);
       #+end_src
       C 语言把所有类型和函数的信息集合成一个软件包的方法是: 把类型定义和函数原
       型(包括前期条件和后置条件注释) 放在一个头文件中. 该文件应该提供程序员使用
       该类型所需的所有信息. ~list.h~ 给出了一个简单链表类型的头文件. 该程序定义
       了一个特定的结构作为 Item 类型, 然后根据 Item 定义了 ~Node~, 再根据
       ~Node~ 定义了 ~List~. 然后, 把表示链表操作的函数设计为接受 Item 类型和
       ~List~ 类型的参数. 如果函数要修改一个参数, 那么该参数的类型应是指向相应类
       型的指针, 而不是该类型. 在头文件中, 把组成函数名的单词的首字母大写, 以这
       种方式表明这些函数是接口包的一部分. 另外, 该文件使用前一章介绍的
       ~#ifndef~ 指令, 防止多次包含一个文件

       如果 编译器不支持 C99, 可用以下代码:
       #+begin_src c
         enum bool { false, true }; // 把 bool 定义为类型, false 和 true 是该类型的值
       #+end_src

       替换下面的头文件:
       #+begin_src c
         #include <stdbool.h>
       #+end_src
       
       只有 ~InitializeList()~, ~AddItem()~ 和 ~EmptyTheList()~ 函数要修改链表,
       因此从技术角度看, 这些函数需要一个指针函数. 然而, 如果偶写函数接受 ~List~
       类型的变量作为参数, 而其他函数却接受 ~List~ 类型的地址作为参数, 用户会很
       迷惑. 因此, 为了减轻用户的负担, 所有的函数均使用指针参数.

       头文件的一个函数原型比其他原型复杂:
       #+begin_src c
         /* 操作: 把函数作用域链表中的每一项 */
         /* plist 指向一个已初始化的链表 */
         /* pfun 指向一个函数, 该函数接受一个 Item 类型的参数, 且无返回值 */
         /* 后置条件: pfun 指向的函数作用域链表中的每一项一次 */
         void Traverse(const List* plist, void(*pfun)(Item item));
       #+end_src
       
       参数 pfun 是一个指向函数的指针, 它指向的函数接受 item 值且无返回值. 第 14
       章中介绍过, 可以把函数指针作为参数传递给另一个函数, 然后该函数就可以使用
       这个被指针指向的函数. eg: 该例中可以让 pfun 指向显示链表项的函数, 然后把
       ~Traverse()~ 函数把该函数作用于链表中的每一项, 显示链表中的内容.

*** 使用接口
    我们的模板是: 使用这个接口编写程序, 但是不必知道具体的实现细节(eg: 不知道函
    数的实现细节). 在编写具体函数之前, 我们先编写电影程序的一个新版本. 由于接口
    要使用 ~List~ 和 Item 类型, 所以该程序也应使用这些类型. 下面是编写该程序的一
    个伪代码方案.

    #+begin_example
      创建一个 List 类型的变量
      创建一个 Item 类型的变量
      初始化链表为空
      当链表未满且有输入时
      把输入读取到 Item 类型的变量中
      在链表末尾添加新项
      访问链表中的每个项并显示它们
    #+end_example

    ~fimls3.c~ 程序按照以上伪代码来表写, 其中还加入了一些错误检查, 注意该程序使
    用了 ~list.h~ 中描述的接口. 另外, 还需注意, 链表中含有 ~showmovies()~ 函数的
    代码, 它与 ~Traverse()~ 的原型一致. 因此, 程序可以把指针 ~showmovies~ 传递给
    ~Traverse()~, 这样 ~Traverse()~ 可以把 ~showmovies()~ 函数应用于链表中的每一
    项

*** 实现接口
    我们还是必须实现 ~List~ 接口. C 方法是把函数定义统一放在 ~list.c~ 文件中. 然
    后, 整个程序由 ~list.h~ (定义数据结构和提供用户接口的原型), ~list.c~ (提供函
    数代码实现接口) 和 ~films3.c~ (把链表接口应用于特定编程问题的源代码文件) 组
    成. ~list.c~ 演示了一种实现. 要运行该程序, 必须把 ~films3.c~ 和 ~list.c~ 一
    起编译和链接(第九章). ~list.h~, ~list.c~ 和 ~films3.c~ 组成了整个程序

    1. 程序的一些注释
       ~list.c~ 文件有几个需要注意的地方. 首先, 该文件演示了什么情况下使用内部链
       接函数, 如第 12 章所述, 具有内部链接的函数只能在其声明所在的文件夹可见.
       在实现接口时, 有时编写一个辅助函数(不作为正式接口的一部分)很方便. eg: 使
       用 ~CopyToNode()~ 函数把一个 Item 类型的值拷贝到 Item 类型的变量中. 由于
       该函数是实现的一部分, *但不是接口的一部分*, 所以我们使用 ~static~ 存储类
       别说明符把它隐藏在 ~list.c~ 文件中.

       ~InitializeList()~ 函数将链表初始化为空. 在我们的实现中, 这这意味着把
       ~List~ 类型的变量设置为 ~NULL~. 这要求把指向 ~List~ 类型变量的指针传递给
       函数.

       ~ListIsEmpty()~ 函数前期条件是当链表为空是, 链表变量被设置为 ~NULL~. 因此,
       在首次调用 ~ListIsEmpty()~ 函数之前初始化链表非常重要. 另外, 如果要扩展接
       口添加删除项的功能, 那么当最后一个项被删除时, 应该确保该删除函数重置链表
       为空. 对链表而言, 链表的大小取决于可用的内存量. ~ListIsFull()~ 函数尝试为
       新项分配空间. 入股哦分配事变, 说明链表已满; 如果分配成功, 则必须释放刚才
       分配的内存供真正的项调用.

       ~ListItemCount()~ 函数使用常用的链表算法遍历链表, 同时统计链表中的项.

       ~AddItem()~ 函数首先为新节点分配空间. 如果分配成功, 则使用 ~CopyToNode()~
       把项拷贝到新节点中. 然后把该节点的 next 成员设置为 ~NULL~. 这表明该节点是
       链表中的最后一个节点. 最后, 完成创建节点并为其成员赋正确的值之后, 该函数
       把该节点添加到链表的末尾. 如果该项是添加到链表的第一个项, 需要把头指针设
       置为指向第一项(记住: 头指针的地址是传递给 ~AddItem()~ 函数的第二个参数,
       所以 ~*plist~ 就是头指针的值). 否则, 代码继续在链表中前进, 知道发现被设置
       为 ~NULL~ 的 next 成员. 此时, 该节点就是当前的最后一个节点, 所以, 函数重
       置它的 next 成员指向新节点

       要养成良好的编程习惯, 给链表添加项之前应调用 ~ListIsFull()~ 函数. 但是,
       用户可能并未这样做, 所以在 ~AddItem()~ 函数内部检查 ~malloc()~ 是否分配成
       功. 而且, 用户还可能在调用 ~ListIsFull()~ 和调用 ~AddItem()~ 函数之间做其
       他事情分配了内存, 所以最好还是检查 ~malloc()~ 是否分配成功.

       ~Traverse()~ 函数与 ~ListItemCount()~ 函数类似, 不过它还把一个指针函数作
       用链表中的每一项.

       该函数的实现通过把 ~List~ 类型的变量设置为 ~NULL~ 来表明一个空链表. 因此,
       要把 ~List~ 类型变量的地址传递给该函数, 以便函数重置. 由于 ~List~ 已经是
       一个指针, 所以 plist 是一个指向指针的指针. 因此, 在上面的代码中, ~*plist~
       是指向 ~Node~ 的指针. 当到达链表末尾时, ~*plist~ 的值为 ~NULL~, 表明原始
       的实际参数现在被设置为 ~NULL~

       *提示*: ~const~ 的限制:
       尽管限制了 ~const List* plist~ 作为形参, 表明不会更改链表. 限制了如下做
       法:
       #+begin_src c
         *plist = (*plist)->next; // 如果 *plist 是 const, 不允许这样做
       #+end_src

       但是, 可以进行如下操作:
       #+begin_src c
         (*plist)->item.rating = 3; // 即使 *plist 是 const, 也可以这样做
       #+end_src

       因为上面代码并未改变 ~*plist~, 改变的是指向的数据. 因此, 不要指望 ~const~
       能捕获到意外修改数据的程序错误

       *总结*: ADT 版本可读性更高, 而且针对的是最终的用户所关心的问题, 其次,
       ~list.h~ 和 ~list.c~ 文件一起组成了可复用的资源. 如果需要另一个简单的链表,
       也可以使用这些文件. 要在 ~list.h~ 文件中重新定义 Item类型, 有时还需要重新
       定义 ~CopyToNode()~ 函数(eg: 当项是数组时, 就不能通过赋值来拷贝). 当然,
       还要根据新的定义重写处理链表的函数, 但是不用修改业务代码中的内容. 对大型
       编程项目而言, 这种把实现和最终接口隔离的做法相当有用. 这称为数据隐藏, 因
       为对终端用户隐藏了数据表示的细节. 

       如果程序运行出现问题, 可以把问题定位到具体函数上. 如果想用更好的方法来完
       成某个人物(eg: 添加项), 只需重写相应的函数即可. 如果需要新功能, 可以添加
       一个新的函数. 如果觉得双向链表更好, 可以重写实现的代码, 不用修改使用实现
       的程序.


** 队列ADT
   在 C 语言中使用抽象数据类型方法编程包含以下 3 个步骤:
   1. 以抽象, 通用的方式描述一个类型, 包括该类型的操作
   2. 设计一个函数接口表示这个新类型
   3. 编写具体代码实现这个接口

   前面已经把这种方法应用到简单链表中. 现在, 把这种方法应用于更复杂的数据类型:
   队列.   

*** 定义队列抽象数据类型
    *队列(queue)是具有两个特殊属性的链表*: 第一: 新项只能添加到链表的末尾. 从这
     方面看, 队列与简单链表类型. 第二, 只能从链表的开头移除项. 可以把队列想象成
     排队买票的人. 你从队尾加入队列, 买完票后从对首离开. 队列是一种 *先进先出*
     (first in, first out, 缩写为 FIFO) 的数据形式, 就像在排队买票的队伍一样(前
     提是没有人插队). 接下来, 建立一个非正式的抽象定义:
     
     #+begin_example
       类型名: 队列
       类型属性: 可以储存一系列项
       类型操作: 初始化队列为空
       确定队列为空
       确定队列已满
       确定队列中的项数
       在队列末尾添加项
       在队列开头删除或恢复项
       清空队列
     #+end_example

*** 定义一个接口
    接口定义放在 ~queue.h~ 文件中. 我们使用 C 的 ~typedef~ 工具创建两个类型名:
    Item 和 Queue. 相应结构的具体实现应该是 ~queue.h~ 文件的一部分, 但是从概念上
    来看, 应该在实现阶段才设计结构. 现在, 只是假定已经定义了这些类型, 着重考虑函
    数的原型.

    首先, 考虑初始化. 这涉及改变 Queue 类型, 所以该函数应该以 Queue 的地址作为参
    数: 
    #+begin_src c
      void InitializeQueue(Queue* pq);
    #+end_src

    接下来, 确定队列是否为空或已满的函数应返回真或假值. 这里, 假设 C99 的
    ~stdbool.h~ 头文件可用, 如果该文件不可用, 可以使用 ~int~ 类型或自己定义
    ~bool~ 类型. 由于该函数不更改队列, 所以接受 Queue 类型的参数. 但是, 传递
    Queue 的地址更快, 更节省内存. 这样做的好处是: 所有的函数都以地址作为参数. 为
    了表明这些函数不更改队列, 可以且应该使用 ~const~ 限定符:
    #+begin_src c
      bool QueueIsFull(const Queue* pq);
      bool QueueIsEmpty(const Queue* pq);
    #+end_src

    指针 pq 指向 Queue 数据对象, 不能通过 pq 这个代理更改数据. 可以定义一个类似
    该函数的原型, 返回队列的项数:
    #+begin_src c
      int QueueItemCount(const Queue* pq);
    #+end_src

    在队列末尾添加项设计标识项和队列. 这次要更改队列, 所以有必要(而不是可选)使用
    指针. 该函数的返回类型可以是 ~void~, 或者通过返回值来表示是否成功添加项. 我
    们采用后者:
    #+begin_src c
      bool EnQueue(Item item, Queue* pq);
    #+end_src
    最后, 删除项有多种方法. 如果把该项定义为结构或一种基本类型, 可以通过函数返回
    待删除的项. 函数的参数可以是 Queue 类型或指向 Queue 的指针. 因此, 可以是下面
    这样的原型:
    #+begin_src c
      Item DeQueue(Queue q);
    #+end_src

    然而, 下面的原型会更合适一些:
    #+begin_src c
      bool DeQueue(Item* pitem, Queue* pq);
    #+end_src

    从队列中待删除的项储存在 pitem 指针指向的位置, 函数的返回值表明是否删除成功

    清空队列的函数所需的唯一参数是队列的地址, 可以使用下面的函数原型:
    #+begin_src c
      void EmptyTheQueue(Queue* pq);
    #+end_src

    
*** 实现接口数据表示
    第一步是确定在队列中使用何种 C 数据形式. 有可能是数组. 数组的优点是方便使用,
    而且向数组的末尾添加项很简单. 问题是如果从队列的开头删除项. 类比于排队买票的
    队列, 从队列的开头删除一个项包括拷贝数组首元素的值和把数组剩余各项依次向前移
    动一个位置. 编程实现这个过程很简单, 但是会浪费大量的计算机时间.

    第二种解决数组队列删除问题的方法是改变队列首端的位置, 其余元素不动.

    解决这种问题的一个好方法是, 使队列成为环形, 这意味着把数组的首尾相连, 即数组
    的首元素紧跟在最后一个元素后面. 这样, 当到达数组末尾时, 如果首元素空出, 就可
    以把新添加的项储存到这些空出的元素中. 可以想象在一张条形的纸上画出数组, 然后
    把数组的末尾首尾粘起来形成一个环. 当然, 要做一些标记, 以免尾端超过首端.

    另一种方法是使用链表. 使用链表的好处是删除首项时不必移动其余元素, 只需重置头
    指针指向新的首元素即可. 由于我们已经讨论过链表, 所以采用这个方法. 我们用一个
    整数队列开始测试:
    #+begin_src c
      typedef int Item;
    #+end_src

    链表由节点组成, 所以, 下一步是定义节点:
    #+begin_src c
      typedef struct node
      {
        Item item;
        struct node* next;
      } Node;
    #+end_src

    对队列而言, 要保存首尾项, 这可以使用指针来完成. 另外, 可以用一个计数器来记录
    队列中的项数. 因此, 该结构应由两个指针成员和一个 int 类型的成员构成:
    #+begin_src c
       typedef struct queue
       {
         Node* front; // 指向队列首项的指针
         Node* rear; // 指向队列尾项的指针
         int items; // 队列中的项数
       } Queue;
    #+end_src

    注意: Queue 是一个内含 3 个成员的结构, 所以用指向队列的指针作为参数比直接用
    队列作为参数节约了时间和空间

    接下来, 考虑队列的大小. 对链表而言, 其大小受限于可用的内存量, 因此链表不要太
    大. eg: 可能使用一个队列模拟飞机等待在机场着陆. 如果等待的飞机数量太多, 新到
    的飞机就应该改到其他的机场降落. 我们把队列的最大程度设为 10. ~queue.h~ 包含
    了队列接口的原型和定义. Item 类型留给用户定义. 使用该接口时, 可以根据特定的
    程序插入合适的定义.

**** 实现接口函数
     接下来, 我们编写接口代码. 首先, 初始化队列为空, 这里 "空" 的意思是指把指向
     队列的首项和尾项的指针设置为 ~NULL~, 并把项数(items 成员) 设置为 0:
     #+begin_src c
       void InitializeQueue(Queue* pq)
       {
         pq->front = pq->rear = NULL;
         pq->items = 0;
       }
     #+end_src

     这样, 通过检查 items 的值可以很方便地了解队列是否已满, 是否为空和确定队列的
     项数:
     #+begin_src c
       bool QueueIsFull(const Queue* pq)
       {
         return pq->items == MAXQUEUE;
       }

       bool QueueIsEmpty(const Queue* pq)
       {
         return pq->items == 0;
       }

       int QueueItemCount(const Queue* pq)
       {
         return pq->items;
       }
     #+end_src

     把项添加到队列中, 包括以下几个步骤:
     1. 创建一个新节点
     2. 把项拷贝到节点中
     3. 设置节点的 next 指针为 ~NULL~, 表明该节点是最后一个节点
     4. 设置当前尾节点的 next 指针指向新节点, 把新节点链接到队列中
     5. 把 rear 指针指向该节点, 以便找到最后的节点
     6. 项数加 1

        
     函数还要处理 2 种特殊情况. 第一种情况: 如果队列为空, 应该把 front 指针设置
     为指向新节点. 因为如果队列中只有一个节点, 那么这个节点既是首节点也是尾节点.
     第二种情况是: 如果函数不能为新节点分配所需的内存, 则必须执行一些动作. 因为
     大多数情况下我们都使用小型队列, 这种情况很少发生, 所以, 如果程序运行的内存
     不足, 我们只是通过函数终止程序.

     ~EnQueue()~ 的代码如下:
     #+begin_src c
       bool EnQueue(Item item, Queue* pq)
       {
         Node* pnew;
         if (QueueIsFull(pq))
           return false;

         pnew = (Node*)malloc(sizeof(Node));

         if (pnew == NULL)
         {
           fprintf(stderr, "Unable to allocate memory!\n");
           exit(1);
         }

         CopyToNode(item, pnew);

         pnew->next = NULL;

         if (QueueIsEmpty(pq))
           pq->front = pnew; // 项位于首列顶端
         else
           pq->rear->next = pnew; // 记录队列尾端的位置
         pq->items++; // 队列项数加 1

         return true;
       }
     #+end_src

     ~CopyToNode()~ 函数是静态函数, 用于把项拷贝到节点中:
     #+begin_src c
       static void CopyToNode(Item item, Node* pn)
       {
         pn->item = item;
       }
     #+end_src

     从队列的首端删除项, 涉及以下几个步骤:
     #+begin_src c
       bool DeQueue(Item* pitem, Queue* pq)
       {
         Node* pt;

         if (QueueIsEmpty(pq))
           return false;

         CopyToItem(pq->front, pitem);

         pt = pq->front;
         pq->front = pq->front->next;
         free(pt);

         pq->items--;

         if (pq->items == 0)
           pq->rear = NULL;
         return false;
       }
     #+end_src

     关于指针要注意两点. 第一, 删除最后一项时, 代码并未显示设置 front 指针为
     ~NULL~, 因为已经设置 ~front~ 指针指向被删除节点的 next 指针就为 ~NULL~. 第
     二, 代码使用临时指针(pt) 储存待删除节点的位置. 因为指向首节点的正式指针, 程
     序就不知道该释放哪块内存.

     我们使用 ~DeQueue()~ 函数清空队列. 循环调用 ~DeQueue()~ 函数直到队列为空: 
     #+begin_src c
       void EmptyTheQueue(Queue* pq)
       {
         Item dummy;
         while (!QueueIsEmpty(pq))
           DeQueue(&dummy. pq);
       }
     #+end_src

     注意: *保持纯正* 的 ADT

     定义 ADT 接口后, 应该只使用用接口函数处理数据类型. eg: ~Dequeue()~ 依赖
     ~EnQueue()~ 函数来正确设置指针和把 ~rear~ 节点的 ~next~ 指针设置为 ~NULL~.
     如果在一个使用 ADT 的程序中, 决定直接操控队列的某些部分, 有可能破坏接口包中
     函数直接的协作关系.

     ~queue.c~ 演示了该接口中的所有函数, 包括 ~EnQueue()~ 函数中用到的
     ~CopyToItem()~ 函数

*** 测试队列
    在重要的程序中使用一个新的设计(eg: 队列包)之前, 应该先测试该设计. 测试的一种
    方法是, 编写一个小程序. 这样的程序称为 *驱动程序(driver)*, 其唯一的用途是进
    行测试. eg: ~use_q.c~ 使用一个添加和删除整数的队列. 在运行该程序之前, 要确保
    ~queue.h~ 中包含下面这行代码:
    #+begin_src c
      typedef int item;
    #+end_src

    *注意*: *必须连接* ~queue.c~ 和 ~use_q.c~
** 用队列进行模拟
   经过测试, 队列没问题. 现在, 我们用它来做一些有趣的事情. 许多现实升华的情形都
   设计队列. eg: 在银行或超市的顾客队列, 机场的飞机队列, 多任务计算机系统中的任
   务队列等. 我们可以用队列包来模拟这些情形.

   假设 Sigmund Landers 在商业街设置了一个提供建议的摊位. 顾客可以购买 1分钟, 2
   分钟或 3分钟的建议. 为确保交通畅通, 商业街规定每个摊位前排队等待的顾客最多为
   10 人(相当于程序中的最大队列长度). 假设顾客都是随机出现的, 并且他们花在咨询上
   的时间也是随机选择的(1 分钟, 2 分钟, 3 分钟). 那么 Sigmund 平均每小时要接待多
   少名顾客? 每位顾客平均要花多长时间? 排队等待的顾客平均有多少人? 队列模拟能回
   答类似的问题.

   首先, 要确定在队列中放什么. 可以根据顾客加入队列的事件和顾客咨询时花费的事件
   来描述每一位顾客. 因此, 可以这样定义 Item 类型:
   #+begin_src c
     typedef struct item
     {
       long arrive; // 一位顾客加入队列的事件
       int processtime; // 该顾客咨询时花费的时间
     } Item;
   #+end_src

   要用队列包来处理这个结构, 必须用 ~typedef~ 定义的 Item 替换上一个示例的 int
   类型. 这样做就不必担心队列的具体工作机制, 可以集中精力分析实际问题, 即模拟咨
   询 Sigmund 的顾客队列.

   这里有一种方法, 让时间以 1 分钟为单位递增. 每递增一分钟, 就检查是否有新顾客到
   来. 如果有一位顾客且队列未满, 将该顾客添加到队列中. 这涉及把顾客到来的事件和
   顾客所需的咨询时间记录在 Item 类型的结构中, 然后在队列中添加该项. 然而, 如果
   队列已满, 就让这位顾客离开. 为了做统计, 要记录顾客的总数和被拒顾客(队列已满不
   能加入队列的人)的总数.

   接下来, 处理队列的首端. 也就是说, 如果队列不为空且前面的顾客没有在咨询
   Sigmund, 则删除队列首端的项. 记住, 该项中储存着这位顾客加入队列的时间, 把该时
   间与当前时间作比较, 就可得出该顾客在队列中等待的时间. 该项还存储着这位顾客需
   要咨询的分钟数, 即还要咨询 Sigmund 多长时间, 因此要需要一个变量储存这个时长.
   如果 Sigmund 正忙, 则不用让任何人离开队列. 尽管如此, 记录等待时间的变量应该递
   减 1.

   核心代码类似如下, 每一轮迭代对应一分钟的行为:
   #+begin_src c
     for (cycle = 0; cycle < cyclelimit; cycle++)
     {
       if (newcustomer(min_per_cus))
       {
         if (QueueIsFull(&line))
           turnaways++;
         else {
           customers++;
           temp = customertime(cycle);
           EnQueue(temp, &line);
         }
       }

       if (wait_time <= 0 && !QueueIsEmpty(&line))
       {
         DeQueue(&temp, &line);
         wait_time = temp.processtime;
         line_wait += cycle - temp.arrive;
         served++;
       }

       if (wait_time > 0)
         wait_time--;

       sum_line +=QueueItemCount(&line);
     }
   #+end_src

   *注意*: 时间的表示比较粗糙(1 分钟), 所以一小时最多 60 位顾客. 下面是一些变量
    和函数的含义. 
    
    - min_per_cus: 顾客到达的平均间隔时间
    - ~newcustomer()~: 使用 C 的 ~rand()~ 函数确定在特定时间内是否有顾客到来
    - turnaways: 被拒绝的顾客数量
    - customers: 加入队列的顾客数量
    - temp: 新顾客的 Item 类型变量
    - ~customertime()~: 设置 temp 结构中的 arrive 和 processtime 成员
    - wait_time: Sigmund 完成当前顾客的咨询还需多长时间
    - line_wait: 到目前为止队列中所有顾客的等待总时间
    - served: 咨询过 Sigmund 的顾客数量
    - sum_line: 到目前为止统计的队列长度

      
    如果到处都是 ~malloc()~, ~free()~ 和指向节点的指针, 整个程序代码会非常混乱和
    晦涩. 队列包让你把注意力集中在模拟问题上, 而不是编程细节上.

    ~mall.c~ 演示了 模拟商业街咨询摊位队列的完整代码. 根据第 12 章介绍的方法, 使
    用标准函数 ~rand()~, ~srand()~, 和 ~time()~ 来产生随机数. 另外要特别注意, 必
    须用下面的代码更新 ~queue.h~ 中的 Item, 该程序才能正常工作:
    #+begin_src c
      typedef struct item
      {
        long arrive; // 一位顾客加入队列的时间
        int processtime; // 该顾客咨询时花费的事件
      } Item;
    #+end_src

    记住, 还要把 ~mall.c~ 和 ~queue.c~ 一起链接

    该程序允许用户指定模拟允许的小时数和每小时平均有多少位顾客. 模拟时间较长得出
    的值较为平均, 模拟时间较短得出的值随时间的变化而随机变化. 下面的运行示例解释
    了这一点(先保持每小时的顾客平均数量不变). *注意*: 在模拟 80 小时和 800 小时
    的情况下, 平均队伍长度和等待时间基本相同, 但是, 在模拟一小时的情况下这两个量
    差别很大, 而且与长时间模拟的情况差别也很大. 这是因为小数量的统计样本更容易受
    相对变化的影响.

    *注意*: 随着每小时顾客的平均数量增加, 顾客的平均等待时间迅速增加. 在每小时
     20 位顾客(80 小时模拟时间)的情况下, 每位顾客的平均等待时间是 1.35 分钟; 在
     每小时 25 位顾客的情况下, 平均等待时间增加至 3.50 分钟; 在每小时 30 位顾客
     的情况下, 该数值攀升至 11.83 分钟. 而且, 这三种情况下被拒顾客分别从 0 位增
     加至 3 位最后徒增至 94 位. Sigmund 可以根据程序模拟的结果决定是否要增加一个
     摊位.
** 链表和数组
   许多编程问题, 如创建一个简单链表或队列, 都可以用链表(指的是动态分配结构的序列
   链)或数组来处理. 每种形式都有其优缺点, 所以要根据具体问题的要求来决定选择哪一
   种形式. 下表总结了链表和数组的性质:
   | 数据形式 | 优点                               | 缺点                                   |
   |----------+------------------------------------+----------------------------------------|
   | 数组     | C直接支持, 提供随机访问            | 在编译时确定大小, 插入和删除元素很费时 |
   | 链表     | 运行时确定大小, 快速插入和删除元素 | 不能随机访问, 用户必须提供编程支持     |

   详细分析插入和删除元素的过程: 在数组中插入元素, *必须* 移动其他元素腾出空位插
   入新元素. 新插入的元素离数组开头越近, 要被移动的元素越多. 然而, 在链表中插入
   节点, 只需给 2 个指针复制. 类似地, 从数组中删除一个元素, 也需要移动许多相关的
   元素. 但是从链表中删除节点, 只需重新设置一个指针并释放被删除节点占用的内存即
   可.

   考虑如何访问元素: 对数组而言, 可以使用数组下表直接访问数组中的任意元素, 这叫
   做 *随机访问(random access)*. 对链表而言, 必须从链表首节点开始, 逐个节点移动
   到要访问的节点, 这叫做 *顺序访问(sequential access)*. 当然, 也可以顺序访问数
   组. 只需按顺序递增数组下标即可. 在某些情况下, 顺序访问足够了. eg: 要显示链表
   中的每一项, 顺序访问就不错. 其他情况用随机访问更合适.

   假设要查找链表中的特定项. 一种算法是从列表的开头开始按顺序查找, 这叫做 *顺序
   查找(sequential search)*. 如果项并未按某种顺序排列, 则只能顺序查找. 如果待查
   找的项不在链表里, 必须查找完所有的项才知道该项不在链表中(在这种情况下可以使用
   并发编程, 同时查找列表中的不同部分).

   我们可以先排序列表, 以改进顺序查找. 这样, 就不必查找排在待查找项后面的项. eg:
   假设在一个按字母排序的列表中查找Susan. 从开头开始查找每一项, 知道 Sylvia 都没
   有查找到 Susan. 这时就可以退出查找, 因为如果 Susan 在列表中, 应该排在 Sylvia
   前面. 平均下来, 这种方法查找不在列表中的项的时间减半.

   对于一个排序的列表, 用 *二分查找(binary search)* 比顺序查找好得多. 

   二分查找原理: 首先把待查找的项称为目标项, 而且假设列表中的各项按字母排序. 然
   后, 比较的中间项和目标项. 如果相等, 查找结束; 假设目标项在列表中, 如果中间项
   排在目标项前面, 则目标项一定在后半部分项中; 无论哪种情况, *两项比较的结果都确
   定了下次查找的范围只有列表的一半*. 不断使用此方法, 一般而言, n 次比较能处理有
   2^n - 1 个元素的数组. 所以项数越多, 越能体现二分查找的优势.

   用数组实现二分查找很简单, 因为可以使用数组下标确定数组中任意部分的 *中点*. 只
   要把数组的首元素和尾元素的索引相加,得到的和再除以 2 即可. eg: 内含 100 个元素
   的数组, 首元素下表是 0, 尾元素下表是 99, name用于首次比较的中间项的下表应为
   (0 + 99) / 2, 得 49(整数除法). 这体现了随机访问的特性, 可以从一个位置跳到另
   一个位置, *不用一次访问两位置直接的项*. 但是, 链表 *只支持顺序访问*, 不提供跳
   转至中间节点的方法. 所以在链表中 *不能使用二分查找*.

   如前所述, *选择何种数据类型取决于具体问题*. 如果因频繁地插入和删除项导致经常
   调整大小, 而且不需要经常查找, 选择链表会更好. 如果只是偶尔插入或删除项, 但是
   经常进行查找, 使用数组会更好.

   如果需要一种 *既支持频繁插入和删除项*, *又支持频繁查找* 的数据形式, 数组和链
   表都无法胜任, 这种情况下应该选择 *二叉查找树*.
** 二叉查找树
   二叉查找树是一种结合了二分查找策略的链接结构. 二叉树的每个节点都包含一个项和
   两个指向其他节点(称为子节点)的指针. 二叉树中的每个节点都包含两个子节点 -- 左
   节点和右节点, *其顺序按照如下规定确定*: 左节点的项在父节点的项前面, 右节点的
   项在父节点的项后面. 这种关系存在于每个有子节点的节点中. 进一步而言, 所有可以
   追溯其祖先回到一个父节点的左节点的项, 都在该父节点项的前面. 所有以一个父节点
   的右节点为祖先的项, 都在该父节点项的后面. 有趣的是, 与植物学的树相反, 该树的
   顶部被称为根(root)。 树具有分层组织， 所以以这种方式存储的数据也以等级或层次
   组织, 一般而言, 每级都有上一级和下一级. 如果二叉树是满的, 那么每一级的节点
   都是上一级节点数的两倍.

   
   二叉查找树中的每个节点是其后代节点的根, 该节点与其后代节点构成称了一个子树
   (subtree).

   假设要在二叉树中查找一个项(即目标项). 如果目标项在根节点的前面, 则只需查找左
   子树; 如果目标项在根节点的后面, 则只需查找右子树. 因此, 每次比较就排除半个树,
   假设查找左子树, 这意味着目标项与左子节点项比较. 如果目标项在左子节点项的前面,
   则只需查找其后代节点的左半部分, 以此类推. 与二分查找类似, 每次比较都能排除一
   半的可能匹配项.

   二叉查找树在链式结构中结合了二分查找的效率. 但是, 这样编程的代价是构建一个二
   叉树比创建一个链表更复杂. 下面我们在下一个 ADT 项目中创建一个二叉树.

*** 二叉树ADT
    和前面一样, 先从概括地定义二叉树开始. 该定义假设树不包含相同的项. 许多操作与
    链表相同, 区别在于数据层次的安排. 下面简历一个非正式的树定义:
    
    #+begin_example
      类型名: 二叉查找树
      类型属性: 二叉树要么是空节点的集合(空树), 要么是有一个根节点的节点集合
      每个节点都有 2 个子树, 叫做左子树和右子树
      每个子树本身也是一个二叉树, 也有可能是空树
      二叉查找树是一个有序的二叉树, 每个节点包含一个项

      左子树的所有项都在根节点项的前面, 左子树的所有项都在根节点项的后面

      类型操作: 初始化树为空
      确定树是否为空
      确定树是否已满
      确定树中的项数
      在树中添加一个项
      在树中删除一个项
      在树中查找一个项
      在树中访问一个项
      清空树
    #+end_example

    
*** 二叉查找树接口
    原则上, 可以用多种方法实现二叉查找树, 甚至可以通过操控数组下标用数组来实现.
    但是, 实现二叉查找树最直接的方法是 *通过指针动态分配链式节点*. 因此我们如下
    定义:
    #+begin_src c
      typedef SOMETHING Item;
      typedef struct trnode
      {
        Item item;
        struct trnode* left;
        struct trnode* right;
      } Trn;

      typedef struct tree
      {
        Trnode* root;
        int size;
      } Tree;
    #+end_src

    每个节点包含一个项, 一个纸箱左子节点和一个指向右子节点的指针. 可以把 Tree 定
    义为指向 Trnode 的指针类型, 因为只需要知道根节点的位置就可访问整个树. 然而,
    使用有成员大小的结构能很方便地记录树的大小.

    我们要开发一个维护 Nerfville 宠物俱乐部的花名册, 每一项包含宠物名和宠物的种
    类. ~tree.h~ 就是该花名册的接口. 我们把树的大小限制为 10, 较小的树便于在树已
    满时测试程序的行为是否正确.

    
*** 二叉树的实现
    接下来, 我们要实现 ~tree.h~ 中的每个函数. ~InitializeTree()~, ~EmptyTree()~,
    ~FullTree()~ 和 ~TreeItems()~ 函数都很简单, 与链表 ADT, 队列 ADT 类似, 所以
    下面着重讲解其他函数.

    1. 添加项
       在树中添加一个项, 首先要检查该树是否有空间放得下一个项. 由于我们定义二叉
       树时规定其中的项不能重复, 所以接下来要检查树中是否有该项. 通过这两步检查
       后, 便可创建一个新节点, 把待添加项拷贝到该节点中, 并设置节点的左指针和右
       指针都为 ~NULL~. 这表明该节点没有子节点. 然后, 更新 Tree 结构的 size 成员,
       统计新增了哪一项. 接下来, 必须找出应该把这个新节点放在树中的哪个位置. 如
       果树为空, 则应设置根节点指向该新节点. 否则, 遍历树找到合适的位置放置该节
       点. ~AddItem()~ 函数就根据这个思路来实现, 并把一些工作交给几个尚未定义的
       函数: ~SeekItem()~, ~MakeNode()~ 和 ~AddNode()~.

       #+begin_src c
         bool AddItem(const Item* pi, Tree* ptree)
         {
           Trnode* new_node;

           if (TreeIsFull(ptree))
           {
             fprintf(stderr, "Tree is full\n");
             return false;
           }

           if (SeekItem(pi, ptree).child != NULL)
           {
             fprintf(stderr, "Attempted to add duplicate item\n");
             return false;
           }

           new_node = MakeNode(pi); // 指向新节点

           if (new_node == NULL)
           {
             fprintf(stderr, "Couldn't create node\n");
             return false;
           }

           // 成功创建了一个新节点
           ptree->size++;

           if (ptree->root == NULL) // 情况1: 树为空
             ptree->root = new_node; // 新节点是根节点
           else // 情况2: 树不为空
             AddNode(new_node, ptree->root); // 在树中添加一个节点
           return true; // 成功返回
         }
       #+end_src

       ~SeekItem()~, ~MakeNode()~ 和 ~AddNode()~ 函数不是 Tree 类型公共接口的一
       部分. 它们是隐藏在 ~tree.c~ 文件中的静态函数, 处理实现的细节(如节点, 指针
       和结构), 不属于公共接口.

       ~MakeNode()~ 函数相当简单, 它处理动态内存分配和初始化节点. 该函数的参数是
       指向新项的指针, 其返回值是指向新节点的指针. 如果 ~malloc()~ 无法分配所需
       的内存, 则返回空指针. 只有成功分配了内存, ~MakeNode()~ 函数才会初始化新节
       点.下面是代码:
       #+begin_src c
         static Trnode* MakeNode(const Item* pi)
         {
           Trnode* new_node;
           new_node = (Trnode*)malloc(sizeof(Trnode));

           if (new_node != NULL)
           {
             new_node->item = *pi;
             new_node->left = NULL;
             new_node->right = NULL;
           }

           return new_node;
         }
       #+end_src

       ~AddNode()~ 函数是二叉查找树包中最麻烦的第二个函数. 它必须确定新节点的位
       置, 然后添加新节点. 具体来说, 该函数要比较新项和跟项, 以确定应该把新项放
       在左子树和右子树中. 若新项为数字, 则使用 ~<~ 和 ~>~ 进行比较; 如果是一个
       字符串, 则使用 ~strcmp()~ 函数来比较. 但是, 该项是内含两个字符串的结构,
       所以, 必须自定义用于比较的函数. 如果新项应放在左子树中, ~ToLeft()~ 函数
       (稍后定义)返回 ~true~; 这两个函数分别相当于 ~<~ 和 ~>~. 假设把新项放在左
       子树中, 如果左子树为空, ~AddNode()~ 函数只需让左子节点指针指向新项即可.
       如果左子树不为空, 此时, ~AddNode()~ 函数应该把新项和左子节点中的项作比较,
       以确定新项应该放在该节点的左子树还是右子树. 这个过程一直持续到函数发现一
       个空子树位置, 并在此处添加新节点. 递归是一种实现这种查找过程的方法, 即把
       ~AddNode()~ 函数应用于子节点, 而不是根节点. 当左子树或右子树为空是, 即当
       ~root->left~ 或 ~root->right~ 为 ~NULL~ 时, 函数的递归调用序列结束. 记住,
       ~root~ 是指向 *当前子树顶部* 的指针, 所以每次递归调用它都指向一个新的下一
       级子树(递归见第 9 章)
       
       #+begin_src c
         static void AddNode(Trnode* new_node, Trnode* root)
         {
           if (ToLeft(&new_node->item, &root->item))
           {
             if (root->left == NULL) // 空子树
               root->left = new_node; // 在此处添加节点
             else
               AddNode(new_node, root->left); // 否则, 处理该子树
           }
           else if (ToRight(&new_node->item, &root->item))
           {
             if (root->right == NULL)
               root->right = new_node;
             else
               AddNode(new_node, root->right);
           }
           else // 不应该含有重复的项
           {
             fprinf(stderr, "location error in AddNode()\n");
             exit(1);
           }
         }
       #+end_src

       ~ToLeft()~ 和 ~ToRight()~ 函数依赖于 Item 类型的性质. Nerfville 宠物俱乐
       部的成员名按字母排序. 如果两个宠物名相同, 按其种类排序. 如果种类也相同,
       这两项属于重复项, 根据该二叉树的定义, 这是不允许的. 回忆一下, 如果标准 C
       库函数 ~strcmp()~ 中的第一个参数表示的字符串在第二个参数表示的字符串前面,
       该函数则返回复数; 如果两个字符串相同, 该函数则返回 0; 如果第 1 个字符串在
       第 2 个字符串后面, 该函数则返回整数. ~ToRight()~ 函数的实现代码与该函数类
       型. 荣光这两个函数完成比较, 而不是直接在 ~AddNode()~ 函数中直接比较, 这样
       的代码更容易适应新的要求. 当需要比较不同的数据形式时, 就不必重写整个
       ~AddNode()~ 函数, 只需重写 ~ToLeft()~ 和 ~ToRight()~ 即可.

       #+begin_src c
         static bool ToLeft(const Item* i1, const Item* i2)
         {
           int comp1;

           if ((comp1 = strcmp(i1->petname, i2->petname)) < 0)
             return true;
           else if (comp1 == 0 &&
                    strcmp(i1->petkind, i2->petkind) < 0)
             return true;
           else
             return false;
         }
       #+end_src

    2. 查找项
       3 个接口函数都要在树中查找特定项: ~AddItem()~, ~InItem()~ 和
       ~DeleteItem()~. 这些函数的实现中使用 ~SeekItem()~ 函数进行查找.
       ~DeleteItem()~ 函数有一个额外的要求: 该函数要知道待删除项的父节点, 以便在
       删除子节点后更新父节点指向子节点的指针. 因此, 我们设计 ~SeekItem()~ 函数
       返回的结构包含 2 个: *一个指针指向包含项的节点* (如果未找到指定项则为
       ~NULL~); *一个指针指向父节点* (如果该节点为根节点, 即没有父节点, 则为
       ~NULL~). 这个结构类型的定义如下:
       #+begin_src c
         typedef struct pair {
           Trnode* parent;
           Trnode* child;
         } Pair;
       #+end_src

       ~SeekItem()~ 函数可以用递归的方式实现. 但是, 为了介绍更多编程技巧, 这次试
       用 ~while~ 循环处理树中从上到下的查找. 和 ~AddNode()~ 一样, ~SeekItem()~
       也使用 ~ToLeft()~ 和 ~ToRight()~ 在树中导航. 开始时, ~SeekItem()~ 设置
       ~look.child~ 指针指向该树的根节点, 然后沿着目标项应在的路径重置
       ~look.child~ 指向后续的子树. 同事, 设置 ~look.parent~ 指向后续的父节点.
       如果没有找到匹配的项, ~look.child~ 则被设置为 ~NULL~. 如果在根节点找到匹
       配的项, 则设置 ~look.parent~ 为 ~NULL~, 因为根节点没有父节点. 下面是
       ~SeekItem()~ 函数的实现代码:
       #+begin_src c
         static Pair SeekItem(const ITem* pi, const Tree* ptree)
         {
           Pair look;
           look.parent = NULL;
           look.child = ptree->root;

           if (look.child == NULL)
             return look;

           while (look.children != NULL)
           {
             if (ToLeft(pi, &(look.child->item)))
             {
               look.parent = look.child;
               look.child = look.child->left;
             }
             else if (ToRight(pi, &(look.child->item)))
             {
               look.parent = look.child;
               look.child = look.child->right;
             }
             else // 若前面 2 种情况都不满足, 必定相等
               break; // look.child目标项的节点
           }

           return look;
         }
       #+end_src

       *注意*: 如果 ~SeekItem()~ 函数返回一个结构, 那么该函数可以与结构成员运算
       符一起使用. eg: ~AddItem()~ 函数中有如下代码:
       #+begin_src c
         if (SeekItem(pi, ptree).child != NULL)
       #+end_src

       有了 ~SeekItem()~ 函数后, 编写 ~InTree()~ 公共接口函数就很简单了:
       #+begin_src c
         bool InTree(const ITem* pi, const Tree* ptree)
         {
           return (SeekItem(pi, ptree).child == NULL) ? false : true;
         }
       #+end_src

    3. 考虑删除项
       删除项是最复杂的任务, 因为必须 *重新连接剩余的子树* 形成有效的树. 在准备
       编写这部分代码之前, 必须要明确做什么.

       待删除的节点没有子节点, 这样的节点被称为叶节点(leaf). 这种情况只需把父节
       点中的指针重置为 ~NULL~, 并使用 ~free()~ 函数释放已删除节点所占用的内存.

       删除带有一个子节点的情况比较复杂. 删除该节点会导致其子树与其他部分分离.
       为了修正这种情况, 要把被删除节点父节点中储存该节点的地址更新为该节点子树
       的地址.

       最后一种情况是删除有 2 个子树的节点. 其中一个子树(eg: 左子树)可连接在被删
       除节点之前连接的位置. 但是, 另一个子树如何处理? 牢记树的基本设计: 左子树
       的所有项都在父节点项的前面, 右子树的所有项都在父节点项的后面. 也就是说,
       右子树的所有项都在左子树所有项的后面. 而且, 因为该右子树层级是被删除节点
       的父节点的左子树的一部分, 所以该右节点中的所有项在被删除节点的父节点项的
       前面. 想象一下如何在树中从上到下查找该右子树的头所在的位置. 它应该在被删
       除节点的父节点的前面, 所以要沿着父节点的左子树向下找. 但是, 该右子树的所
       有项又在被删除节点左子树所有项的后面. 因此要查看左子树的右支是否有新节点
       的空位. 如果没有, 就要沿着左子树的右支是否有新节点的空位. 如果没有, 就要
       沿着左子树的右支向下找, 一直找到一个空位为止.

       1) 删除一个节点
          现在可以设计所需的函数了, 可以分成 2 个任务: 第一个任务把特定项与待删
          除节点关联; 第二个任务是删除节点. 无论哪种情况都必须修改待删除项父节点
          的指针. 因此, 要注意以下两点.

          该程序必须标识待删除节点的父节点.

          为了修改指针, 代码必须把该指针的地址传递给执行删除任务的函数.

          第一点稍后讨论, 下面先分析第二点. 要修改的指针本身是 ~Trnode*~ 类型,
          即指向 Trnode 的指针. 由于该函数的参数是该指针的地址, 所以参数的类型是
          ~Trnode**~, 即指向指针(该指针指向 Trnode)的指针. 假设有何时的地址可用,
          可以这样编写执行删除任务的函数:

          #+begin_src c
            static void DeleteNode(Trnode** ptr)
            {
              // ptr 是指向目标节点的父节点指针成员的地址

              Trnode* temp;
              if ((*ptr)->left == NULL)
              {
                temp = *ptr;
                *ptr = (*ptr)->right;
                free(temp);
              }
              else if ((*ptr)->right == NULL)
              {
                temp = *ptr;
                *ptr = (*ptr)->left;
                free(temp);
              }
              else // 被删除的节点有 2 个子节点
              {
                // 找到重新连接右子树的位置
                for (temp = (*ptr)->left; temp->right != NULL; temp = temp->right)
                  continue;

                temp->right = (*ptr)->right;
                temp = *ptr;

                *ptr = (*ptr)->left;
                free(temp);
              }
            }
          #+end_src

          该函数显式处理了 3 种情况: 没有左节点的节点, 没有右子节点的节点和有两
          个子节点的节点. 无子节点的节点可作为无左子节点的节点特例. 如果该节点没
          有左子节点, 程序就将右子节点的地址赋值给其父节点的指针. 如果该节点也没
          有右子节点, 则该指针为 ~NULL~. 这就是无子节点的情况的值

          *注意*: 代码中用临时指针记录被删除节点的地址. 被删除节点的父节点指针
          (*ptr) 被重置后, 程序会丢失被删除节点的地址, 但是 ~free()~ 函数需要这
          个信息. 所以, 程序把 ~*ptr~ 的原始值储存在 temp 中, 然后用 ~free()~ 函
          数使用 temp 来释放被删除节点所占用的内存.

          有两个子节点的情况, 首先在 for 循环中通过 temp 指针从左子树的右半部分
          向下查找一个空位. 找到空位后, 把右子树连接与此. 然后, 再用 temp 保存被
          删除节点的位置. 接下来, 把左子树链接到被删除节点的父节点上, 最后释放
          temp 指向的节点

          *注意*: 由于 ptr 的类型是 ~Trnode**~, 所以 ~*ptr~ 的类型是 ~Trnode*~,
          与 temp 的类型相同

       2) 删除一个项
          剩下的问题是把一个节点与特定项关联. 可以使用 ~SeekItem()~ 函数来完成.
          该函数返回一个结构(内含 2 个指针, 一个指针指向父节点, 一个指针指向包含
          特定项的节点). 然后就可以通过父节点的指针获得相应的地址传递给
          ~DeleteNode()~ 函数. 根据这个思路, ~DeleteNode()~ 函数的定义如下:
          #+begin_src c
            bool DeleteItem(const Item* pi, Tree* ptree)
            {
              Pair look;
              look = SeekItem(pi, ptree);

              if (look.child == NULL)
                return false;
              if (look.parent == NULL) // 删除根节点
                DeleteNode(&ptree->root);
              else if (look.parent->left == look.child)
                DeleteNode(&look.parent->left);
              else
                DeleteNode(&look.parent->right);
              ptree->size--;

              return true;
            }
          #+end_src

          首先, ~SeekItem()~ 函数的返回值被赋给 look 类型的结构变量. 如果
          ~look.child~ 是 ~NULL~, 表明未找到指定项, ~DeleteItem()~ 函数退出, 并
          返回 ~false~. 如果找到了指定的 Item, 该函数分 3 种情况来处理. 第一种情
          况是, ~look.parent~ 的值为 ~NULL~, 这意味着该项在根节点中. 在这种情况
          下, 不用更新父节点, 但是要更新 Tree 结构中根节点的指针. 因此, 该函数把
          该指针的地址传递给 ~DeleteNode()~ 函数. 否则(即剩下 2 种情况), 程序判
          断待删除节点是其父节点的左子节点还是右节点, 然后传递合适指针的地址.

          *注意*: 公共接口函数(~DeleteItem()~) 处理的是最终用户所关心的问题(项和
          树), 而隐藏的 ~DeleteNode()~ 函数处理的是与指针相关的实质性任务

    4. 遍历树
       遍历树比遍历链表更复杂, 因为每个节点都有 2 个分支. 这种分支特性很适合使用
       分而治之的递归(第九章)来处理. 对于每一个节点, 执行遍历任务的函数都要做如
       下的工作:
       #+begin_example
         处理节点中的项:
         处理左子树(递归调用);
         处理右子树(递归调用).
       #+end_example

       可以把遍历分成 2 个函数来完成: ~Traverse()~ 和 ~InOrder()~. *注意*:
       ~InOrder()~ 函数处理左子树, 然后处理项, 最后处理右子树. 这种遍历树的顺序
       是按字母排序进行. 如果你有时间, 可以试试用不同的顺序, 比如: 项-左子树-右
       子树或者左子树-右子树-项, 看看会发生什么.
       #+begin_src c
         void Traverse(const Tree* ptree, void(*pfun)(Item item))
         {
           if (ptree != NULL)
             InOrder(ptree->root, pfun);
         }

         static void InOrder(const Trnode* root, void(*pfun)(Item item))
         {
           if (root != NULL)
           {
             InOrder(root->left, pfun);
             (*pfun)(root->item);
             InOrder(root->right, pfun);
           }
         }
       #+end_src

    5. 清空树
       清空树基本上和遍历树的过程相同, 即清空树的代码也要访问每个节点, 而且要用
       ~free()~ 函数释放内存.除此之外, 还要重置 Tree 类型结构的成员, 表明该树为
       空. ~DeleteAll()~ 函数负责处理 Tree 类型的结构, 把释放内存的任务交给
       ~DeleteAllNode()~ 函数. ~DeleteAllNode()~ 与 ~InOrder()~ 函数的构造相同,
       它储存了指针的值 ~root->right~, 使其在释放根节点后仍然可用. 下面是 2 个函
       数的代码:
       
       #+begin_src c
         void DeleteAll(Tree* ptree)
         {
           if (ptree != NULL)
             DeleteAllNodes(ptree->root);
           ptree->root = NULL;
           ptree->size = 0;
         }

         static void DeleteAllNodes(Trnode* root)
         {
           Trnode* pright;

           if (root != NULL)
           {
             pright = root->right;
             DeleteAllNodes(root->left);
             free(root);
             DeleteAllNodes(pright);
           }
         }
       #+end_src

    6. 完整的包
       ~tree.c~ 演示了整个树的代码, ~tree.h~ 和 ~tree.c~ 共同组成了树的程序包

*** 使用二叉树
    ~petclub.c~ 的程序以菜单的方式提供选择: 向俱乐部成员花名册添加宠物, 显示成员
    列表, 报告成员数量, 核实成员及退出. ~main()~ 函数很简单, 主要提供程序的大纲.
    具体工作主要由支持函数来完成.

*** 树的思想
    二叉查找树也有一些缺陷. eg: *二叉查找树只有在满员(或平衡)时效率最高*. 
    
    假设用户按字母顺序输入数据, 那么每个新节点应该被添加到右边. 查找不平衡的树并
    不比查找链表要快.

    避免串状树的方法之一是在创建树时多加注意. 如果树或子树的一边或另一边太不平衡,
    就需要重新排列节点使之恢复平衡. 与此类似, 可以在进行删除操作后重新排列树. 俄
    国数学家 Adel'son-Vel'skii 和 Landis 发明了一种算法来解决这个问题. 根据他们
    的算法创建的树称为 *AVL 树*. 因为要重构, 所以创建一个平衡的树所花费的时间更
    多, 但是这样的树可以确保最大化搜索效率.

    可能需要一个能储存相同项的二叉查找树. eg: 在分析一些文本时, 统计某个单词在文
    本中出现的次数. 一种方法是把 Item 定义成包含一个单词和一个数字的结构. 第一次
    遇到一个单词时, 将其添加到树中, 并且该单词的数量加一. 下一次遇到同样的单词时,
    程序找到包含该单词的节点, 并递增表示该单词数量的值. 把基本二叉查找树修改成具
    有这一特性, 不费多少功夫.

    考虑到 Nerfville 宠物俱乐部的示例, 有另一种情况. 示例中的树根据宠物的名字和
    种类进行排列, 所以, 可以把名为 Sam 的猫储存在一个节点中, 把名为 Sam 的狗储存
    在另一节点中, 把名为 Sam 的山羊储存在第 3 个节点中. 但是, 不能储存两只名为
    Sam 的猫. 另一种方法是以名字来排序, 但是这样做只能储存一个名为 Sam 的宠物.
    还需要把 Item 定义成多个结构, 而不是一个结构. 第一次出现 Sally 时, 程序创建
    一个新节点, 并创建一个新的列表, 然后把 Sally 及其种类添加到列表中. 下一次出
    现 Sally 时, 程序将定位到之前储存 Sally 的节点, 并把新的数据添加到结构列表中.

    提示: 插件库
    实现一个像链表或树这样的 ADT 比较困难, 很容易犯错. 插件库提供了一种可选的方
    法: 让其他人来完成这些工作和测试.学完本章后, 会更好地理解和认识这样的库.
    
** 其他说明
   本书中, 涵盖了 C 语言的基本特性, 但是只是介绍了库. ANSI C 库中包含多种有用的
   函数. 绝大部分实现都针对特定的系统提供扩展库. 基于 Windows 的编译器支持
   Windows 图形接口. Macintosh C 编译器提供访问 Macinto 工具箱的函数, 以便编写具
   有标准 Macintosh 接口或 iOS 系统的程序产品, eg: iPhone 或 iPad. 与此类似, 还
   有一些工具用于 Linux 程序的图形接口.

   C++, Objective-C 或 Java 这些都是以 C 为基础的面向对象 (object-oriented) 语言.
   C 已经涵盖了从简单的 char 类型变量到大型且复杂的结构在内的数据对象. 面向对象
   语言更进一步发展了对象的观点. eg: 对象的性质不仅包括它所储存的信息类型, 而且
   还包括了对其进行的操作类型. 本章介绍的 ADT 就遵循了这种模式. 而且, 对象可以继
   承其他对象的属性. OOP 提供比 C 更高级的抽象, 很适合编写大型程序.

   可以参阅补充阅读中找到感兴趣的书籍

** 关键概念
   一种数据类型通过以下几点来表征: 如何构建数据, 如何存储数据, 有哪些可能的操作.
   抽象数据类型 (ADT) 以抽象的方式指定构成某种类型特征的属性和操作. 从概念上看,
   可以分两步把 ADT 翻译成一种特定的编程语言. 第一步是定义编程接口. 在 C 中, 通
   过使用头文件定义类型名, 并提供与允许的操作相应的函数原型来实现. 第二步是实现
   接口. 在 C 中, 可以用源代码文件提供与函数原型相应的函数定义来实现.

** 本章小结
   链表, 队列和二叉树是 ADT 在计算机程序设计中常用的示例. 通常用动态内存分配和链
   式结构来实现它们, 但有时用数组来实现会更好.

   当使用一种特定类型(eg: 队列或树) 进行编程时, 压偶根据类型接口来编写程序. 这样,
   在修改或改进实现时就不用更改使用接口的那些程序.
** 复习题
   1. 构建和储存数据, 以及对数据可能的操作.
   2. 修改为双向链表, prev 存储上一项的指针:
      #+begin_src c
        struct film {
          char title[TSIZE];
          int rating;
          struct film* prev;
          struct film* next;
        };
      #+end_src
   3. 提供类型属性和相关操作的抽象概述. 这些概述既不能依赖特定的实现, 也不能依赖
      特定的编程语言. 这种正式的抽象描述被称为抽象数据类型(ADT), 抽象数据类型以
      抽象的方式制定构成某种类型特征的属性和操作
   4. 指针传递性能更高, 但是修改值会影响原始值, 拷贝传递需要拷贝一次传递, 但是修
      改值不影响原始值
   5. 见 ~res1.c~
   6. 如下:
      |    项 | 顺序查找 | 二叉查找 |
      |-------+----------+----------|
      |     3 |        3 |        2 |
      |  1023 |     1023 |     1023 |
      | 65535 |    65535 |       16 |
   7. 见 ~res2.txt~
   8. 见 ~res3.txt~
** 编程练习
   1. 见 ~practice1.c~
