* 高级数据表示
  本章介绍以下内容

  - 函数: 进一步学习 ~malloc()~
  - 使用 C 表示不同类型的数据
  - 新的算法, 从概念上增强开发程序的成立
  - 抽象数据类型(ADT)
    
    本章重点介绍如何把项目看作一个整体.

    从程序设计的关键部分开始, 即数据表示方式. 程序开发最重要的部分是 *找到程序中
    表示数据的好方法*, 正确地表示数据可以更容易地编写程序其余部分. 到目前为止,
    应该熟悉的内置类型: 简单变量, 数组, 指针, 结构和联合

    找出正确的数据不仅仅是一种数据类型, 还要必须考虑进行哪些操作. 必须确定 *如何
    存储数据*, 并且为数据类型 *定义有效的操作*.
    
    eg: C 实现通常把 int 类型和指针类型都储存为整数, 但是这两种类型的有效操作不
    相同. 
    eg: 两个整数可以相乘, 但是 *指针不能相乘*; 可以用 ~*~ 运算符解引用指针, 但是
    对整数这样做毫无意义. C 语言为它的基本类型都定义了有效的操作. 但是, 当要涉及
    数据表示的方案时, 可能需要自己定义有效操作.

    C 语言中, 可以把所需的操作设计成 C 函数来表示. 
    简而言之, 设计一种数据类型包括设计如何储存该数据类型和设计一系列管理该数据的函数

    本章还会介绍一些算法, 即 *操控数据* 的方法. 应该掌握这些可以反复解决类似问题
    的处理方法.

    本章将进一步研究设计数据类型的过程, 这是一个把算法和数据表示相匹配的过程. 期
    间会用到一些常见的数据形式, 如队列, 列表和二叉树.

    本章还将介绍 *抽象数据类型(ADT)* 的概念. 抽象数据类型以面向问题而不是面向语
    言的方式, 把解决问题的方法和数据表示结合起来. 设计一个 ADT 后, 可以在不同的
    环境中复用. 理解 ADT 可以为将来学习面向对象程序设计(OOP) 以及 C++ 语言做好准
    备

** 研究数据表示
   假设要创建一个地址薄程序. 应该使用什么数据形式存储信息? 由于储存的每一项都包
   含多种信息, 用结构来表示每一项合适. 如何表示多个项? 是否用标准的结构数组? 还
   是动态数组? 还是一些其他形式? 各项是否按字母顺序排列? 是否要按照邮政编码(或 id
   去编码) 查找各项? 需要执行的行为将如何存储信息? 简而言之, 在开始编写代码之前,
   要在程序设计方面做很多决定

   如何表示储存在内存中的位图图像? 位图图像中的每个像素在屏幕上都单独设置. 在以
   前的黑白屏的年代, 可以使用一个计算机位(1 或 0)来表示一个像素点(开或关), 因此
   称之为位图. 对于彩色显示器而言, 如果 8 位表示一个像素, 可以得到 256 种颜色.
   现在行业标准已经发展到 65536 色(每像素 16 位), 16777216 色(每像素 24 位),
   2147483 色(每像素 32 位), 甚至更多. 如果有 32 位色, 且显示器有 2560 * 1440 的
   分辨率, 则需要将近 1.18 亿位(14 M) 来表示一个屏幕的位图图像. 是用这种方法表示,
   还是开发一种压缩信息的方法? 是有损压缩(丢失相对次要的数据) 还是无损压缩(没有
   丢失数据)? 开始编写代码之前, 需要做很多程序设计方面的决定

   来处理一个数据表示的示例. 假设要编写一个程序, 让用户输入一年内看过的所有电影
   (包括 DVD 和 蓝光光碟). 要储存每部影片的各种信息, eg: 片名, 发行年份, 导演,
   主演, 片长, 影片的种类(喜剧, 科幻, 爱情等), 评级等. 建议使用一个结构储存每部
   电影, 一个数组储存一年内看过的电影. 为简单起见, 我们规定结构中只有 2 个成员:
   片名和评级(0 ~ 10). ~films1.c~ 演示了一个基本的实现

   该程序创建了一个结构数组, 然后把用户输入的数据储存在数组中. 直到数组已满(用
   FMAX 判断)或者达到结尾(~NULL~ 判断), 或者用户首行按下 ENTER(用 ~'\0'~ 判断),
   输入才会终止

   这样设计程序有问题. 首先, 该程序可能会浪费许多 *空间*, 因为大部分的片名都不会
   超过 40 个字符. 但是, 有的片名的确很长. 其次, 许多人会觉得每年 5 部电影的限制
   太严格, 放宽多大才合适? 很可能浪费大量内存. 一些编译器对自动存储类别的变量
   (eg: movies)可用的内存数量设置了一个默认的限制, 大型的数组可能会超过默认设置
   的值. 可以把数组声明为 *静态* 或 *外部数组*, 或者设置编译器使用更大的栈来解决
   这个问题. 但是这样做 *并不能解决根本问题*.

   该程序真正的问题是, 数据表示 *不太灵活*. 程序在编译时确定所需内存量, 改成运行
   时会更好.

   #+begin_src c
     #define TSISE 45

     struct film {
       char title[TSIZE];
       int rating;
     };

     // ...

     int n, i;
     struct film* movies; // 指向结构的指针

     // ...

     printf("Enter the maximum number of movies you'll enter:\n");
     scanf("%d", &n);

     movies = (struct film*)malloc(n * sizeof(struct film));
   #+end_src

   使用 ~malloc()~, 可以推迟到程序运行时才确定数组中的元素数量. 所以, 如果只需要
   20 个元素, 就不必分配 500 个元素的空间. ong 付要为元素个数提供正确的值

** 从数组到链表
   理想的情况是, 用户可以不确定地添加数据(或者不断添加数据知道用完内存量), 而不
   是先指定要输入多少项, 也不用让程序分配多余的空间. 这可以通过在输入每一项后调
   用 ~malloc()~ 分配正好能储存该项的空间. 如果用户输入 3 部影片, 程序就调用
   ~malloc()~ 3 次; 如果用户输入 300 部 影片, 程序就调用 ~malloc()~ 300 次. 

   比较: 一种方法是调用 ~malloc()~ 一次, 为 300 个 ~film~ 结构请求分配足够的空
   间. 前者分配的是连续的内存块, 只需要一个单独的指向 ~struct~ 变量(film) 的指针,
   该指针指向已分配块中的第一个结构. 简单的数组表示法让指针访问块中的每个结构,
   如前面的代码所示. 第二种方法的问题是, 无法保证每次调用 ~malloc()~ 都能分配到
   连续的内存块. 这意味着结构不一定被连续储存. 因此, 与第一种方法储存一个指向
   300 个结构块的指针相比, 需要储存 300 个指针, 每个指针指向一个单独储存的结构

   两种方法: 
   1. 一种解决方法是创建一个大型的指针数组, 并在分配新结构时逐个给这些指针赋值:
      #+begin_src c
        #define TSIZE 45
        #define FMAX 500

        struct film {
          char title[TSIZE];
          int rating;
        };

        // ...

        struct film* movies[FMAX]; // 结构指针数组

        int i;

        // ...

        movies[i] = (struct film*)malloc(sizeof(struct fiml));

      #+end_src

      如果用不完 500 个指针, 这种方法节约了大量的内存, 因为内含 500 个指针的数组
      比内含 500 个结构的数组所占的内存少的多. 尽管如此, 如果用不到 500 个指针,
      还是浪费了不少空间. 而且, 这样还是有 500 个结构的限制.

   2. 更好的方法: 每次使用 ~malloc()~ 为新结构分配空间时, 也为新指针分配空间. 但
      是还得需要另一个指针来跟踪新分配的指针, 用于跟踪新指针的指针本身, 也需要一
      个指针来跟踪. 以次类推. 要重新定义结构材料解决这个潜在的问题, 即每个结构中
      包含指向 next 结构的指针. 然后, 当创建新结构时, 可以把该结构的地址储存在上
      一个结构中. 简而言之, 可以这样定义 ~film~ 结构:

      #+begin_src c
        #define TSIZE 45

        struct fiml {
          char title[TSIZE];
          int rating;
          struct film* next;
        }
      #+end_src

      虽然结构不能含有与自身类型相同的结构, 但是可以含有指向同类型结构的指针. 这
      种定义是 *链表(linked list)* 的基础,链表中的每一项都包含着在何处能找到下一
      项的信息.

      概念上理解链表: 假设用户输入片名 Modern Times, 等级为 10. 程序将为 film 类
      型结构分配空间, 把字符串 Modern Times 拷贝到结构中的 title 成员中, 然后设
      置 rating 成员为 10. 为了表明该结构后面没有其他结构, 程序要把 next 成员指
      针设置为 ~NULL(符号常量, 表示空指针)~. 当然, 还需要一个单独的指针储存第一
      个结构的地址, 该指针被称为 *头指针(head pointer)*. 头指针指向链表中的第一
      项. 

      #+begin_src c
        #define TSIZE 45

        struct film {
          char title[TSIZE];
          int rating;
          struct film* next;
        };

        struct film* head;
      #+end_src
      
      现在, 假设用户输入第二部电影及其评级, 如 Midnight in Paris 和 8. 程序为第
      二个 film 类型结构分配空间, 把新结构的地址储存在第一个结构的 next 成员中
      (擦写了之前储存在该成员中的 NULL), 这样链表中第一个结构中的 next 指针指向
      第二个结构. 然后程序把 Midnight in Parais 和 8 拷贝到新结构中, 并把第二个
      结构中的 next 成员设置为 NULL, 表明该结构是链表中的最后一个结构

      没加入一部新电影, 就以相同的方式来处理. 新结构的地址将储存在上一个结构中,
      新信息储存在新结构中, 而且新结构中的 next 成员设置为 NULL

      假设要显示这个链表, 每显示一项, 就可以根据该项中已储存的地址来定义下一个待
      显示的项. 然而, 这种方法能正常余晓玲, 还需要一个指针储存链表中第一项的地址,
      因为链表中没有其他项储存该项的地址. 此时, 头指针就派上了用场.

**** 使用链表
     实现: ~film2.c~

     该程序用链表执行 2 个任务: 第一个任务是: 构造一个链表, 把用户输入的数据储存
     在链表中. 第二个任务是: 显示链表. 显示链表的任务比较简单

     1. 显示链表
        显示链表从设置一个指向第一个结构的指针(名为 current) 开始. 由于头指针(名
        为 head)已经指向链表中的第一个结构, 所以可以用下面的代码来完成
        #+begin_src c
          current = head;
        #+end_src

        然后, 可以使用指针表示法访问结构的成员:
        #+begin_src c
          printf("Movie: %s Rating: %d\n", current->title, current->rating);
        #+end_src

        完成这些之后, 在重复整个过程, 但显示到链表中最后一个项时, ~current~ 将被
        设置为 ~NULL~, 因为这是链表最后一个结构中 next 成员的值
        #+begin_src c
          while (current != NULL)
          {
            printf("Movie: %s Rating: %d\n", current->title, current->rating);
            current = current->next;
          }
        #+end_src

        遍历链表时, 需要创建一个新的指针, 直接使用 head 会改变 head 的值, 导致程
        序还找不到链表的开始处

     2. 创建链表
        步骤:
        1) 使用 ~malloc()~ 为结构分配足够的空间
        2) 储存结构的地址
        3) 把当前信息拷贝到结构中

        如无必要不要红创建一个结构, 所以程序使用临时存储区(input 数组) 获取用户
        输入的电影名. 如果用户通过键盘模拟 ~EOF~ 或输入一行空行, 将退出下面的循
        环:
        #+begin_src c
          while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
        #+end_src

        如果用户进行输入, 程序就分配一个结构的空间, 并将其地址赋给指针变量
        current:
        #+begin_src c
          current = (struct film*)malloc(sizeof(struct film));
        #+end_src

        链表中第一个结构的地址应储存在指针变量 head 中. 随后每个结构的地址应储存
        在其前一个结构的 next 成员中. 因此, 程序要知道它处理的是否是第一个结构.
        最简单的方法是在程序开始时, 把 head 指针初始化为 NULL. 然后, 程序可以使
        用 head 的值进行判断:
        #+begin_src c
          if (head == NULL)
          {
            head = current;
          }
          else
          {
            prev->next = current;
          }
        #+end_src

        指针 prev 指向上一次分配的结构.
        
        接下来, 必须为结构成员设置合理的值. 尤其是: 把 next 成员设置为 NULL, 表
        明当前结构是链表的最后一个结构. 还要把 input 数组中的电影名拷贝到 title
        成员中, 而且要给 rating 成员赋值:
        #+begin_src c
          current->next = NULL;
          strcpy(current->title, input);
          puts("Enter your rating <0-10>:");
          scanf("%d", &current->rating);
        #+end_src

        由于 ~s_gets()~ 限制了只能输入 ~TSIZE-1~ 个字符, 所以用 ~strcpy()~ 函数
        把 input 数组中的字符串拷贝到 title 成员很安全

        最后, 要为下一次输入做好准备. 尤其要设置 prev 指向当前结构. 因为在用户输
        入下一步电影且成员为新结构分配空间后, 当前结构将成为新结构的上一个结构,
        所以程序在循环末尾这样设置指针:
        #+begin_src c
          prev = current;
        #+end_src
        
     3. 释放链表
        在许多环境中, 程序结束时都会自动释放 ~malloc()~ 分配的内存. 但是, 最好还
        是成对调用 ~malloc()~ 和 ~free()~. 因此, 程序在清理内存时为每个已分配的
        结构都调用了 ~free()~ 函数:
        #+begin_src c
          current = head;

          while (current != NULL) {
            current = head;
            head = current->next;
            free(current);
          }
        #+end_src

        
**** 反思
     ~film2.c~ 程序还有些不足. eg: 程序没有检查 ~malloc()~ 是否成功请求到内存,
     也无法删除链表中的项. 这些不足可以弥补. eg: 添加代码检查 ~malloc()~ 的返回
     值是否是 ~NULL~ (返回 NULL 说明未获得所需内存). 如果程序要删除链表 中的项,
     还要编写更多的代码.

     这种用 *特定方法解决特定问题*, 并且在需要时才添加相关功能的变成方式通常不是
     最好的解决方案. 另一方面, 通常都无法预料程序要完成的所有任务. 随着编程项目
     越来越大, 一个程序员或编程团队事先计划好一切模式, 越来越不现实. 很多成功的
     大型程序都是由成功的小型程序逐步发展而来.

     如果要修改程序, 首先应该强调最初的设计, 并简化其他细节. ~film2.c~ 中的程序
     示例没有遵循这个原则, 它把概念模型和代码细节混在一起. eg: 该程序的概念模型
     是在一个链表中添加项, 但是程序却把一些细节(eg: ~malloc()~ 和
     ~current->next~ 指针)放在 *最明显* 的位置, 没有 *突出接口*. 如果程序能以某
     种方式强调给链表添加项, 并隐藏具体的处理细节(如调用内存管理函数和设置指针)
     会更好. 把 *用户接口和代码细节分开的程序, 更容易理解和更新*.
** 抽象数据类型(ADT)
   在编程时, 应该根据编程问题匹配合适的数据类型. eg: 用 ~int~ 类型代表你有多少双
   鞋, 用 ~float~ 或 ~double~ 类型代表每双鞋的价格. 在前面的电影示例中, 数据构成
   了链表, 每个链表项由电影名 (C 字符串) 和评级 (一个 int 类型的值). C 中没有与
   之匹配的基本类型, 所以我们定义了一个结构代表单独的项, 然后设计了一些方法把一
   系列结构构成一个链表. 本质上, 我们使用 C 语言的功能设计了一种符合程序要求的新
   数据类型. 但是并 *不系统*. 现在, 我们用更系统的方法来定义数据类型

   *注意*: 整数属性

   C 的 ~int~ 类型背后是一个更抽象的整数概念. 数学家已经用正式的抽象方式定义了整
   数的属性. eg: N 和 M 是整数, 那么 ~N+M=M+N~; 假设 S, Q 也是整数, 如果
   ~N+M=S~, 而且 ~N+Q=S~, 那么 ~M=Q~. 可以认为数学家提供了整数的抽象概念, 而 C
   则实现了这一抽象概念. *注意*: 实现整数的算术运算是表示整数必不可少的部分. 如
   果只是储存值, 并未在算术表达式中使用, ~int~ 类型就没那么有用了. 还要注意的是,
   C 并未很好地实现整数. eg: 整数是无穷大的数, 但是 2 字节的 int 类型只能表示
   65536 个整数. 因此, *不要混淆抽象概念和具体的实现*

   假设要定义一个新的数据类型. 首先, 必须提供储存数据的方法, eg: 设计一个结构.
   其次, 必须提供操控数据的方法. eg: 考虑 ~films2.c~ 程序. 该程序用链接的结构来
   储存信息, 并且通过代码实现了如何添加和显示信息. 尽管如此, 该程序并未清楚地表
   明正在创建一个新类型. 做法:

   计算机科学领域已开发了一种定义新类型的好方法, 用 3 个步骤完成从抽象到具体的
   过程:

   1. 提供类型属性和相关操作的抽象描述. 这些描述既不能依赖特定的实现, 也不能依赖
      特定的编程语言. 这种正式的抽象描述被称为抽象数据类型(ADT)

   2. 开发一个实现 ADT 的编程接口. 也就是说, 指名如何储存数据和执行所需操作的函
      数. eg: 在 C 中, 可以提供结构定义和操控该结构的函数原型. 这些作用于用户定
      义类型的函数相当于作用与 C 基本类型的内置运算符. 需要使用该新类型的程序员
      可以使用这个接口进行编程

   3. 编写代码实现接口. 这一步至关重要, 但是使用该新类型的程序员无需了解具体的实
      现细节.
** 队列ADT
   在 C 语言中使用抽象数据类型方法编程包含以下 3 个步骤:
   1. 以抽象, 通用的方式描述一个类型, 包括该类型的操作
   2. 设计一个函数接口表示这个新类型
   3. 编写具体代码实现这个接口

   前面已经把这种方法应用到简单链表中. 现在, 把这种方法应用于更复杂的数据类型:
   队列.   

*** 定义队列抽象数据类型
    *队列(queue)是具有两个特殊属性的链表*: 第一: 新项只能添加到链表的末尾. 从这
     方面看, 队列与简单链表类型. 第二, 只能从链表的开头移除项. 可以把队列想象成
     排队买票的人. 你从队尾加入队列, 买完票后从对首离开. 队列是一种 *先进先出*
     (first in, first out, 缩写为 FIFO) 的数据形式, 就像在排队买票的队伍一样(前
     提是没有人插队). 接下来, 建立一个非正式的抽象定义:
     
     #+begin_example
       类型名: 队列
       类型属性: 可以储存一系列项
       类型操作: 初始化队列为空
       确定队列为空
       确定队列已满
       确定队列中的项数
       在队列末尾添加项
       在队列开头删除或恢复项
       清空队列
     #+end_example

*** 定义一个接口
    接口定义放在 ~queue.h~ 文件中. 我们使用 C 的 ~typedef~ 工具创建两个类型名:
    Item 和 Queue. 相应结构的具体实现应该是 ~queue.h~ 文件的一部分, 但是从概念上
    来看, 应该在实现阶段才设计结构. 现在, 只是假定已经定义了这些类型, 着重考虑函
    数的原型.

    首先, 考虑初始化. 这涉及改变 Queue 类型, 所以该函数应该以 Queue 的地址作为参
    数: 
    #+begin_src c
      void InitializeQueue(Queue* pq);
    #+end_src

    接下来, 确定队列是否为空或已满的函数应返回真或假值. 这里, 假设 C99 的
    ~stdbool.h~ 头文件可用, 如果该文件不可用, 可以使用 ~int~ 类型或自己定义
    ~bool~ 类型. 由于该函数不更改队列, 所以接受 Queue 类型的参数. 但是, 传递
    Queue 的地址更快, 更节省内存. 这样做的好处是: 所有的函数都以地址作为参数. 为
    了表明这些函数不更改队列, 可以且应该使用 ~const~ 限定符:
    #+begin_src c
      bool QueueIsFull(const Queue* pq);
      bool QueueIsEmpty(const Queue* pq);
    #+end_src

    指针 pq 指向 Queue 数据对象, 不能通过 pq 这个代理更改数据. 可以定义一个类似
    该函数的原型, 返回队列的项数:
    #+begin_src c
      int QueueItemCount(const Queue* pq);
    #+end_src

    在队列末尾添加项设计标识项和队列. 这次要更改队列, 所以有必要(而不是可选)使用
    指针. 该函数的返回类型可以是 ~void~, 或者通过返回值来表示是否成功添加项. 我
    们采用后者:
    #+begin_src c
      bool EnQueue(Item item, Queue* pq);
    #+end_src
    最后, 删除项有多种方法. 如果把该项定义为结构或一种基本类型, 可以通过函数返回
    待删除的项. 函数的参数可以是 Queue 类型或指向 Queue 的指针. 因此, 可以是下面
    这样的原型:
    #+begin_src c
      Item DeQueue(Queue q);
    #+end_src

    然而, 下面的原型会更合适一些:
    #+begin_src c
      bool DeQueue(Item* pitem, Queue* pq);
    #+end_src

    从队列中待删除的项储存在 pitem 指针指向的位置, 函数的返回值表明是否删除成功

    清空队列的函数所需的唯一参数是队列的地址, 可以使用下面的函数原型:
    #+begin_src c
      void EmptyTheQueue(Queue* pq);
    #+end_src

    
*** 实现接口数据表示
    第一步是确定在队列中使用何种 C 数据形式. 有可能是数组. 数组的优点是方便使用,
    而且向数组的末尾添加项很简单. 问题是如果从队列的开头删除项. 类比于排队买票的
    队列, 从队列的开头删除一个项包括拷贝数组首元素的值和把数组剩余各项依次向前移
    动一个位置. 编程实现这个过程很简单, 但是会浪费大量的计算机时间.

    第二种解决数组队列删除问题的方法是改变队列首端的位置, 其余元素不动.

    解决这种问题的一个好方法是, 使队列成为环形, 这意味着把数组的首尾相连, 即数组
    的首元素紧跟在最后一个元素后面. 这样, 当到达数组末尾时, 如果首元素空出, 就可
    以把新添加的项储存到这些空出的元素中. 可以想象在一张条形的纸上画出数组, 然后
    把数组的末尾首尾粘起来形成一个环. 当然, 要做一些标记, 以免尾端超过首端.

    另一种方法是使用链表. 使用链表的好处是删除首项时不必移动其余元素, 只需重置头
    指针指向新的首元素即可. 由于我们已经讨论过链表, 所以采用这个方法. 我们用一个
    整数队列开始测试:
    #+begin_src c
      typedef int Item;
    #+end_src

    链表由节点组成, 所以, 下一步是定义节点:
    #+begin_src c
      typedef struct node
      {
        Item item;
        struct node* next;
      } Node;
    #+end_src

    对队列而言, 要保存首尾项, 这可以使用指针来完成. 另外, 可以用一个计数器来记录
    队列中的项数. 因此, 该结构应由两个指针成员和一个 int 类型的成员构成:
    #+begin_src c
       typedef struct queue
       {
         Node* front; // 指向队列首项的指针
         Node* rear; // 指向队列尾项的指针
         int items; // 队列中的项数
       } Queue;
    #+end_src

    注意: Queue 是一个内含 3 个成员的结构, 所以用指向队列的指针作为参数比直接用
    队列作为参数节约了时间和空间

    接下来, 考虑队列的大小. 对链表而言, 其大小受限于可用的内存量, 因此链表不要太
    大. eg: 可能使用一个队列模拟飞机等待在机场着陆. 如果等待的飞机数量太多, 新到
    的飞机就应该改到其他的机场降落. 我们把队列的最大程度设为 10. ~queue.h~ 包含
    了队列接口的原型和定义. Item 类型留给用户定义. 使用该接口时, 可以根据特定的
    程序插入合适的定义.

**** 实现接口函数
     接下来, 我们编写接口代码. 首先, 初始化队列为空, 这里 "空" 的意思是指把指向
     队列的首项和尾项的指针设置为 ~NULL~, 并把项数(items 成员) 设置为 0:
     #+begin_src c
       void InitializeQueue(Queue* pq)
       {
         pq->front = pq->rear = NULL;
         pq->items = 0;
       }
     #+end_src

     这样, 通过检查 items 的值可以很方便地了解队列是否已满, 是否为空和确定队列的
     项数:
     #+begin_src c
       bool QueueIsFull(const Queue* pq)
       {
         return pq->items == MAXQUEUE;
       }

       bool QueueIsEmpty(const Queue* pq)
       {
         return pq->items == 0;
       }

       int QueueItemCount(const Queue* pq)
       {
         return pq->items;
       }
     #+end_src

     把项添加到队列中, 包括以下几个步骤:
     1. 创建一个新节点
     2. 把项拷贝到节点中
     3. 设置节点的 next 指针为 ~NULL~, 表明该节点是最后一个节点
     4. 设置当前尾节点的 next 指针指向新节点, 把新节点链接到队列中
     5. 把 rear 指针指向该节点, 以便找到最后的节点
     6. 项数加 1

        
     函数还要处理 2 种特殊情况. 第一种情况: 如果队列为空, 应该把 front 指针设置
     为指向新节点. 因为如果队列中只有一个节点, 那么这个节点既是首节点也是尾节点.
     第二种情况是: 如果函数不能为新节点分配所需的内存, 则必须执行一些动作. 因为
     大多数情况下我们都使用小型队列, 这种情况很少发生, 所以, 如果程序运行的内存
     不足, 我们只是通过函数终止程序.

     ~EnQueue()~ 的代码如下:
     #+begin_src c
       bool EnQueue(Item item, Queue* pq)
       {
         Node* pnew;
         if (QueueIsFull(pq))
           return false;

         pnew = (Node*)malloc(sizeof(Node));

         if (pnew == NULL)
         {
           fprintf(stderr, "Unable to allocate memory!\n");
           exit(1);
         }

         CopyToNode(item, pnew);

         pnew->next = NULL;

         if (QueueIsEmpty(pq))
           pq->front = pnew; // 项位于首列顶端
         else
           pq->rear->next = pnew; // 记录队列尾端的位置
         pq->items++; // 队列项数加 1

         return true;
       }
     #+end_src

     ~CopyToNode()~ 函数是静态函数, 用于把项拷贝到节点中:
     #+begin_src c
       static void CopyToNode(Item item, Node* pn)
       {
         pn->item = item;
       }
     #+end_src

     从队列的首端删除项, 涉及以下几个步骤:
     #+begin_src c
       bool DeQueue(Item* pitem, Queue* pq)
       {
         Node* pt;

         if (QueueIsEmpty(pq))
           return false;

         CopyToItem(pq->front, pitem);

         pt = pq->front;
         pq->front = pq->front->next;
         free(pt);

         pq->items--;

         if (pq->items == 0)
           pq->rear = NULL;
         return false;
       }
     #+end_src

     关于指针要注意两点. 第一, 删除最后一项时, 代码并未显示设置 front 指针为
     ~NULL~, 因为已经设置 ~front~ 指针指向被删除节点的 next 指针就为 ~NULL~. 第
     二, 代码使用临时指针(pt) 储存待删除节点的位置. 因为指向首节点的正式指针, 程
     序就不知道该释放哪块内存.

     我们使用 ~DeQueue()~ 函数清空队列. 循环调用 ~DeQueue()~ 函数直到队列为空: 
     #+begin_src c
       void EmptyTheQueue(Queue* pq)
       {
         Item dummy;
         while (!QueueIsEmpty(pq))
           DeQueue(&dummy. pq);
       }
     #+end_src

     注意: *保持纯正* 的 ADT

     定义 ADT 接口后, 应该只使用用接口函数处理数据类型. eg: ~Dequeue()~ 依赖
     ~EnQueue()~ 函数来正确设置指针和把 ~rear~ 节点的 ~next~ 指针设置为 ~NULL~.
     如果在一个使用 ADT 的程序中, 决定直接操控队列的某些部分, 有可能破坏接口包中
     函数直接的协作关系.

     ~queue.c~ 演示了该接口中的所有函数, 包括 ~EnQueue()~ 函数中用到的
     ~CopyToItem()~ 函数

*** 测试队列
    在重要的程序中使用一个新的设计(eg: 队列包)之前, 应该先测试该设计. 测试的一种
    方法是, 编写一个小程序. 这样的程序称为 *驱动程序(driver)*, 其唯一的用途是进
    行测试. eg: ~use_q.c~ 使用一个添加和删除整数的队列. 在运行该程序之前, 要确保
    ~queue.h~ 中包含下面这行代码:
    #+begin_src c
      typedef int item;
    #+end_src

    *注意*: *必须连接* ~queue.c~ 和 ~use_q.c~
** 用队列进行模拟
   经过测试, 队列没问题. 现在, 我们用它来做一些有趣的事情. 许多现实升华的情形都
   设计队列. eg: 在银行或超市的顾客队列, 机场的飞机队列, 多任务计算机系统中的任
   务队列等. 我们可以用队列包来模拟这些情形.

   假设 Sigmund Landers 在商业街设置了一个提供建议的摊位. 顾客可以购买 1分钟, 2
   分钟或 3分钟的简易. 为确保交通畅通, 商业街规定每个摊位前排队等待的顾客最多为
   10 人(相当于程序中的最大队列长度). 假设顾客都是随机出现的, 并且他们花在咨询上
   的时间也是随机选择的(1 分钟, 2 分钟, 3 分钟). 那么 Sigmund 平均每小时要借贷多
   少名顾客? 每位顾客平均要花多长时间? 排队等待的顾客平均有多少人? 队列模拟能回
   答类似的问题.

   首先, 要确定在队列中放什么. 可以根据顾客加入队列的事件和顾客咨询时花费的事件
   来描述每一位顾客. 因此, 可以这样定义 Item 类型:
   #+begin_src c
     typedef struct item
     {
       long arrive; // 一位顾客加入队列的事件
       int processtime; // 该顾客咨询时花费的时间
     } Item;
   #+end_src

   要用队列包来处理这个结构, 必须用 ~typedef~ 定义的 Item 替换上一个示例的 int
   类型. 这样做就不必担心队列的具体工作机制, 可以集中精力分析实际问题, 即模拟咨
   询 Sigmund 的顾客队列.

   这里有一种方法, 让时间以 1 分钟为单位递增. 没递增一分钟, 就检查是否有新顾客到
   来. 如果有一位顾客且队列未满, 将该顾客添加到队列中. 这涉及把顾客到来的事件和
   顾客所需的咨询时间记录在 Item 类型的结构中, 然后在队列中添加该项. 然而, 如果
   队列已满, 就让这位顾客离开. 为了做统计, 要记录顾客的总数和被拒顾客(队列已满不
   能加入队列的人)的总数.

   接下来, 处理队列的首端. 也就是说, 如果队列不为空且前面的顾客没有在咨询
   Sigmund, 则删除队列首端的项. 记住, 该项中储存着这位顾客加入队列的时间, 把该时
   间与当前时间作比较, 就可得出该顾客在队列中等待的时间. 该项还存储着这位顾客需
   要咨询的分钟数, 即还要咨询 Sigmund 多长时间, 因此要需要一个变量储存这个时长.
   如果 Sigmund 正忙, 则不用让任何人离开队列. 尽管如此, 记录等待时间的变量应该递
   减 1.

   核心代码类似如下, 每一轮迭代对应一分钟的行为:
   #+begin_src c
     for (cycle = 0; cycle < cyclelimit; cycle++)
     {
       if (newcustomer(min_per_cus))
       {
         if (QueueIsFull(&line))
           turnaways++;
         else {
           customers++;
           temp = customertime(cycle);
           EnQueue(temp, &line);
         }
       }

       if (wait_time <= 0 && !QueueIsEmpty(&line))
       {
         DeQueue(&temp, &line);
         wait_time = temp.processtime;
         line_wait += cycle - temp.arrive;
         served++;
       }

       if (wait_time > 0)
         wait_time--;

       sum_line +=QueueItemCount(&line);
     }
   #+end_src

   *注意*: 时间的表示比较粗糙(1 分钟), 所以一小时最多 60 位顾客. 下面是一些变量
    和函数的含义. 
    
    - min_per_cus: 顾客到达的平均间隔时间
    - ~newcustomer()~: 使用 C 的 ~rand()~ 函数确定在特定时间内是否有顾客到来
    - turnaways: 被拒绝的顾客数量
    - customers: 加入队列的顾客数量
    - temp: 新顾客的 Item 类型变量
    - ~customertime()~: 设置 temp 结构中的 arrive 和 processtime 成员
    - wait_time: Sigmund 完成当前顾客的咨询还需多长时间
    - line_wait: 到目前为止队列中所有顾客的等待总时间
    - served: 咨询过 Sigmund 的顾客数量
    - sum_line: 到目前为止统计的队列长度

      
    如果到处都是 ~malloc()~, ~free()~ 和指向节点的指针, 整个程序代码会非常混乱和
    晦涩. 队列包让你把注意力集中在模拟问题上, 而不是编程细节上.

    ~mall.c~ 演示了 模拟商业街咨询摊位队列的完整代码. 根据第 12 章介绍的方法, 使
    用标准函数 ~rand()~, ~srand()~, 和 ~time()~ 来产生随机数. 另外要特别注意, 必
    须用下面的代码更新 ~queue.h~ 中的 Item, 该程序才能正常工作:
    #+begin_src c
      typedef struct item
      {
        long arrive; // 一位顾客加入队列的时间
        int processtime; // 该顾客咨询时花费的事件
      } Item;
    #+end_src

    记住, 还要把 ~mall.c~ 和 ~queue.c~ 一起链接

    该程序允许用户指定模拟允许的小时数和每小时平均有多少位顾客. 模拟时间较长得出
    的值较为平均, 模拟时间较短得出的值随时间的变化而随机变化. 下面的运行示例解释
    了这一点(先保持每小时的顾客平均数量不变). *注意*: 在模拟 80 小时和 800 小时
    的情况下, 平均队伍长度和等待时间基本相同, 但是, 在模拟一小时的情况下这两个量
    差别很大, 而且与长时间模拟的情况差别也很大. 这是因为小数量的统计样本更容易受
    相对变化的影响.

    *注意*: 随着每小时顾客的平均数量增加, 顾客的平均等待时间迅速增加. 在每小时
     20 位顾客(80 小时模拟时间)的情况下, 每位顾客的平均等待时间是 1.35 分钟; 在
     每小时 25 位顾客的情况下, 平均等待时间增加至 3.50 分钟; 在每小时 30 位顾客
     的情况下, 该数值攀升至 11.83 分钟. 而且, 这三种情况下被拒顾客分别从 0 位增
     加至 3 位最后徒增至 94 位. Sigmund 可以根据程序模拟的结果决定是否要增加一个
     摊位.
** 链表和数组
   许多编程问题, 如创建一个简单链表或队列, 都可以用链表(指的是动态分配结构的序列
   链)或数组来处理. 每种形式都有其优缺点, 所以要根据具体问题的要求来决定选择哪一
   种形式. 下表总结了链表和数组的性质:
   | 数据形式 | 优点                               | 缺点                                   |
   |----------+------------------------------------+----------------------------------------|
   | 数组     | C直接支持, 提供随机访问            | 在编译时确定大小, 插入和删除元素很费时 |
   | 链表     | 运行时确定大小, 快速插入和删除元素 | 不能随机访问, 用户必须提供编程支持     |

   详细分析插入和删除元素的过程: 在数组中插入元素, *必须* 移动其他元素腾出空位插
   入新元素. 新插入的元素离数组开头越近, 要被移动的元素越多. 然而, 在链表中插入
   节点, 只需给 2 个指针复制. 类似地, 从数组中删除一个元素, 也需要移动许多相关的
   元素. 但是从链表中删除节点, 只需重新设置一个指针并释放被删除节点占用的内存即
   可.

   考虑如何访问元素: 对数组而言, 可以使用数组下表直接访问数组中的任意元素, 这叫
   做 *随机访问(random access)*. 对链表而言, 必须从链表首节点开始, 逐个节点移动
   到要访问的节点, 这叫做 *顺序访问(sequential access)*. 当然, 也可以顺序访问数
   组. 只需按顺序递增数组下标即可. 在某些情况下, 顺序访问足够了. eg: 要显示链表
   中的每一项, 顺序访问就不错. 其他情况用随机访问更合适.

   假设要查找链表中的特定项. 一种算法是从列表的开头开始按顺序查找, 这叫做 *顺序
   查找(sequential search)*. 如果项并未按某种顺序排列, 则只能顺序查找. 如果待查
   找的项不在链表里, 必须查找完所有的项才知道该项不在链表中(在这种情况下可以使用
   并发编程, 同时查找列表中的不同部分).

   我们可以先排序列表, 以改进顺序查找. 这样, 就不必查找排在待查找项后面的项. eg:
   假设在一个按字母排序的列表中查找Susan. 从开头开始查找每一项, 知道 Sylvia 都没
   有查找到 Susan. 这时就可以退出查找, 因为如果 Susan 在列表中, 应该排在 Sylvia
   前面. 平均下来, 这种方法查找不在列表中的项的时间减半.

   对于一个排序的列表, 用 *二分查找(binary search)* 比顺序查找好得多. 

   二分查找原理: 首先把待查找的项称为目标项, 而且假设列表中的各项按字母排序. 然
   后, 比较的中间项和目标项. 如果相等, 查找结束; 假设目标项在列表中, 如果中间项
   排在目标项前面, 则目标项一定在后半部分项中; 无论哪种情况, *两项比较的结果都确
   定了下次查找的范围只有列表的一半*. 不断使用此方法, 一般而言, n 次比较能处理有
   2^n - 1 个元素的数组. 所以项数越多, 越能体现二分查找的优势.

   用数组实现二分查找很简单, 因为可以使用数组下标确定数组中任意部分的 *中点*. 只
   要把数组的首元素和尾元素的索引相加,得到的和再除以 2 即可. eg: 内含 100 个元素
   的数组, 首元素下表是 0, 尾元素下表是 99, name用于首次比较的中间项的下表应为
   (0 + 99) / 2, 得 49(整数除法). 这体现了随机访问的特性, 可以从一个位置跳到另
   一个位置, *不用一次访问两位置直接的项*. 但是, 链表 *只支持顺序访问*, 不提供跳
   转至中间节点的方法. 所以在链表中 *不能使用二分查找*.

   如前所述, *选择何种数据类型取决于具体问题*. 如果因频繁地插入和删除项导致经常
   调整大小, 而且不需要经常查找, 选择链表会更好. 如果只是偶尔插入或删除项, 但是
   经常进行查找, 使用数组会更好.

   如果需要一种 *既支持频繁插入和删除项*, *又支持频繁查找* 的数据形式, 数组和链
   表都无法胜任, 这种情况下应该选择 *二叉查找树*.
