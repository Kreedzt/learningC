* 高级数据表示
  本章介绍以下内容

  - 函数: 进一步学习 ~malloc()~
  - 使用 C 表示不同类型的数据
  - 新的算法, 从概念上增强开发程序的成立
  - 抽象数据类型(ADT)
    
    本章重点介绍如何把项目看作一个整体.

    从程序设计的关键部分开始, 即数据表示方式. 程序开发最重要的部分是 *找到程序中
    表示数据的好方法*, 正确地表示数据可以更容易地编写程序其余部分. 到目前为止,
    应该熟悉的内置类型: 简单变量, 数组, 指针, 结构和联合

    找出正确的数据不仅仅是一种数据类型, 还要必须考虑进行哪些操作. 必须确定 *如何
    存储数据*, 并且为数据类型 *定义有效的操作*.
    
    eg: C 实现通常把 int 类型和指针类型都储存为整数, 但是这两种类型的有效操作不
    相同. 
    eg: 两个整数可以相乘, 但是 *指针不能相乘*; 可以用 ~*~ 运算符解引用指针, 但是
    对整数这样做毫无意义. C 语言为它的基本类型都定义了有效的操作. 但是, 当要涉及
    数据表示的方案时, 可能需要自己定义有效操作.

    C 语言中, 可以把所需的操作设计成 C 函数来表示. 
    简而言之, 设计一种数据类型包括设计如何储存该数据类型和设计一系列管理该数据的函数

    本章还会介绍一些算法, 即 *操控数据* 的方法. 应该掌握这些可以反复解决类似问题
    的处理方法.

    本章将进一步研究设计数据类型的过程, 这是一个把算法和数据表示相匹配的过程. 期
    间会用到一些常见的数据形式, 如队列, 列表和二叉树.

    本章还将介绍 *抽象数据类型(ADT)* 的概念. 抽象数据类型以面向问题而不是面向语
    言的方式, 把解决问题的方法和数据表示结合起来. 设计一个 ADT 后, 可以在不同的
    环境中复用. 理解 ADT 可以为将来学习面向对象程序设计(OOP) 以及 C++ 语言做好准
    备

** 研究数据表示
   假设要创建一个地址薄程序. 应该使用什么数据形式存储信息? 由于储存的每一项都包
   含多种信息, 用结构来表示每一项合适. 如何表示多个项? 是否用标准的结构数组? 还
   是动态数组? 还是一些其他形式? 各项是否按字母顺序排列? 是否要按照邮政编码(或 id
   去编码) 查找各项? 需要执行的行为将如何存储信息? 简而言之, 在开始编写代码之前,
   要在程序设计方面做很多决定

   如何表示储存在内存中的位图图像? 位图图像中的每个像素在屏幕上都单独设置. 在以
   前的黑白屏的年代, 可以使用一个计算机位(1 或 0)来表示一个像素点(开或关), 因此
   称之为位图. 对于彩色显示器而言, 如果 8 位表示一个像素, 可以得到 256 种颜色.
   现在行业标准已经发展到 65536 色(每像素 16 位), 16777216 色(每像素 24 位),
   2147483 色(每像素 32 位), 甚至更多. 如果有 32 位色, 且显示器有 2560 * 1440 的
   分辨率, 则需要将近 1.18 亿位(14 M) 来表示一个屏幕的位图图像. 是用这种方法表示,
   还是开发一种压缩信息的方法? 是有损压缩(丢失相对次要的数据) 还是无损压缩(没有
   丢失数据)? 开始编写代码之前, 需要做很多程序设计方面的决定

   来处理一个数据表示的示例. 假设要编写一个程序, 让用户输入一年内看过的所有电影
   (包括 DVD 和 蓝光光碟). 要储存每部影片的各种信息, eg: 片名, 发行年份, 导演,
   主演, 片长, 影片的种类(喜剧, 科幻, 爱情等), 评级等. 建议使用一个结构储存每部
   电影, 一个数组储存一年内看过的电影. 为简单起见, 我们规定结构中只有 2 个成员:
   片名和评级(0 ~ 10). ~films1.c~ 演示了一个基本的实现

   该程序创建了一个结构数组, 然后把用户输入的数据储存在数组中. 直到数组已满(用
   FMAX 判断)或者达到结尾(~NULL~ 判断), 或者用户首行按下 ENTER(用 ~'\0'~ 判断),
   输入才会终止

   这样设计程序有问题. 首先, 该程序可能会浪费许多 *空间*, 因为大部分的片名都不会
   超过 40 个字符. 但是, 有的片名的确很长. 其次, 许多人会觉得每年 5 部电影的限制
   太严格, 放宽多大才合适? 很可能浪费大量内存. 一些编译器对自动存储类别的变量
   (eg: movies)可用的内存数量设置了一个默认的限制, 大型的数组可能会超过默认设置
   的值. 可以把数组声明为 *静态* 或 *外部数组*, 或者设置编译器使用更大的栈来解决
   这个问题. 但是这样做 *并不能解决根本问题*.

   该程序真正的问题是, 数据表示 *不太灵活*. 程序在编译时确定所需内存量, 改成运行
   时会更好.

   #+begin_src c
     #define TSISE 45

     struct film {
       char title[TSIZE];
       int rating;
     };

     // ...

     int n, i;
     struct film* movies; // 指向结构的指针

     // ...

     printf("Enter the maximum number of movies you'll enter:\n");
     scanf("%d", &n);

     movies = (struct film*)malloc(n * sizeof(struct film));
   #+end_src

   使用 ~malloc()~, 可以推迟到程序运行时才确定数组中的元素数量. 所以, 如果只需要
   20 个元素, 就不必分配 500 个元素的空间. ong 付要为元素个数提供正确的值

** 从数组到链表
   理想的情况是, 用户可以不确定地添加数据(或者不断添加数据知道用完内存量), 而不
   是先指定要输入多少项, 也不用让程序分配多余的空间. 这可以通过在输入每一项后调
   用 ~malloc()~ 分配正好能储存该项的空间. 如果用户输入 3 部影片, 程序就调用
   ~malloc()~ 3 次; 如果用户输入 300 部 影片, 程序就调用 ~malloc()~ 300 次. 

   比较: 一种方法是调用 ~malloc()~ 一次, 为 300 个 ~film~ 结构请求分配足够的空
   间. 前者分配的是连续的内存块, 只需要一个单独的指向 ~struct~ 变量(film) 的指针,
   该指针指向已分配块中的第一个结构. 简单的数组表示法让指针访问块中的每个结构,
   如前面的代码所示. 第二种方法的问题是, 无法保证每次调用 ~malloc()~ 都能分配到
   连续的内存块. 这意味着结构不一定被连续储存. 因此, 与第一种方法储存一个指向
   300 个结构块的指针相比, 需要储存 300 个指针, 每个指针指向一个单独储存的结构

   两种方法: 
   1. 一种解决方法是创建一个大型的指针数组, 并在分配新结构时逐个给这些指针赋值:
      #+begin_src c
        #define TSIZE 45
        #define FMAX 500

        struct film {
          char title[TSIZE];
          int rating;
        };

        // ...

        struct film* movies[FMAX]; // 结构指针数组

        int i;

        // ...

        movies[i] = (struct film*)malloc(sizeof(struct fiml));

      #+end_src

      如果用不完 500 个指针, 这种方法节约了大量的内存, 因为内含 500 个指针的数组
      比内含 500 个结构的数组所占的内存少的多. 尽管如此, 如果用不到 500 个指针,
      还是浪费了不少空间. 而且, 这样还是有 500 个结构的限制.

   2. 更好的方法: 每次使用 ~malloc()~ 为新结构分配空间时, 也为新指针分配空间. 但
      是还得需要另一个指针来跟踪新分配的指针, 用于跟踪新指针的指针本身, 也需要一
      个指针来跟踪. 以次类推. 要重新定义结构材料解决这个潜在的问题, 即每个结构中
      包含指向 next 结构的指针. 然后, 当创建新结构时, 可以把该结构的地址储存在上
      一个结构中. 简而言之, 可以这样定义 ~film~ 结构:

      #+begin_src c
        #define TSIZE 45

        struct fiml {
          char title[TSIZE];
          int rating;
          struct film* next;
        }
      #+end_src

      虽然结构不能含有与自身类型相同的结构, 但是可以含有指向同类型结构的指针. 这
      种定义是 *链表(linked list)* 的基础,链表中的每一项都包含着在何处能找到下一
      项的信息.

      概念上理解链表: 假设用户输入片名 Modern Times, 等级为 10. 程序将为 film 类
      型结构分配空间, 把字符串 Modern Times 拷贝到结构中的 title 成员中, 然后设
      置 rating 成员为 10. 为了表明该结构后面没有其他结构, 程序要把 next 成员指
      针设置为 ~NULL(符号常量, 表示空指针)~. 当然, 还需要一个单独的指针储存第一
      个结构的地址, 该指针被称为 *头指针(head pointer)*. 头指针指向链表中的第一
      项. 

      #+begin_src c
        #define TSIZE 45

        struct film {
          char title[TSIZE];
          int rating;
          struct film* next;
        };

        struct film* head;
      #+end_src
      
      现在, 假设用户输入第二部电影及其评级, 如 Midnight in Paris 和 8. 程序为第
      二个 film 类型结构分配空间, 把新结构的地址储存在第一个结构的 next 成员中
      (擦写了之前储存在该成员中的 NULL), 这样链表中第一个结构中的 next 指针指向
      第二个结构. 然后程序把 Midnight in Parais 和 8 拷贝到新结构中, 并把第二个
      结构中的 next 成员设置为 NULL, 表明该结构是链表中的最后一个结构

      没加入一部新电影, 就以相同的方式来处理. 新结构的地址将储存在上一个结构中,
      新信息储存在新结构中, 而且新结构中的 next 成员设置为 NULL

      假设要显示这个链表, 每显示一项, 就可以根据该项中已储存的地址来定义下一个待
      显示的项. 然而, 这种方法能正常余晓玲, 还需要一个指针储存链表中第一项的地址,
      因为链表中没有其他项储存该项的地址. 此时, 头指针就派上了用场.

**** 使用链表
     实现: ~film2.c~

     该程序用链表执行 2 个任务: 第一个任务是: 构造一个链表, 把用户输入的数据储存
     在链表中. 第二个任务是: 显示链表. 显示链表的任务比较简单

     1. 显示链表
        显示链表从设置一个指向第一个结构的指针(名为 current) 开始. 由于头指针(名
        为 head)已经指向链表中的第一个结构, 所以可以用下面的代码来完成
        #+begin_src c
          current = head;
        #+end_src

        然后, 可以使用指针表示法访问结构的成员:
        #+begin_src c
          printf("Movie: %s Rating: %d\n", current->title, current->rating);
        #+end_src

        完成这些之后, 在重复整个过程, 但显示到链表中最后一个项时, ~current~ 将被
        设置为 ~NULL~, 因为这是链表最后一个结构中 next 成员的值
        #+begin_src c
          while (current != NULL)
          {
            printf("Movie: %s Rating: %d\n", current->title, current->rating);
            current = current->next;
          }
        #+end_src

        遍历链表时, 需要创建一个新的指针, 直接使用 head 会改变 head 的值, 导致程
        序还找不到链表的开始处

     2. 创建链表
        步骤:
        1) 使用 ~malloc()~ 为结构分配足够的空间
        2) 储存结构的地址
        3) 把当前信息拷贝到结构中

        如无必要不要红创建一个结构, 所以程序使用临时存储区(input 数组) 获取用户
        输入的电影名. 如果用户通过键盘模拟 ~EOF~ 或输入一行空行, 将退出下面的循
        环:
        #+begin_src c
          while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
        #+end_src

        如果用户进行输入, 程序就分配一个结构的空间, 并将其地址赋给指针变量
        current:
        #+begin_src c
          current = (struct film*)malloc(sizeof(struct film));
        #+end_src

        链表中第一个结构的地址应储存在指针变量 head 中. 随后每个结构的地址应储存
        在其前一个结构的 next 成员中. 因此, 程序要知道它处理的是否是第一个结构.
        最简单的方法是在程序开始时, 把 head 指针初始化为 NULL. 然后, 程序可以使
        用 head 的值进行判断:
        #+begin_src c
          if (head == NULL)
          {
            head = current;
          }
          else
          {
            prev->next = current;
          }
        #+end_src

        指针 prev 指向上一次分配的结构.
        
        接下来, 必须为结构成员设置合理的值. 尤其是: 把 next 成员设置为 NULL, 表
        明当前结构是链表的最后一个结构. 还要把 input 数组中的电影名拷贝到 title
        成员中, 而且要给 rating 成员赋值:
        #+begin_src c
          current->next = NULL;
          strcpy(current->title, input);
          puts("Enter your rating <0-10>:");
          scanf("%d", &current->rating);
        #+end_src

        由于 ~s_gets()~ 限制了只能输入 ~TSIZE-1~ 个字符, 所以用 ~strcpy()~ 函数
        把 input 数组中的字符串拷贝到 title 成员很安全

        最后, 要为下一次输入做好准备. 尤其要设置 prev 指向当前结构. 因为在用户输
        入下一步电影且成员为新结构分配空间后, 当前结构将成为新结构的上一个结构,
        所以程序在循环末尾这样设置指针:
        #+begin_src c
          prev = current;
        #+end_src
        
     3. 释放链表
        在许多环境中, 程序结束时都会自动释放 ~malloc()~ 分配的内存. 但是, 最好还
        是成对调用 ~malloc()~ 和 ~free()~. 因此, 程序在清理内存时为每个已分配的
        结构都调用了 ~free()~ 函数:
        #+begin_src c
          current = head;

          while (current != NULL) {
            current = head;
            head = current->next;
            free(current);
          }
        #+end_src

        
**** 反思
     ~film2.c~ 程序还有些不足. eg: 程序没有检查 ~malloc()~ 是否成功请求到内存,
     也无法删除链表中的项. 这些不足可以弥补. eg: 添加代码检查 ~malloc()~ 的返回
     值是否是 ~NULL~ (返回 NULL 说明未获得所需内存). 如果程序要删除链表 中的项,
     还要编写更多的代码.

     这种用 *特定方法解决特定问题*, 并且在需要时才添加相关功能的变成方式通常不是
     最好的解决方案. 另一方面, 通常都无法预料程序要完成的所有任务. 随着编程项目
     越来越大, 一个程序员或编程团队事先计划好一切模式, 越来越不现实. 很多成功的
     大型程序都是由成功的小型程序逐步发展而来.

     如果要修改程序, 首先应该强调最初的设计, 并简化其他细节. ~film2.c~ 中的程序
     示例没有遵循这个原则, 它把概念模型和代码细节混在一起. eg: 该程序的概念模型
     是在一个链表中添加项, 但是程序却把一些细节(eg: ~malloc()~ 和
     ~current->next~ 指针)放在 *最明显* 的位置, 没有 *突出接口*. 如果程序能以某
     种方式强调给链表添加项, 并隐藏具体的处理细节(如调用内存管理函数和设置指针)
     会更好. 把 *用户接口和代码细节分开的程序, 更容易理解和更新*.
** 抽象数据类型(ADT)
   在编程时, 应该根据编程问题匹配合适的数据类型. eg: 用 ~int~ 类型代表你有多少双
   鞋, 用 ~float~ 或 ~double~ 类型代表每双鞋的价格. 在前面的电影示例中, 数据构成
   了链表, 每个链表项由电影名 (C 字符串) 和评级 (一个 int 类型的值). C 中没有与
   之匹配的基本类型, 所以我们定义了一个结构代表单独的项, 然后设计了一些方法把一
   系列结构构成一个链表. 本质上, 我们使用 C 语言的功能设计了一种符合程序要求的新
   数据类型. 但是并 *不系统*. 现在, 我们用更系统的方法来定义数据类型

   *注意*: 整数属性

   C 的 ~int~ 类型背后是一个更抽象的整数概念. 数学家已经用正式的抽象方式定义了整
   数的属性. eg: N 和 M 是整数, 那么 ~N+M=M+N~; 假设 S, Q 也是整数, 如果
   ~N+M=S~, 而且 ~N+Q=S~, 那么 ~M=Q~. 可以认为数学家提供了整数的抽象概念, 而 C
   则实现了这一抽象概念. *注意*: 实现整数的算术运算是表示整数必不可少的部分. 如
   果只是储存值, 并未在算术表达式中使用, ~int~ 类型就没那么有用了. 还要注意的是,
   C 并未很好地实现整数. eg: 整数是无穷大的数, 但是 2 字节的 int 类型只能表示
   65536 个整数. 因此, *不要混淆抽象概念和具体的实现*

   假设要定义一个新的数据类型. 首先, 必须提供储存数据的方法, eg: 设计一个结构.
   其次, 必须提供操控数据的方法. eg: 考虑 ~films2.c~ 程序. 该程序用链接的结构来
   储存信息, 并且通过代码实现了如何添加和显示信息. 尽管如此, 该程序并未清楚地表
   明正在创建一个新类型. 做法:

   计算机科学领域已开发了一种定义新类型的好方法, 用 3 个步骤完成从抽象到具体的
   过程:

   1. 提供类型属性和相关操作的抽象描述. 这些描述既不能依赖特定的实现, 也不能依赖
      特定的编程语言. 这种正式的抽象描述被称为抽象数据类型(ADT)

   2. 开发一个实现 ADT 的编程接口. 也就是说, 指名如何储存数据和执行所需操作的函
      数. eg: 在 C 中, 可以提供结构定义和操控该结构的函数原型. 这些作用于用户定
      义类型的函数相当于作用与 C 基本类型的内置运算符. 需要使用该新类型的程序员
      可以使用这个接口进行编程

   3. 编写代码实现接口. 这一步至关重要, 但是使用该新类型的程序员无需了解具体的实
      现细节.
** 队列ADT
   在 C 语言中使用抽象数据类型方法编程包含以下 3 个步骤:
   1. 以抽象, 通用的方式描述一个类型, 包括该类型的操作
   2. 设计一个函数接口表示这个新类型
   3. 编写具体代码实现这个接口

   前面已经把这种方法应用到简单链表中. 现在, 把这种方法应用于更复杂的数据类型:
   队列.   

*** 定义队列抽象数据类型
    *队列(queue)是具有两个特殊属性的链表*: 第一: 新项只能添加到链表的末尾. 从这
     方面看, 队列与简单链表类型. 第二, 只能从链表的开头移除项. 可以把队列想象成
     排队买票的人. 你从队尾加入队列, 买完票后从对首离开. 队列是一种 *先进先出*
     (first in, first out, 缩写为 FIFO) 的数据形式, 就像在排队买票的队伍一样(前
     提是没有人插队). 接下来, 建立一个非正式的抽象定义:
     
     #+begin_example
       类型名: 队列
       类型属性: 可以储存一系列项
       类型操作: 初始化队列为空
       确定队列为空
       确定队列已满
       确定队列中的项数
       在队列末尾添加项
       在队列开头删除或恢复项
       清空队列
     #+end_example

*** 定义一个接口
    接口定义放在 ~queue.h~ 文件中. 我们使用 C 的 ~typedef~ 工具创建两个类型名:
    Item 和 Queue. 相应结构的具体实现应该是 ~queue.h~ 文件的一部分, 但是从概念上
    来看, 应该在实现阶段才设计结构. 现在, 只是假定已经定义了这些类型, 着重考虑函
    数的原型.

    首先, 考虑初始化. 这涉及改变 Queue 类型, 所以该函数应该以 Queue 的地址作为参
    数: 
    #+begin_src c
      void InitializeQueue(Queue* pq);
    #+end_src

    接下来, 确定队列是否为空或已满的函数应返回真或假值. 这里, 假设 C99 的
    ~stdbool.h~ 头文件可用, 如果该文件不可用, 可以使用 ~int~ 类型或自己定义
    ~bool~ 类型. 由于该函数不更改队列, 所以接受 Queue 类型的参数. 但是, 传递
    Queue 的地址更快, 更节省内存. 这样做的好处是: 所有的函数都以地址作为参数. 为
    了表明这些函数不更改队列, 可以且应该使用 ~const~ 限定符:
    #+begin_src c
      bool QueueIsFull(const Queue* pq);
      bool QueueIsEmpty(const Queue* pq);
    #+end_src

    指针 pq 指向 Queue 数据对象, 不能通过 pq 这个代理更改数据. 可以定义一个类似
    该函数的原型, 返回队列的项数:
    #+begin_src c
      int QueueItemCount(const Queue* pq);
    #+end_src

    在队列末尾添加项设计标识项和队列. 这次要更改队列, 所以有必要(而不是可选)使用
    指针. 该函数的返回类型可以是 ~void~, 或者通过返回值来表示是否成功添加项. 我
    们采用后者:
    #+begin_src c
      bool EnQueue(Item item, Queue* pq);
    #+end_src
    最后, 删除项有多种方法. 如果把该项定义为结构或一种基本类型, 可以通过函数返回
    待删除的项. 函数的参数可以是 Queue 类型或指向 Queue 的指针. 因此, 可以是下面
    这样的原型:
    #+begin_src c
      Item DeQueue(Queue q);
    #+end_src

    然而, 下面的原型会更合适一些:
    #+begin_src c
      bool DeQueue(Item* pitem, Queue* pq);
    #+end_src

    从队列中待删除的项储存在 pitem 指针指向的位置, 函数的返回值表明是否删除成功

    清空队列的函数所需的唯一参数是队列的地址, 可以使用下面的函数原型:
    #+begin_src c
      void EmptyTheQueue(Queue* pq);
    #+end_src

    
*** 实现接口数据表示
    第一步是确定在队列中使用何种 C 数据形式. 有可能是数组. 数组的优点是方便使用,
    而且向数组的末尾添加项很简单. 问题是如果从队列的开头删除项. 类比于排队买票的
    队列, 从队列的开头删除一个项包括拷贝数组首元素的值和把数组剩余各项依次向前移
    动一个位置. 编程实现这个过程很简单, 但是会浪费大量的计算机时间.

    第二种解决数组队列删除问题的方法是改变队列首端的位置, 其余元素不动.

    解决这种问题的一个好方法是, 使队列成为环形, 这意味着把数组的首尾相连, 即数组
    的首元素紧跟在最后一个元素后面. 这样, 当到达数组末尾时, 如果首元素空出, 就可
    以把新添加的项储存到这些空出的元素中. 可以想象在一张条形的纸上画出数组, 然后
    把数组的末尾首尾粘起来形成一个环. 当然, 要做一些标记, 以免尾端超过首端.

    另一种方法是使用链表. 使用链表的好处是删除首项时不必移动其余元素, 只需重置头
    指针指向新的首元素即可. 由于我们已经讨论过链表, 所以采用这个方法. 我们用一个
    整数队列开始测试:
    #+begin_src c
      typedef int Item;
    #+end_src

    链表由节点组成, 所以, 下一步是定义节点:
    #+begin_src c
      typedef struct node
      {
        Item item;
        struct node* next;
      } Node;
    #+end_src

    对队列而言, 要保存首尾项, 这可以使用指针来完成. 另外, 可以用一个计数器来记录
    队列中的项数. 因此, 该结构应由两个指针成员和一个 int 类型的成员构成:
    #+begin_src c
       typedef struct queue
       {
         Node* front; // 指向队列首项的指针
         Node* rear; // 指向队列尾项的指针
         int items; // 队列中的项数
       } Queue;
    #+end_src

    注意: Queue 是一个内含 3 个成员的结构, 所以用指向队列的指针作为参数比直接用
    队列作为参数节约了时间和空间

    接下来, 考虑队列的大小. 对链表而言, 其大小受限于可用的内存量, 因此链表不要太
    大. eg: 可能使用一个队列模拟飞机等待在机场着陆. 如果等待的飞机数量太多, 新到
    的飞机就应该改到其他的机场降落. 我们把队列的最大程度设为 10. ~queue.h~ 包含
    了队列接口的原型和定义. Item 类型留给用户定义. 使用该接口时, 可以根据特定的
    程序插入合适的定义.

**** 实现接口函数
     接下来, 我们编写接口代码. 首先, 初始化队列为空, 这里 "空" 的意思是指把指向
     队列的首项和尾项的指针设置为 ~NULL~, 并把项数(items 成员) 设置为 0:
     #+begin_src c
       void InitializeQueue(Queue* pq)
       {
         pq->front = pq->rear = NULL;
         pq->items = 0;
       }
     #+end_src

     这样, 通过检查 items 的值可以很方便地了解队列是否已满, 是否为空和确定队列的
     项数:
     #+begin_src c
       bool QueueIsFull(const Queue* pq)
       {
         return pq->items == MAXQUEUE;
       }

       bool QueueIsEmpty(const Queue* pq)
       {
         return pq->items == 0;
       }

       int QueueItemCount(const Queue* pq)
       {
         return pq->items;
       }
     #+end_src

     把项添加到队列中, 包括以下几个步骤:
     1. 创建一个新节点
     2. 把项拷贝到节点中
     3. 设置节点的 next 指针为 ~NULL~, 表明该节点是最后一个节点
     4. 设置当前尾节点的 next 指针指向新节点, 把新节点链接到队列中
     5. 把 rear 指针指向该节点, 以便找到最后的节点
     6. 项数加 1

        
     函数还要处理 2 种特殊情况. 第一种情况: 如果队列为空, 应该把 front 指针设置
     为指向新节点. 因为如果队列中只有一个节点, 那么这个节点既是首节点也是尾节点.
     第二种情况是: 如果函数不能为新节点分配所需的内存, 则必须执行一些动作. 因为
     大多数情况下我们都使用小型队列, 这种情况很少发生, 所以, 如果程序运行的内存
     不足, 我们只是通过函数终止程序.

     ~EnQueue()~ 的代码如下:
     #+begin_src c
       bool EnQueue(Item item, Queue* pq)
       {
         Node* pnew;
         if (QueueIsFull(pq))
           return false;

         pnew = (Node*)malloc(sizeof(Node));

         if (pnew == NULL)
         {
           fprintf(stderr, "Unable to allocate memory!\n");
           exit(1);
         }

         CopyToNode(item, pnew);

         pnew->next = NULL;

         if (QueueIsEmpty(pq))
           pq->front = pnew; // 项位于首列顶端
         else
           pq->rear->next = pnew; // 记录队列尾端的位置
         pq->items++; // 队列项数加 1

         return true;
       }
     #+end_src

     ~CopyToNode()~ 函数是静态函数, 用于把项拷贝到节点中:
     #+begin_src c
       static void CopyToNode(Item item, Node* pn)
       {
         pn->item = item;
       }
     #+end_src

     从队列的首端删除项, 涉及以下几个步骤:
     #+begin_src c
       bool DeQueue(Item* pitem, Queue* pq)
       {
         Node* pt;

         if (QueueIsEmpty(pq))
           return false;

         CopyToItem(pq->front, pitem);

         pt = pq->front;
         pq->front = pq->front->next;
         free(pt);

         pq->items--;

         if (pq->items == 0)
           pq->rear = NULL;
         return false;
       }
     #+end_src

     关于指针要注意两点. 第一, 删除最后一项时, 代码并未显示设置 front 指针为
     ~NULL~, 因为已经设置 ~front~ 指针指向被删除节点的 next 指针就为 ~NULL~. 第
     二, 代码使用临时指针(pt) 储存待删除节点的位置. 因为指向首节点的正式指针, 程
     序就不知道该释放哪块内存.

     我们使用 ~DeQueue()~ 函数清空队列. 循环调用 ~DeQueue()~ 函数直到队列为空: 
     #+begin_src c
       void EmptyTheQueue(Queue* pq)
       {
         Item dummy;
         while (!QueueIsEmpty(pq))
           DeQueue(&dummy. pq);
       }
     #+end_src

     注意: *保持纯正* 的 ADT

     定义 ADT 接口后, 应该只使用用接口函数处理数据类型. eg: ~Dequeue()~ 依赖
     ~EnQueue()~ 函数来正确设置指针和把 ~rear~ 节点的 ~next~ 指针设置为 ~NULL~.
     如果在一个使用 ADT 的程序中, 决定直接操控队列的某些部分, 有可能破坏接口包中
     函数直接的协作关系.

     ~queue.c~ 演示了该接口中的所有函数, 包括 ~EnQueue()~ 函数中用到的
     ~CopyToItem()~ 函数

*** 测试队列
    在重要的程序中使用一个新的设计(eg: 队列包)之前, 应该先测试该设计. 测试的一种
    方法是, 编写一个小程序. 这样的程序称为 *驱动程序(driver)*, 其唯一的用途是进
    行测试. eg: ~use_q.c~ 使用一个添加和删除整数的队列. 在运行该程序之前, 要确保
    ~queue.h~ 中包含下面这行代码:
    #+begin_src c
      typedef int item;
    #+end_src

    *注意*: *必须连接* ~queue.c~ 和 ~use_q.c~
