* 第 8 章
  
** 单字符 I/O: getchar()和 putchar()
   getchar()和 putchar()每次只处理一个字符.
   自从 ANSI C 标准发布以后, C 就把 stdio.h 头文件与使用 getchar()和 putchar()相关联
   getchar()和 putchar()都不是真正的函数, 它们被定义为供预处理器使用的宏

** 缓冲区
   - 无缓冲输入: 回显用户输入的字符后立即重复打印该字符, 即正在等待的程序可立即
     使用输入的字符

   - 缓冲输入: 大部分系统在用户按下 Enter 键之前不会重复打印刚输入的字符. 用户输入
     的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区, 按下 Enter 键后, 程
     序才可使用用户输入的字符
     1. 输入的字符被逐个送入缓冲区

     2. 程序可使用缓冲区的内容

        
   缓冲:
   1. 完全缓冲 I/O: 当缓冲区被填满时才刷新缓冲区(内容被发送至目的地), 通常出现在
      文件输入中. 缓冲区的大小取决于系统, 常见的大小是 512 字节和 4096 字节
   2. 行缓冲 I/O: 出现换行符时刷新缓冲区.

      
   ANSI C 中把缓冲输入作为标准, ANSI 没有提供调用无缓冲输入的标准方式

** 结束键盘输入

*** 文件, 流和键盘输入
    C 可以使用主机操作系统的基本文件工具直接处理文件, 这些直接调用操作系统的函数
    被称为底层 I/O (low-level I/O), 由于计算机系统各不相同, 所以不可能为普通的底
    层 I/O 函数创建标准库

    C 还可以通过标准 I/O 包(standard I/O package) 来处理文件. 这涉及创建用于处理文
    件的标准模型和一套标准 I/O 函数. 在这一层面上, 具体的 C 实现负责处理不同系统的差
    异, 以便用户使用统一的界面

    从概念上来看, C 程序处理的是流而不是直接处理文件. 流(stream)是一个世纪输入或
    输入映射的理想化数据流. 这意味着不同属性和不同种类的输入, 由属性更统一的流来
    表示. 于是, 打开文件的过程就是把流与文件相关联, 而且读写都通过流来完成

*** 文件结尾
1123123    无论操作系统实际使用何种方式检测文件结尾, 在 C 语言中, 用 getchar()读取文件检测
    到文件结尾时将返回一个特殊的值, 即 *EOF* (end of file 的缩写). scanf()函数检
    测到文件结尾时也返回 EOF. 通常, EOF 定义在 stdio.h 文件中:
    #+begin_src c
      #define EOF(-1)
    #+end_src
    EOF 是一个值, 标志着检测到文件结尾, 而不是在文件中找得到的符号
    在程序中使用 EOF:
    #+begin_src c
      while ((ch = getchar()) != EOF)
    #+end_src
    发送 EOF 字符:
    - UNIX: Ctrl+D
    - PC: Ctrl+Z

** 重定向和文件
   默认情况下, C 程序使用标准 I/O 包查找标准输入作为输入源. 这就是前面介绍过的
   stdin 流,它是把数据读入计算机的常用方式

   程序可以通过 2 种方式使用文件.
   1. 显示使用特定的函数打开\关闭\读取\写入文件.
   2. 设计能与键盘和屏幕互动的程序, 通过不同的取到重定向输入至文件和从文件输出.
      换言之, 把 stdin 流重新赋值给文件

*** UNIX, Linux 和 DOS 重定向
    重定向输入让程序使用文件而不是键盘来输入, 重定向输出让程序输出至文件而不是屏
    幕

    1. 重定向输入
       ~<~ 符号
       #+begin_src sh
         echo_eof < words
       #+end_src
    2. 重定向输出
       ~>~ 符号
       #+begin_src sh
         echo_eof > mywords
       #+end_src
    3. 组合重定向
       #+begin_src sh
         echo_eof < mywords > savewords
         echo_eof > savewords < mywords
       #+end_src
       命令与重定向运算符的 *顺序无关*
       注意: 在一条命令中, 输入文件名和输出文件名不能相同
       #+begin_src sh
         echo_eof < mywords > mywords
         # 错误, > mywords 在输入之前已导致原mywords的长度被截断为0
       #+end_src


    规则:
    1. 重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件, 不能
       用于连接一个数据文件和另一个数据文件, 也不能用于连接一个程序和另一个程序
    2. 使用重定向运算符不能读取多个文件的输入, 也不能把输出定向至多个文件
    3. 通常, 文件名和运算符之间的空格不是必须的

       补充:
       - ~>>~ 运算符: 可以把数据添加到先问文件的末尾
       - ~|~ 运算符: 把一个文件的输出连接到另一个文件的输入

         
    小结: 如果重定向输入和输出
    把输出重定向至文件: ~>~
    把输入重定向至文件: ~<~

** 输入验证
*** 分析程序(checking.c)
    程序遵循模块化的编程思想, 使用独立函数(模块)来验证输入和管理显示. 程序越大,
    使用模块化编程就越重要

    ~main()~ 函数管理程序流, 为其他函数委派任务. 它使用 ~get_long()~ 获取值, ~while~ 循
    环处理值, ~badlimits()~ 函数检查值是否有效, ~sum_squares()~ 函数处理实际的运算

*** 输入流和数字
    在编写处理错误输入的代码时, 可以很清楚C是如何处理输入的:
    #+begin_example
    is 28 12.4
    #+end_example
    在我们眼中, 这就像是一个由字符, 整数和浮点数组成的字符串. 但是对C程序而言,
    这是一个字节流. 第1个字节是字母i的字符编码, 第2个字节是字母s的字符编码, 第
    3个字节是空格字符的字符编码, 第4个字节是数字2的字符编码, 等等.
    
    如果 ~get_long()~ 函数处理这一行输入, 第1个字符是非数字, 那么整行输入都会被
    丢弃, 包括其中的数字, 因为这些数字只是该输入行中的其他字符
    
    虽然输入流由字符组成, 但是也可以设置 ~scanf()~ 函数把它们转换成数值:
    #+begin_example
    42
    #+end_example
    - 如果在 ~scanf()~ 函数中使用 ~%c~ 转换说明, 它只会读取字符4并将其储存在char类型
    的变量中. 
    - 如果使用 ~%s~ 转换说明, 它会读取字符4和字符2这2个字符, 并将其储存在字符数组
    中. 
    - 如果使用 ~%d~ 转换说明, ~scanf()~ 同样会读取2个字符, 但是随后会计算出它们
      对应的整数值: ~4 * 10 + 2~, 即 42, 然后将表示该整数的二进制数储存在int类型
      的变量中.
    - 如果使用 ~%f~ 转换说明, ~scanf()~ 也会读取2个字符, 计算出它们对应的数值42.0,
      用内部的浮点表示法表示该值, 并将结果储存在float类型的变量中

      
    总结: 输入由字符组成, 但是 ~scanf()~ 可以把输入转换成整数值或浮点数值, 使用转换
    说明(如 ~%d~ 或 ~%f~) 限制了可接受输入的字符类型, 而 ~getchar()~ 和使用 ~%c~
    的 ~scanf()~ 接受所有的字符

** 菜单浏览
*** 任务
    1. 获取选项
    2. 当选项不是 ~'q'~ 时
    3. 转至相应的选项并执行
    4. 获取下一个选项

*** 使执行更顺利
    需要为输入过程提供一个只返回正确相应的函数
    定义get_choice()函数只能返回'a', 'b', 'c'和'q'
    设计方案:
    1. 显示选项
    2. 获取用户响应
    3. 当响应不合适时
    4. 提示用户再次输入
    5. 获取用户响应

*** 混合字符和数值输入
    注意清理换行符

** 关键概念
   C程序把输入作为传入的字节流. ~getchar()~ 函数把每个字符解释成一个字符编码.
   ~scanf()~ 函数以同样的方式看待输入, 但是根据转换说明, 它可以把字符输入转换成
   数值. 许多操作系统都提供重定向, 允许用文件代替键盘输入, 用文件代替显示器输出
   
   程序通常接受特殊形式的输入. 可以在设计程序时考虑用户在输入时可能犯的错误, 在
   输入验证部分处理这些错误情况, 让程序更强健更友好

   对于一个小型程序, 输入验证可能是代码中最复杂的部分. 处理这类问题有多重解决方
   案. 例如, 如果用户输入错误类型的信息, 可以终止程序, 也可以给用户提供有限次或
   无限次机会重新输入

** 本章小结
   许多程序使用 ~getchar()~ 逐字符读取输入. 通常, 系统使用行缓冲输入, 即当用户按
   下 Enter 键 后输入才被传送给程序. 按下 Enter 键也传送了一个换行符, 编程时要注
   意处理这个换行符. ANSI C 把缓冲输入作为标准

   通过标准I/O包中的一系列函数, 以统一的方式处理不同系统中的不同文件形式, 是C语
   言的特性之一. getchar() 和 scanf() 函数也属于这一系列. 当检测到文件结尾时, 这
   2个函数都返回 *EOF* (被定义在stdio.h头文件中). 在不同系统中模拟文件结尾条件的
   方式稍有不同. UNIX系统中在一行开始处按下Ctrl+D可以模拟文件结尾条件, DOS则是
   Ctrl+Z

   许多操作系统(包括UNIX和DOS)都有重定向的特性, 因此可以用文件代替键盘和屏幕进行
   输入和输出. 读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号, 或者用于
   重定向文件

   混合使用getchar()和scanf()时, 如果在调用 getchar() 之前, scanf()在输入行留下
   一个换行符, 会导致一些问题, 及时处理此问题
