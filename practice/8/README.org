* 第 8 章
  
** 单字符 I/O: getchar()和 putchar()
   getchar()和 putchar()每次只处理一个字符.
   自从 ANSI C 标准发布以后, C 就把 stdio.h 头文件与使用 getchar()和 putchar()相关联
   getchar()和 putchar()都不是真正的函数, 它们被定义为供预处理器使用的宏

** 缓冲区
   - 无缓冲输入: 回显用户输入的字符后立即重复打印该字符, 即正在等待的程序可立即
     使用输入的字符

   - 缓冲输入: 大部分系统在用户按下 Enter 键之前不会重复打印刚输入的字符. 用户输入
     的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区, 按下 Enter 键后, 程
     序才可使用用户输入的字符
     1. 输入的字符被逐个送入缓冲区

     2. 程序可使用缓冲区的内容

        
   缓冲:
   1. 完全缓冲 I/O: 当缓冲区被填满时才刷新缓冲区(内容被发送至目的地), 通常出现在
      文件输入中. 缓冲区的大小取决于系统, 常见的大小是 512 字节和 4096 字节
   2. 行缓冲 I/O: 出现换行符时刷新缓冲区.

      
   ANSI C 中把缓冲输入作为标准, ANSI 没有提供调用无缓冲输入的标准方式

** 结束键盘输入

*** 文件, 流和键盘输入
    C 可以使用主机操作系统的基本文件工具直接处理文件, 这些直接调用操作系统的函数
    被称为底层 I/O (low-level I/O), 由于计算机系统各不相同, 所以不可能为普通的底
    层 I/O 函数创建标准库

    C 还可以通过标准 I/O 包(standard I/O package) 来处理文件. 这涉及创建用于处理文
    件的标准模型和一套标准 I/O 函数. 在这一层面上, 具体的 C 实现负责处理不同系统的差
    异, 以便用户使用统一的界面

    从概念上来看, C 程序处理的是流而不是直接处理文件. 流(stream)是一个世纪输入或
    输入映射的理想化数据流. 这意味着不同属性和不同种类的输入, 由属性更统一的流来
    表示. 于是, 打开文件的过程就是把流与文件相关联, 而且读写都通过流来完成

*** 文件结尾
1123123    无论操作系统实际使用何种方式检测文件结尾, 在 C 语言中, 用 getchar()读取文件检测
    到文件结尾时将返回一个特殊的值, 即 *EOF* (end of file 的缩写). scanf()函数检
    测到文件结尾时也返回 EOF. 通常, EOF 定义在 stdio.h 文件中:
    #+begin_src c
      #define EOF(-1)
    #+end_src
    EOF 是一个值, 标志着检测到文件结尾, 而不是在文件中找得到的符号
    在程序中使用 EOF:
    #+begin_src c
      while ((ch = getchar()) != EOF)
    #+end_src
    发送 EOF 字符:
    - UNIX: Ctrl+D
    - PC: Ctrl+Z

** 重定向和文件
   默认情况下, C 程序使用标准 I/O 包查找标准输入作为输入源. 这就是前面介绍过的
   stdin 流,它是把数据读入计算机的常用方式

   程序可以通过 2 种方式使用文件.
   1. 显示使用特定的函数打开\关闭\读取\写入文件.
   2. 设计能与键盘和屏幕互动的程序, 通过不同的取到重定向输入至文件和从文件输出.
      换言之, 把 stdin 流重新赋值给文件

*** UNIX, Linux 和 DOS 重定向
    重定向输入让程序使用文件而不是键盘来输入, 重定向输出让程序输出至文件而不是屏
    幕

    1. 重定向输入
       ~<~ 符号
       #+begin_src sh
         echo_eof < words
       #+end_src
    2. 重定向输出
       ~>~ 符号
       #+begin_src sh
         echo_eof > mywords
       #+end_src
    3. 组合重定向
       #+begin_src sh
         echo_eof < mywords > savewords
         echo_eof > savewords < mywords
       #+end_src
       命令与重定向运算符的 *顺序无关*
       注意: 在一条命令中, 输入文件名和输出文件名不能相同
       #+begin_src sh
         echo_eof < mywords > mywords
         # 错误, > mywords 在输入之前已导致原mywords的长度被截断为0
       #+end_src


    规则:
    1. 重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件, 不能
       用于连接一个数据文件和另一个数据文件, 也不能用于连接一个程序和另一个程序
    2. 使用重定向运算符不能读取多个文件的输入, 也不能把输出定向至多个文件
    3. 通常, 文件名和运算符之间的空格不是必须的

       补充:
       - ~>>~ 运算符: 可以把数据添加到先问文件的末尾
       - ~|~ 运算符: 把一个文件的输出连接到另一个文件的输入

         
    小结: 如果重定向输入和输出
    把输出重定向至文件: ~>~
    把输入重定向至文件: ~<~
