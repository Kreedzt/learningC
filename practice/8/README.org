* 第8章
  
** 单字符I/O: getchar()和putchar()
   getchar()和putchar()每次只处理一个字符.
   自从ANSI C标准发布以后, C就把stdio.h头文件与使用getchar()和putchar()相关联
   getchar()和putchar()都不是真正的函数, 它们被定义为供预处理器使用的宏

** 缓冲区
   - 无缓冲输入: 回显用户输入的字符后立即重复打印该字符, 即正在等待的程序可立即
     使用输入的字符

   - 缓冲输入: 大部分系统在用户按下Enter键之前不会重复打印刚输入的字符. 用户输入
     的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区, 按下Enter键后, 程
     序才可使用用户输入的字符
     1. 输入的字符被逐个送入缓冲区

     2. 程序可使用缓冲区的内容

        
   缓冲:
   1. 完全缓冲I/O: 当缓冲区被填满时才刷新缓冲区(内容被发送至目的地), 通常出现在
      文件输入中. 缓冲区的大小取决于系统, 常见的大小是 512 字节和 4096 字节
   2. 行缓冲I/O: 出现换行符时刷新缓冲区.

      
   ANSI C中把缓冲输入作为标准, ANSI没有提供调用无缓冲输入的标准方式

** 结束键盘输入

*** 文件, 流和键盘输入
    C可以使用主机操作系统的基本文件工具直接处理文件, 这些直接调用操作系统的函数
    被称为底层 I/O (low-level I/O), 由于计算机系统各不相同, 所以不可能为普通的底
    层 I/O 函数创建标准库

    C还可以通过标准I/O包(standard I/O package) 来处理文件. 这涉及创建用于处理文
    件的标准模型和一套标准I/O函数. 在这一层面上, 具体的C实现负责处理不同系统的差
    异, 以便用户使用统一的界面

    从概念上来看, C程序处理的是流而不是直接处理文件. 流(stream)是一个世纪输入或
    输入映射的理想化数据流. 这意味着不同属性和不同种类的输入, 由属性更统一的流来
    表示. 于是, 打开文件的过程就是把流与文件相关联, 而且读写都通过流来完成

*** 文件结尾
    无论操作系统实际使用何种方式检测文件结尾, 在C语言中, 用getchar()读取文件检测
    到文件结尾时将返回一个特殊的值, 即 *EOF* (end of file的缩写). scanf()函数检
    测到文件结尾时也返回EOF. 通常, EOF定义在stdio.h文件中:
    #+begin_src c
      #define EOF(-1)
    #+end_src
    EOF是一个值, 标志着检测到文件结尾, 而不是在文件中找得到的符号
    在程序中使用EOF:
    #+begin_src c
      while ((ch = getchar()) != EOF)
    #+end_src
    发送EOF字符:
    - UNIX: Ctrl+D
    - PC: Ctrl+Z
